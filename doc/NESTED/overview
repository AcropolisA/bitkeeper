
BitKeeper Nested overview
-------------------------

BitKeeper 5.0 introduces a new feature, BK/Nested.  BK/Nested is
technology that provides product and product line development support.
A product is a collection of repositories, called components, that are
grouped together and move in lock step as one.  Clones of a nested
collection may be fully or partially populated with components.

A product line is a development effort which spans multiple related
products.  In most cases, each product in a product line reuses some
or all components from other products in the product line.

A product is N+1 repositories: the N are components and the +1 is the 
product itself.  Each component belongs to the product just like files
belong to a repository.

The product repository is the "glue" that makes the set of components
all move forward in lock step; a product may be thought of as a way
to provide an audit trail for a collection of repositories much as a
repository provides an audit trail for a collection of files.  The value
to you is that all states of a product are reproducible and BitKeeper will
never let a user create a view of the source that is not reproducible
(unlike virtually all other SCM systems that scale to gigabytes of data).

The product feature makes it possible, even pleasant, to manage large
collections of files with good performance.  For example, for testing
we imported the entire FreeBSD CVS history.  Some numbers:

	  144 components
      149,051 files
      300,141 changesets (over all repositories)
    1,065,336 file deltas
	  2GB compressed history (4GB uncompressed)

and some performance numbers:

    Clone over network: 1.3 minutes (average of more than 23MB/sec)
    Local clone: 43 seconds
    Local clone of the kernel component only: 3 seconds
    Scan revision history of all files: 8.5 seconds

These numbers are without any performance tuning, we suspect we can
do better.  Even without tuning, they are reasonable given the amount
of data involved.  

Terminology
-----------
    BK/Nested - a collection of repositories which operate in lockstep
    Product - the repository at the top of the collection
    Component - a repository that "belongs" to the product
    Product line - a set of distinct products that reuse some/all components
    Alias - a symbolic name for one or more components
    Portal - an instance of a product used as a destination for bk port

New commands
------------
    bk alias - manage aliases for lists of components
    bk attach - clone and attach a repository to a product, creating a component
    bk comps - list components (here, missing, or all)
    bk detach - clone and detach a component into a standalone repository
    bk here - list or change the set of populated repositories
    bk partition - transform a repository into a nested collection
    bk port - pull changes from a different product's component
    bk portal - mark a product as a portal, aka a destination for bk port

Changed commands
----------------
    bk -A cmd - like bk -r <cmd> except works across product/components
    bk -U cmd - like bk -Ur <cmd> except works across product/components
    bk -s cmd - iterator, runs <cmd> in each of the product/components 
    	with -s<alias> runs only in the specified alias[es].
    bk changes - nested aware, i.e., bk changes -v includes component files
    bk citool - nested aware, scans all repositories, faster
    bk clone - has a new option to specify one or more aliases
    bk csettool - nested aware, spans all repositories
    bk difftool - nested aware, spans all repositories
    bk rset - is nested aware, spans all repositories
    bk setup - has a new option to create a product
    bk abort, commit, clone, pull, push, resolve, undo - obviously nested aware
    bk newroot - remembers old rootkeys (for port)

Creating a nested collection
----------------------------
    There are 3 ways to create a nested collection:
    a) create a new empty product repository with bk setup -P
    b) split a repository into a collection with bk partition
    c) clone a repository and use bk newroot -P to make it a product

Adding components to a nested collection
----------------------------------------
    Adding components is similar to running clone.  There is a
    bk attach command that will do both the clone and the bookkeeping
    to attach the component to the product.

    Currently, components may be added to any instance of a nested
    collection but this may change in the future to be limited to
    the portal instance of the collection so that the same component 
    is not added more than once.

Removing components from a nested collection
--------------------------------------------
    Removing components is the same as removing files from a standalone
    repository.  The only way to do it is to run csetprune and prune out
    the changeset key[s] for the component[s].  This will create a new
    product such that pull/push will not work from/to non-pruned instances
    of the product.  bk port will work.

Making changes in a nested collection
-------------------------------------
    Once you have your nested collection, it works almost identically
    to a traditional repository.  The clone/pull/push/resolve/abort/undo
    commands are all nested aware and do the right thing.  Commit is an
    exception (by design), you have to commit in each of the components
    first and then in the product.

    bk citool has been rewritten to hide all of this from you.  It scans
    all of the collection and presents any files that need comments as
    soon as they are found.  When you commit in citool it does the commit
    in each of the components and then in the product automatically.

Aliases
-------
    When managing larger collections of data, it is natural to want a way
    to clone a subset of the data.  It is possible to a clone a subset of
    the components that make up a product by naming one or more subsets,
    or aliases.

    An alias is a symbolic name for one or more components.  There is
    an aliases database, a versioned control file in the product, that
    defines the mapping between symbolic names and the list of components.
    There is an alias command that is used to manage the aliases database.

    Suppose that you had several components that made up a subset of
    your product.  If the aliases database has an entry for that subset,
    you may clone just the subset like so:

	$ bk clone -sCOMPILERS <url> [<destination>]

    If you later need some other collection of components, you use the
    here command to fetch them:

	$ bk here add DOCS

    BitKeeper remembers where all missing components can be found and by
    default bk here will try those locations to satisfy a request.  If
    that fails or you know a closer location then an optional URL to use
    can be passed as well.

    If you later need to remove some components, you use the here command
    as well:

	$ bk here rm DOCS

Product lines
-------------
    A product line is used when some or all of the same components are
    reused in other products.  It is reasonable to say that product
    lines are the SCM enablers for code reuse.

    A product line consists of two or more products, each of which
    while distinct from each other, shares one or more components.
    Examples where this sort of partitioning and reuse would be valuable
    include a family of cell phones, printers, and any other product
    line where various components may be shared across multiple products.

    Product line support in BitKeeper consists of two parts: the ability
    to use one product as the baseline for another product; and the
    ability to move changes across product boundaries.

    A product line is distinctly different than two clones of the same
    source code.  Unlike clones, the products are not constrained to two
    versions of the same source code; each product may share as little
    or as much as it wants with other products.  More importantly,
    each product has independent control over its own components.
    That point is key.  If you have two clones, updating one from the
    other is an all or nothing event, it is not possible to update just
    one subdirectory.  In a product line, product A can pick and and
    choose, on a per component basis, which components to update and
    when to update them.  If you've ever wanted the ability to hold one
    area stable while updating another, you want product lines.

    Product lines are supported via the bk port command.  The port
    command is similar to pull but works across different products on
    individual components.

    For example, suppose you had a product that was the source base for
    a printer (printers, cell phones, even CPUs are good examples of
    product lines where you want to make a new one based on an old one).

    In the simplest case, the new printer has all the same components
    as the old printer.  So you'd create a new printer like so:

	$ bk clone old-printer new-printer
	$ cd new-printer
	$ bk newroot -P

    If it turned out that you wanted only a subset of the features in
    the old printer, you could have specified those like so:

	$ bk clone -sfeatures-I-want old-printer new-printer
	$ bk comps -mk | bk csetprune -

    Once you have your new printer, you do development on that as normal.
    The old printer may continue to improve and you may want some or
    all of those improvements.	To get them, you must use the "bk port"
    command.

	$ bk port <old-printer-url>/usb

Combining repositories into a nested collection
-----------------------------------------------
    Suppose your current world consists of several different repositories,
    the source, tests, and documentation.  You may wish to combine those
    into a single product:

	$ bk setup -P product
	$ bk attach bk://server/source
	$ bk attach bk://server/tests
	$ bk attach bk://server/docs

    A new effort can use "product" and you might suppose you were done.
    Unfortunately, it is difficult or impossible to get everyone to
    switch at the same time, so it is likely that the old standalone
    repositories are still changing.

    Periodically, the project lead for the new nested product will want
    to get the changes from one or more of the standalone repositories.

	$ bk port bk://server/source

    will do the trick.

Splitting a repository into a nested collection
-----------------------------------------------
    We currently maintain two main trees of BitKeeper source, our stable
    tree that we call "bugfix" and the basis for BitKeeper 5.0 that we
    call "dev".  What is interesting is that "bugfix" is a traditional
    repository and "dev" is a nested collection.  Interesting because
    "bugfix" continues to be developed in parallel with "dev" and we
    want all of those changes in "dev".  Here is how that works.

    There is a bk partition command that is used to take a single
    repository and break it up into a nested collection.  It takes as
    input a set of directories and creates a component for each named
    directory and leaves the rest in the product.

    The resulting tree can then be pulled forward into the nested
    collection.  We've been doing this for more than a year and it works
    quite well.

    A simplified example:

	$ cd bugfix
	$ cat > COMPONENTS <<EOF
	src/gnu/patch
	src/gnu/diffutils
	src/libc
	src/gui
	src/t
	src/win32
	EOF
	$ bk partition -CCOMPONENTS . NESTED
	$ cd ../bk
	$ bk pull ../bugfix/NESTED

Out-sourcing
------------
    Suppose you wanted to out-source translation of the docs but you did
    not want to expose the source code.   Further suppose that the product
    changesets contained too much IP to let the product+docs out the door.

    The solution is to create a detached instance of the component, send
    that off to the external people, get back changes in the detached
    repository, and the project lead ports those into the collection:

	# Hand them the docs repo
	$ bk detach docs ../out-source
	$ cd ../out-source
	$ bk clone . bk://out-source-is-us/docs

	# they do their their work
	$ cd out-source
	$ bk pull
	
	# move it to the product
	$ cd ../product
	$ bk port ../out-source
	$ bk commit -Y'Drop from our crack out-sourcing team'

More examples/timing
--------------------
    The configs in question are 3ghz CPUs on both ends, gig ether,
    at least 4GB of ram on both ends, linux 2.6.26, ext2 file system.

    Truth in advertising: all numbers are hot cache, the config is
    checkout:none.

    $ time bk clone -q -s./src/sys bk://bits/freebsd kernel
    0m11.609s
    $ cd kernel
    $ du -sh .
    210M .
    $ bk comps -h
    src/sys
    $ time bk here add ./src/contrib/gcc
    0m1.574s
    $ bk comps -h
    src/contrib/gcc
    src/sys
    $ bk changes -r+ -vnd:GFILE:
    ChangeSet
    src/sys/ChangeSet
    src/sys/dev/ata/ata-all.h
    src/sys/dev/ata/ata-raid.c
    $ time bk -N co -q
    0m5.148s
    $ time bk -N clean
    0m0.956s
    $ du -sh .
    236M .
    # The following tells you how many files
    $ bk -N | wc -l
    8944
