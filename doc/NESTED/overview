
BitKeeper nested overview
-------------------------

BitKeeper 5.0 introduces a new feature, BK/Nested.  BK/Nested is
technology that provides product and product line development support.
A product is a collection of repositories, called components, that are
grouped together and operate as one.

A product line is a development effort which spans multiple related
products.  In most cases, each product in a product line reuses components
from other products in the product line.

A product is N+1 repositories: the N are components and the +1 is the 
product itself.  Each component belongs to the product just like files
belong to a repository.

The product repository is the "glue" that makes the set of components
all move forward in lock step; a product may be thought of as a way
to provide an audit trail for a collection of repositories much as a
repository provides an audit trail for a collection of files.  The value
to you is that all states of a product are reproducible and BitKeeper will
never let a user create a view of the source that is not reproducible.

The product feature makes it possible, even pleasant, to manage large
collections of files with good performance.  For example, for testing
we imported the entire FreeBSD CVS history.  Some numbers:

	  145 components
      149,051 files
      428,605 changesets (over all components)
    1,065,917 file deltas
	  2GB compressed history (4GB uncompressed)

and some performance numbers:

    Clone over network: 2 minutes (average of more than 15MB/sec)
    Local clone (hardlinked): 1 minute
    Scan revision history of all files: 12 seconds

These numbers are without any performance tuning, we suspect we can
do better.  Even without tuning, they are reasonable given the amount
of data involved.

Terminology
-----------
    BK/Nested - a collection of repositories which operate in lockstep
    Product - the repository at the top of the collection
    Component - a repository that "belongs" to the product
    Product line - a set of distinct products that reuse some/all components
    Alias - a symbolic name for one or more components
    Portal - an instance of a product used with bk port

New commands
------------
    bk alias - manage lists of components
    bk attach - clone and attach a repository to a product, creating a component
    bk components - list components (here, missing, or all)
    bk detach - clone and detach a component into a standalone repository
    bk partition - transform a repository into a nested collection
    bk populate - fill in component[s] in a sparse product repository
    bk port - pull changes from a different product's component
    bk portal - mark a product as a portal, aka a destination for bk port
    bk unpopulate - unfill in one or more components

Changed commands
----------------
    bk -A cmd - iterator, runs <cmd> in each of the product/components 
    bk -N cmd - like bk -r <cmd> except works across product/components
    bk changes - is nested aware, i.e., bk changes -v includes component files
    bk citool - nested aware, scans all repositories
    bk clone - has a new option to specify one or more aliases
    bk csettool - nested aware
    bk difftool - nested aware
    bk rset - is nested aware
    bk setup - has a new option to create a product
    bk abort, commit, clone, pull, push, resolve, undo - obviously nested aware
    bk newroot - remembers old rootkeys (for port)

Creating a nested collection
----------------------------
    There are 3 ways to create a nested collection:
    a) create a new empty product repository with bk setup -P
    b) split a repository into a collection with bk partition
    c) clone a repository and use bk newroot -P to make it a product

Adding components to a nested collection
----------------------------------------
    Adding components is similar to running clone.  There is a
    bk attach command that will do both the clone and the bookkeeping
    to attach the component to the product.

    Currently, components may be added to any instance of a nested
    collection but this may change in the future to be limited to
    the portal instance of the collection.

Removing components from a nested collection
--------------------------------------------
    Removing components is the same as removing files from a standalone
    repository.  The only way to do it is to run csetprune and prune out
    the changeset key[s] for the component[s].  This will create a new
    product such that pull/push will not work from/to non-pruned instances
    of the product.  bk port will work.

Making changes in a nested collection
-------------------------------------
    Once you have your nested collection, it works almost identically to
    a traditional repository.  The clone/pull/push/resolve/abort/undo
    commands are all nested aware and do the right thing.  Commit is
    currently an exception, you have to commit in each of the components
    first and then in the product.

    bk citool has been rewritten to hide all of this from you.  It scans
    all of the collection and presents any files that need comments as
    soon as they are found.  When you commit in citool it does the commit
    in each of the components and then in the product automatically.

Aliases
-------
When managing larger collections of data, it is natural to want a way
to clone a subset of the data.  It is possible to a clone a subset
of the components that make up a product by naming one or more subsets,
or aliases.

An alias is a symbolic name for one or more components.  There is a
aliases database, a versioned control file in the product, that 
defines the mapping between symbolic names and the list of components.
There is an alias command that is used to manage the aliases database.

Suppose that you had several components that made up a subset of 
your product.  If the aliases database has an entry for that subset,
you may clone just the subset like so:

    $ bk clone -sCOMPILERS <url> [<destination>]

If you later need some other collection of components, you use the
populate command to fetch them:

    $ bk populate -sDOCS

BitKeeper remembers where all missing components can be found and by
default populate will try those locations to satisify a request.  If
that fails or you know a closer location then an optional URL to use
can be passed as well.

There is an unpopulate command that will remove one or more components.

Product lines
-------------
A product line is used when some or all of the same components are reused
in other products.  It is reasonable to say that product lines are the
SCM enablers for code reuse.

A product line consists of two or more products, each of which while
distinct from each other, shares one or more components.  Examples where
this sort of partitioning and reuse would be valuable include a family
of cell phones, printers, and any other product line where various
components may be shared across multiple products.

Product line support in BitKeeper consists of two parts: the ability to
use one product as the baseline for another product; and the ability to
move changes across product boundaries.

A product line is distinctly different than two clones of the same
source code.  Unlike clones, the products are not constrained to two
versions of the same source code; each product may share as little
or as much as it wants with other products.  More importantly, each
product has independent control over its own components.  That point
is key.  If you have two clones, updating one from the other is an all
or nothing event, it is not possible to update just one subdirectory.
In a product line, product A can pick and and choose, on a per component
basis, which components to update and when to update them.  If you've
ever wanted the ability to hold one area stable while updating another,
you want product lines.

Product lines are supported via the bk port command.  The port command
is similar to pull but works across different products on individual
components.

For example, suppose you had a product that was the source base for a
printer (printers, cell phones, even CPUs are good examples of product
lines where you want to make a new one based on an old one).

In the simplest case, the new printer has all the same components as
the old printer.  So you'd create a new printer like so:

    $ bk clone old-printer new-printer
    $ cd new-printer
    $ bk newroot -P

If it turned out that you wanted only a subset of the features in the 
old printer, you could have specified those like so:

    $ bk clone -sfeatures-I-want old-printer new-printer
    $ bk components missing -k | bk csetprune -

Once you have your new printer, you do development on that as normal.
The old printer may continue to improve and you may want some or all 
of those improvements.  To get them, you must use the "bk port" command.

    $ bk port <old-printer-url>/usb

Combining repositories into a nested collection
-----------------------------------------------
Suppose your current world consists of several different repositories,
the source, tests, and documentation.  You may wish to combine those
into a single product:

    $ bk setup -P product
    $ bk attach bk://server/source
    $ bk attach bk://server/tests
    $ bk attach bk://server/docs

A new effort can use "product" and you might suppose you were done.
Unfortunately, it is difficult or impossible to get everyone to switch
at the same time, so it is likely that the old standalone repositories
are still changing.  

Periodically, the project lead for the new nested product will want to
get the changes from one or more of the standalone repositories.  

    $ bk port bk://server/source

will do the trick.

Splitting a repository into a nested collection
-----------------------------------------------
We currently maintain two main trees of BitKeeper source, our stable
tree that we call "bugfix" and the basis for BitKeeper 5.0 that we
call "dev".  What is interesting is that "bugfix" is a traditional
repository and "dev" is a nested collection.  Interesting because
"bugfix" continues to be developed in parallel with "dev" and we want
all of those changes in "dev".  Here is how that works.

There is a bk partition command that is used to take a single repository
and break it up into a nested collection.  It takes as input a set of
directories and creates a component for each named directory and leaves
the rest in the product.

The resulting tree can then be pulled forward into the nested collection.
We've been doing this for more than a year and it works quite well.

A simplified example:

    $ cd bugfix
    $ cat > COMPONENTS <<EOF
    src/gnu/patch
    src/gnu/diffutils
    src/libc
    src/gui
    src/t
    src/win32
    EOF
    $ bk partition -CCOMPONENTS . NESTED
    $ cd ../bk
    $ bk pull ../bugfix/NESTED

Out-sourcing
------------
Suppose you wanted to out-source translation of the docs but you did not
want to expose the source code.   Further suppose that the product changesets
contained too much IP to let the product+docs out the door.

The solution is to create a detached instance of the component, send that
off to the external people, get back changes in the detached repository,
and the project lead ports those into the collection:

    # Hand them the docs repo
    $ bk detach docs ../out-source
    $ cd ../out-source
    $ bk clone . bk://out-source-is-us/docs

    # they do their their work
    $ cd out-source
    $ bk pull
    
    # move it to the product
    $ cd ../product
    $ bk port ../out-source
    $ bk commit -Y'Drop from our crack out-sourcing team'

More examples/timing
--------------------
    The configs in question are 3ghz CPUs on both ends, gig ether,
    at least 4GB of ram on both ends, linux 2.6.26, ext2 file system.

    Truth in advertising: all numbers are hot cache, the config is
    checkout:none.

    $ time bk clone -q -s./src/sys bk://bits/freebsd kernel
    0m20.720s
    $ cd kernel
    $ du -sh .
    309M    .
    $ bk components here
    src/sys
    $ time bk populate -s./src/contrib/gcc
    0m4.052s
    $ bk components here
    src/contrib/gcc
    src/sys
    $ bk changes -r+ -vnd:GFILE:
    ChangeSet
    src/sys/ChangeSet
    src/sys/dev/ata/ata-all.h
    src/sys/dev/ata/ata-raid.c
    $ time bk -N co -q
    0m6.740s
    $ time bk -N clean
    0m2.176s
    $ du -sh .
    336M
    # The following tells you how many files
    $ bk -N | wc -l
    8944
