.so ../bk-macros
.TH "bk triggers" 1 20%E% "\*(BC" "\*(UM"
.SH NAME
bk triggers \- using \*(BK event triggers
.SH DESCRIPTION
.LP
\*(BK supports a variety of trigger types.   Triggers are simple programs,
usually shell scripts, which may be called before and/or after certain
events, such as a commit, pull, push, resolve, etc.
Triggers can be used for event notification 
and/or to implement control over the events themselves.
.LP
When a trigger is called, it is called with the current working
directory set to the root of the  repository.
Note that in the case of incoming data, the root of the
repository is defined as the RESYNC directory.
.LP
If an incoming changeset adds or updates a trigger, the incoming trigger is not
the trigger fired, with the exception of the post-incoming trigger.
The trigger already present in the repository, if any, is the trigger
used.  This arrangement is for security reasons; incoming changes could
be malicious or ill advised and a prudent repository manager may have
developed triggers to look for problems.  If the incoming data contained
a new or modified trigger, and that trigger was run, triggers could not
be used to implement security or other policies at the repository boundary.
.LP
Triggers only occur when events happen which (may) add changes.
The removal of changes via bk undo, bk unpull, etc, does not result
in any triggers being run.
.SS
TRIGGER NAMES
.LP
When an event occurs, if there exists a 
file BitKeeper/triggers/\c
.ARG event_class
in the repository root that corresponds to the event, 
\*(BK will execute that trigger.  For example, if there is
a push from repository B going into repository A 
and repository A has a file BitKeeper/triggers/pre-incoming, 
the pre-incoming script will be run before the push event 
applies to repository A.
.LP
All triggers for a particular class must be named with
the class name and prefix, for example \f(CWpre-incoming\fP.
More than one trigger per event class is allowed; each trigger program
has the class name and prefix and a suffix of your choosing.  The trigger
programs are sorted and run alphabetically (C locale sort order).  
Files ending in ~ are ignored to avoid editor backup files.
In order
to avoid name space conflicts, the typical approach is to use the reason
for the trigger as the suffix, i.e.,
.DS
post-incoming.mail
post-incoming.regression-test
.DE
.SS
TRIGGER CLASSES
.LP
There are multiple event classes which may activate triggers: incoming
events, outgoing events, deltas, commits, tags, and fix -c.
The incoming event is broken into
multiple events: incoming, resolve, and apply.
.LP
Most events may have triggers which run before and/or after the event.
The difference between
pre- and post- event triggers is that pre-triggers may cause events
to fail, but post-triggers are strictly informational.   
.LP
Not all triggers have both pre- and post- versions, the set of
supported triggers are as follows:
.de EV
.	if t .TP 
.	if n .TP 2
.	B \\$1
.	LI 3
..
.EV pre-commit
called before a changeset is committed.
.LI
exit 0 allows the commit. 
.LI
exit 1 fails the commit. If the commit was initiated from citool, 
citool will not exit. This allows the user to try the commit again. 
See example below.
.LI
exit 2 Reserved for future use (see pre-delta) and should not be used.
.EV post-commit
called after a changeset is committed or attempted to be committed.
.LI
typically used for notification.
.EV pre-delta
called before a delta is created. Can be use for triggers that check code style
.LI
exit 0 allows the delta.
.LI
exit 2 indicates that the trigger called delta itself, upon which the
calling delta command treats it as a successful delta.
.LI
Other than 2, all other non-zero exit values will fail the delta.
.EV pre-fix
called before a changeset is fixed (see bk fix(1)).
Typically used as part of a process to record the renaming of changesets in
bug tracking systems.
.LI
exit 0 allows the fix.
.LI
non-zero exit values will fail the fix.
.EV pre-incoming
called before an incoming push/pull is started.
.LI
non-zero exit status fails the incoming event.
.LI
typically used for locking down a repository.
.LI
may be used to fail the event based on remote user, host, directory,
and/or \*(BK version.
.EV post-incoming
called after the data has been applied to the tree.
.LI
typically used for notification.
.EV pre-outgoing
called before an outgoing pull/push/clone event.
.LI
non-zero exit status fails the outgoing event.
.LI
typically used for locking down a repository.
.EV post-outgoing
called after the outgoing event.
.LI
typically used for notification.
.EV pre-tag
called before a tag event, such as a bk commit with a specified tag or
a bk tag.
.LI
exit 0 allows the tag.
.LI
exit 1 causes the tag operation to fail as well as the commit operation if
the tag was part of a commit.
.LI
exit 2 causes the tag operation to fail but allows the commit operation to
proceed if the tag was part of a commit.
.EV pre-resolve
called after the data has been union-ed in the RESYNC directory.
.LI
called in the RESYNC directory, not the enclosing repository.
.LI
exit 0 allows the pull/push.
.LI
exit 1 fails the entire pull/push.
.LI
exit 2 fails the entire pull/push but leaves the patch in PENDING.
.LI
typically used to examine changes before taking them.
.EV pre-apply
called after the data has been merged in the RESYNC directory but
before it is applied to the tree.  Last chance to say no, allows examination
of the merge changes.
.LI
called in the RESYNC directory, not the enclosing repository.
.LI
exit 0 allows the pull/push.
.LI
exit 1 fails the entire pull/push.
.LI
exit 2 fails the pull/push but leaves the patch in PENDING.
.LI
exit 3 fails the pull/push but leaves the patch in PENDING and the
RESYNC tree in PENDING/RESYNC-<date>.
.LI
typically used to examine changes before taking them.
.SS
TRIGGER LOCKING
.LP
Triggers are called with a locked repository.
When a post trigger is called, the repository is read locked, even in 
the case that the event was an event which changed the repository.
A read lock will allow the trigger to do outgoing events, such as a push,
but will prevent incoming events.
Pre-incoming and pre-commit triggers will be called with a write locked
repository.
.SS
TRIGGER SECURITY ISSUES
.LP
Triggers are arbitrary programs (or scripts) which are run automatically
and without warning.  It is possible that a malicious person could add
a trigger which effect a security breach, damage files, etc.  If you are
operating in a non-trusted environment, you may disable all triggers by
setting the \f(CWBK_NO_TRIGGERS\fP environment variable.  This is the
safest thing to do but then the trigger functionality is lost.
.LP
Alternatively, a "paranoid" trigger could be added which refused to accept
a new trigger into a repository without being examined first.  Here's an
example of such a trigger, which would typically be named
\f(CWBitKeeper/triggers/pre-apply.paranoid\fP:
.DS
.ft CW
#!/bin/sh

# This is running in the RESYNC tree, we're looking
# for any new triggers and/or changes to triggers.
# Done after the resolve stage because they could
# be sneaky and create the file in an earlier
# changeset and then move it.

test `bk sfiles -g BitKeeper/triggers | wc -l` -gt 0 || exit 0

if [ $BK_SIDE = server ]
then    echo Refusing to accept any changes to triggers on push,
        echo get the project admin to pull your changes.
        exit 1
fi

rm -f BitKeeper/tmp/t_reject
for i in `bk sfiles -g BitKeeper/triggers`
do      (
        echo Please review the following trigger for security risks.
        echo Do not accept it if you think it is a problem.
        echo
        echo ===== $i =====
        bk cat $i
        ) > BitKeeper/tmp/prompt$$
        bk prompt -fBitKeeper/tmp/prompt$$ \\
	    -t"Review trigger" -yAccept -nReject
        STATUS=$?
        rm -f BitKeeper/tmp/prompt$$
        test $STATUS = 0 || {
                touch BitKeeper/tmp/t_reject
                break
        }
done
test -f BitKeeper/tmp/t_reject && {
        rm -f BitKeeper/tmp/t_reject
        exit 3
}
rm -f BitKeeper/tmp/t_reject
exit 0
.ft
.DE
.SS
TRIGGER ENVIRONMENT VARIABLES
.LP
Information which might be useful to the trigger is passed in environment
variables.  There are variables for user, host, location, \*[BK] version,
repository level, amongst others.
There are two classes of variables, client side variables
(\fBBK_*\fP) and server side variables (\fBBKD_*\fP).
The client side variables are associated with the user who
initiated the command.
The server side variables, if present, are associated with the "other"
repository.  For example, if a user on host "to" does a pull from host
"from", then BK_HOST=to and BKD_HOST=from.
In the list of variables which follow,
.B BKD_*
variables are not present unless the command has two end points,
such as  a pull, push, or clone.
The BKD_ variables are not defined for commit, resolve,
and apply events.
In all other cases, the variable is present in all triggers
unless otherwise stated.
.LP
.ip BK_CSETLIST 12
If set, contains the name of a file which contains the list of changesets
being received.  Valid in pre-outgoing, post-outgoing,
pre-resolve, pre-apply, and post-incoming triggers.
.ip BK_CSETS
If set, contains the list of changesets being sent.
Valid only in pre-outgoing and post-outgoing clone events.
.ip BK_COMMENTFILE
Location of the comment file for the changeset. Useful when writing
triggers that need to parse the changeset comments. See example
below.
.ip BK_EVENT
The event from the point of view of the trigger.  The full list of values
for this variable is
commit,
delta,
outgoing clone,
incoming push,
outgoing push,
incoming pull,
outgoing pull, 
resolve and apply.
.ip BK_FILE
Valid only in the pre-delta trigger, and contains the filename of the file
about to be delta-ed.
.ip BK_HOST
The hostname of the client side host.
.ip BKD_HOST
The hostname of the server side host.
.ip BK_LEVEL
The "level" of the client side repository.
.ip BKD_LEVEL
The "level" of the server side repository.
.ip BK_LOCALCSETS
The number of changesets (and/or tags) which are not
present in the remote repository but are present in the local repository.
Note that this variable does not have a BKD_ version because it
is valid only on the outgoing end of a pull or a push.
The other variable is BK_REMOTECSETS.
Both variables are valid in pre-outgoing and post-outgoing
triggers only.
.ip BK_PATCH
Valid only in the pre-resolve trigger,
and contains the full pathname of the file containing the patch being resolved.
.ip BK_PENDING
Contains the name of a file which
contains the list of files with pending deltas.
Valid only in pre-commit.
.ip BK_REMOTECSETS
The number of remote changesets (and/or tags) which are not
present in the local repository but are present in the remote
repository.
Goes with BK_LOCALCSETS and is valid only in pre-outgoing and
post-outgoing triggers.
.ip BK_ROOT
The full path name to the root of the client side repository.
.ip BKD_ROOT
The full path name to the root of the server side repository.
.ip BK_SIDE
If the trigger is part of a two-sided operation (i.e., pull, push), then
this is set to "server" if the trigger is running on the server repository.
Otherwise this is set to "client".
.ip BK_STATUS
The status of the command, if known.  Values may include:
.RS 
.ip NOTHING
There was nothing to pull or push.
.ip FAILED
The command did not complete because of an error.
.ip DRYRUN
The command did not complete because it was a "dry run", i.e., a 
pull -n to look to see if there is anything to pull.
.ip CONFLICTS
The command did not complete because there were conflicts (parallel work).
.ip SIGNALED
The command did not complete because it received a signal.
.ip OK
The command completed successfully.
.ip UNKNOWN
Unknown status.
.RE
.ip BK_TAG
If set, contains the value of the symbolic tag to be added to the repository.
Valid only in pre-tag trigger.
.ip BK_TAG_REV
If set, contains the changeset revision on which the tag will be placed.
This will be set if and only if the revision is not the most recent revision.
Valid only in pre-tag trigger.
.ip BK_TIME_T
The Unix style timestamp of the client side BK binary.
.ip BKD_TIME_T
The Unix style timestamp of the server side BK binary.
.ip BK_TRIGGER
The basename name of the trigger program.
.ip BK_USER
The user name of the user who ran the command on the client.
.ip BKD_USER
The user name of the user who ran the command on the server.
.ip BK_UTC
The time stamp of the client side BK binary expressed as YYYYMMDDHHMMSS.
.ip BKD_UTC
The time stamp of the server side BK binary expressed as YYYYMMDDHHMMSS.
.ip BK_VERSION
The version of the client side BK binary as the symbolic name or the UTC.
.ip BKD_VERSION
The version of the server side BK binary as the symbolic name or the UTC.
.SS
.SH "EXAMPLE 1"
.DS
.ft CW
.LP
#!/bin/sh

# Display info about incoming and outgoing csets.

if [ X$BK_STATUS = XDRYRUN -o X$BK_STATUS = XNOTHING ]
then	exit 0
fi
if [ $BK_SIDE = server ]
then U=$BKD_USER
     H=$BKD_HOST
     R=$BKD_ROOT
else U=$BK_USER
     H=$BK_HOST
     R=$BK_ROOT
fi
(
if [ X$BKD_ROOT != X ]
then	printf '%-10s%-20s%-20s\\n' VAR CLIENT SERVER
	printf '%-10s%-20s%-20s\\n' === ====== ======
	printf '%-10s%-20s%-20s\\n' USER $BK_USER $BKD_USER
	printf '%-10s%-20s%-20s\\n' HOST $BK_HOST $BKD_HOST
	printf '%-10s%-20s%-20s\\n' ROOT $BK_ROOT $BKD_ROOT
	printf '%-10s%-20s%-20s\\n' LEVEL $BK_LEVEL $BKD_LEVEL
	printf '%-10s%-20s%-20s\\n' TIME_T $BK_TIME_T $BKD_TIME_T
	printf '%-10s%-20s%-20s\\n' UTC $BK_UTC $BKD_UTC
	printf '%-10s%-20s%-20s\\n' VERSION $BK_VERSION $BKD_VERSION
	echo
fi
echo ${U}@${H} fired the $BK_TRIGGER trigger in $R
case $BK_TRIGGER in
    pre-outgoing)	VERB=Sending;;
    post-outgoing)	VERB=Sent;;
    pre-incoming)	VERB=Receiving;;
    post-incoming)	VERB=Received;;
    pre-resolve)	VERB=Resolving;;
    pre-commit)		VERB=Committing;;
    post-commit)	VERB=Committed;;
    pre-apply)		VERB=Applying;;
esac
if [ X$BK_PENDING != X ]
then	(
	echo $VERB the following deltas
	echo
	bk prs - < $BK_PENDING
	) | sed 's/^/    /'
fi
if [ X$BK_CSETLIST != X ]
then	(
	echo $VERB the following changesets
	echo
	bk changes -v - < $BK_CSETLIST
	) | sed 's/^/    /'
fi
if [ X$BK_CSETS != X ]
then	(
	echo $VERB the following changesets
	echo
	bk changes -v -r$BK_CSETS
	) | sed 's/^/    /'
fi
) | mail -s "$BK_EVENT in ${H}:${R}" notify@bitmover.com
.ft
.DE
.SH "EXAMPLE 2"
.DS
.ft CW
.LP
#!/bin/sh
#
# Using pre-commit trigger to verify changeset comment
# BitKeeper/trigger/pre-commit.cset_comments
#

grep -q 'BUGID:' $BK_COMMENTFILE && exit 0

msg="A 'BUGID:' field is needed in the checkin comments"

# Bring up an external program to browse bugs so that the
# engineer can add a valid bugid to the changeset comments.

#/opt/bugtrack/bin/bugviewer 'http://server.host.com/bugs?status=open' &

# Ask user if he needs to enter a bugid.  returning a non-zero exit
# code from the trigger will allow user to retry the commit from
# within citool.
bk prompt -y"Reenter bugid" -n"No bugid is required" "$msg" && exit 1

exit 0
.ft
.DE
.SH SEE ALSO
.SA commit 1
.SA delta 1
.SA fix 1
.SA prompt 1
.SA pull 1
.SA push 1
.SA tag 1
.SH CATEGORY
.B Repository
