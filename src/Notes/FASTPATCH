Fast patch is the patch generated by one pass makepatch / takepatch
It's just moving a subset of the weave in a way that uses the
code flow in makepatch and takepatch.

Changes to the patch format
---------------------------

Bump the version number to 1.4

Have only one diffs section per file, after all the
delta table.

Keep the general layout in place:

	== file
	delta header
	\n
	diffs (old but not new)
	\n
	tag header (to show that tags have empty patches)
	\n
	\n
	delta header
	\n
	diffs (this is where the new interleave diff goes)
	\n
	== anotherfile or sfio or patch checksum
	...

Two differences: all but the last diffs slots
must be blank ("\n\n"), and if a tag is last, it
looks like the tag will have a patch.  This is
because the last header and the diffs aren't
connected, just adjacent.

Note: the last diffs can be blank if no data is being
sent (such as tags or an exclude or empty merge node).

New interleaved diff format
---------------------------

If there is a diffs in the last block, it will start with
"F\n" and end with "K<chksum> <line-count>\n"

Then a mix of:
[DEIN]serial line
>data

Example:

F
I1 23
>here's a line
>here's another line
D2 25
>and even more
E2 25
E1 25
K2235 127

The serial number in the diffs is from the order
of the delta and tag headers in the patch.  The
first delta listed is serial 1.  The serials don't
appear anywhere in the header.

The line numbers are data as shown by 'bk annotate -R '
for the set of deltas shipped, and for files (but not
csets), the ancestors back to root.  Since the patch
most likely is shipping the tip in the patch, then the
line numbers would be from all data in the file.

The checksum is all those lines, and the final line
count is those lines as well.

The changeset file doesn't do the transitive closure
to root graph coloring.  It just uses the lines sent.
The reason for this is the patch would stop working
when chaining (or the half version of it: csetshrink)
comes online.

Weaving the diff
----------------

The SCCS weave has two relationships for placing of
commands and blocks of data: before or after an existing
text line.  That's straightforward enough.  However with
this weave, we're adding in older lines, and having it
looked like they were woven oldest to newest.  This adds
two more functions to movement.  When moving before,
stop if we get to the desired data token, but also
stop if we get to a D command with a higher serial
in an active region.  This is because the D commands
stack up before a data token in serial order:

^AD 12
^AD 14
^AD 17
some line that many people deleted.

If we are weaving a D 15, then we stop when we hit D 17.

The other additional move is after.  Not only do we move
after the desired token, but we see if there are any I
or E commands in the weave body that have a larger serial,
and skip those.  If it is an I command, then we skip over
the data block until we find the corresponding E.  Then
we resume the check.  Any D will stop the movement, as
D commands associate before the next token.  Also any
smaller I or E will stop the search.

put new stuff from serial 12 after this token
^AI 17
^AD 18
skip right over that D because it is an I-E block being ignored
^AE 18
and the rest of the block
^AE 17
stop before here because this is the next line

Read ahead one line
-------------------

The way the weave walk is setup is to keep a line buffer
w->buf, always set to the next line.  Before the process
is started, a line is read into the buffer.  Now the code
will look at that line, and if it wants to move past it,
will print it out to the new sfile, and then read the next
line into the w->buf.  If the weave walker decides it wants
to stop before the line in the buf, it exits and goes on
its merry way, leaving w->buf to be read next time a weave
walk is done.

Perf on the takepatch side
--------------------------

Between extractPatch() and sccs_fastWeave() is a pipeline
which could be collapsed into reading the sfile once in
the repo, then, if we need to, write it once to the RESYNC.
The patch can be read as a stream, without the mtell and
mseek and no mrange setups.  sccs_fastWeave should just
look for a blank line as end of patch.

This has been mostly written in a number of repos I have
(one based on bk and one on bugfix) but there were too
many moving parts for me to trust it shipping to a production
environment.  So the published version leaves the extra stages
and a file copy from repo to RESYNC and an extra init for
every sfile (once in the repo and once in the RESYNC). Granted,
right after a copy, things are cached.  If we are only going
with one init, then would might get file cache benefit by
pulling the INIT_NOCKSUM, but that's for later review.

At a minimum, might the filecopy be enhanced to be a hardlink
or copy like the resolver uses?

Another perf feature is to change takepatch to process patches
directly from from the stream.  Don't save the patch to PENDING, and
don't pre-scan the patch to validate the checksum.  Just process the
incoming patch directly overlapping the file IO with the network IO.
Then if the checksum is found to be wrong, delete the RESYNC directory
and return an error.
