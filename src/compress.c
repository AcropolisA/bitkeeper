/*
 * %W% %K%
 */

#include "bkd.h"

/*
 * Provide compress/uncompress streams using the zgets.c code.
 * This code need to be compatible with the previous version from bk-4.1
 * and earlier.
 *
 * This is a normal gzip stream of data split up into blocks so that
 * it can be read unbuffered without reading past the compressed
 * stream.  Each block starts with a 2-byte length count encoded in
 * network byte order followed by that number of bytes of data.  The
 * last block is just a 2-byte length of zero.
 *
 * This code has the following restrictions:
 *   - Each compressed block must be <= 32768 bytes including the header
 *
 * The data stream generated by this code must also be compatible with
 * bk-4.1 which has the following restrictions:
 *   - Each compressed block must be <= 4098 bytes (with header)
 *   - All data must be complete in the block before the block
 *     containing the gzip EOF marker and checksum.
 * (These two restrictions require zgets.c to use Z_PARTIAL_FLUSH and
 *  a blocksize of 4k)
 *
 * Neither version has a restriction on how much uncompressed data can
 * come from a single block.
 */

int
gzip_main(int ac, char **av)
{
	int c, rc, gzip_level = -1;

	unless (av[1]) {
		fprintf(stderr, "usage: %s -z|-u\n", av[0]);
		exit(1);
	}
	while ((c = getopt(ac, av, "z:u")) != -1) { 
		switch (c) {
		    case 'u':	gzip_level = -1; break;
		    case 'z':	gzip_level = atoi(optarg); break;
		    default:  
			    	fprintf(stderr,
					"usage bk _gzip [-z[n] | -u]\n");
			   	return (1);
		}
	}

	if (gzip_level >= 0) {
		rc = gzipAll2fh(0, stdout, gzip_level, 0, 0, 0);
	} else {
		rc = gunzipAll2fh(0, stdout, 0, 0);
	}
	return (rc);
}

private	int	incnt, outcnt;

int
gzipAll2fh(int rfd, FILE *wf, int level, int *in, int *out, int verbose)
{
	int	n, i = 0;
	char    *spin = "|/-\\";
	zputbuf	*zout;
	char	buf[8<<10];

	setmode(rfd, _O_BINARY);
	incnt = outcnt = 0;
	zout = zputs_init(zputs_hfwrite, wf, level);
	if (getenv("BK_NOTTY")) verbose = 0;
	/*
	 * must use readn() here, needed for consistant block sizes so
	 * recompressing the stream for http push won't change.
	 */
	while ((n = readn(rfd, buf, sizeof(buf))) > 0) {
		incnt += n;
		zputs(zout, buf, n);
		if (verbose) fprintf(stderr, "%c\b", spin[i++ % 4]);

	}
	if (zputs_done(zout)) return (-1);
	if (in) *in = incnt;
	if (out) *out = outcnt;
	return (0);
}

int
gunzipAll2fh(int rfd, FILE *wf, int *in, int *out)
{
	int	i, fd;
	int	moved = 0, offset = 0;
	zgetbuf	*zin;
	char	buf[8<<10];

	if (getenv("BK_REGRESSION")) {
		char	*p = getenv("BK_DIE_OFFSET");

		if (p) offset = atoi(p);
	}
	setmode(rfd, _O_BINARY);
	fflush(wf);
	fd = fileno(wf);
	incnt = outcnt = 0;
	zin = zgets_initCustom(zgets_hread, int2p(rfd));
	while ((i = zread(zin, buf, sizeof(buf))) > 0) {
		moved += i;
		if (offset && (moved >= offset)) exit(1);
		if (writen(fd, buf, i) != i) {
			perror("write");
			exit(1);
		}
		outcnt += i;
	}
	if (zgets_done(zin)) return (1);
	if (in) *in = incnt;
	if (out) *out = outcnt;
	return (0);
}


/*
 * callback used by zgets to read data from a stream.
 * Handles the 2-byte length markers.
 * This code uses unbuffer read()'s and should be avoided if possible.
 */
int
zgets_hread(void *token, u8 **buf)
{
	int	fd = p2int(token);
	int	i;
	u16	hlen;
	static	char *data = 0;
	static	int	len = -1;

	if (len == -1) {
		if (readn(fd, (void *)&hlen, 2) != 2) {
			perror("readn");
			exit(1);
		}
		incnt += 2;
		len = ntohs(hlen);
	}
	assert(len <= BSIZE-2);
	if (buf) {
		unless (data) data = malloc(BSIZE);
		*buf = data;
		unless (len) return (0);
		i = readn(fd, data, len + 2);
		if (i != len+2) {
			perror("unexpected data");
			return (0); /* force EOF */
		}
		incnt += i;
		memcpy(&hlen, data + len, 2);
		len = ntohs(hlen);
		return (i-2);
	} else {
		/* called from zgets_done */
		if (len != 0) {
			ttyprintf("failed to find trailer\n");
		}
		if (data) {
			free(data);
			data = 0;
			len = -1;
		}
		return (0);
	}
}

/*
 * callback used by zgets to read data from a file. Expects 2-byte
 * length markers before each block of data.
 */
int
zgets_hfread(void *token, u8 **buf)
{
	FILE	*f = token;
	u16	hlen;
	int	len, i;
	static	char *data = 0;

	if (fread((char *) &hlen, 1, sizeof(hlen), f) != sizeof(hlen)) {
		fprintf(stderr, "BAD gzip hdr\n");
		len = 0;
	} else {
		len = ntohs(hlen);
	}
	assert(len <= BSIZE-2);	/* match zgets_hread */
	if (buf) {
		unless (data) data = malloc(BSIZE);
		*buf = data;
		i = fread(data, 1, len, f);
		if (i != len) {
			perror("short read");
			return (0);	/* force eof */
		}
		return (i);
	} else {
		/* called from zgets_done */
		if (len != 0) {
			ttyprintf("failed to find trailer\n");
		}
		if (data) {
			free(data);
			data = 0;
		}
		return (0);
	}
}

/*
 * A callback to be used with zputs that writes blocks of data
 * proceeded by 2-byte length markers.
 */
void
zputs_hfwrite(void *token, u8 *data, int len)
{
	FILE	*f = token;
	u16	hlen;

	assert(len <= 4096);	/* legal for <= bk-4.1 */
	hlen = htons(len);
	fwrite(&hlen, 2, 1, f);
	if (len) fwrite(data, 1, len, f);
	outcnt += len + 2;
}

