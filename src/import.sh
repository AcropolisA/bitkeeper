#! @FEATURE_SH@

# import.sh - import various sorts of files into BitKeeper
# TODO
#	we allow repeated imports on patches but don't error check the other
#	cases.  We should fail if the repository is not empty.
# %W% %@%

import() {
	if [ X"$1" = "X--help" ]
	then	bk help import; exit 0;
	fi
	INCLUDE=""
	EXCLUDE=""
	LIST=""
	INC=NO
	EX=NO
	TYPE=
	RENAMES=YES
	QUIET=
	SYMBOL=
	FORCE=NO
	PARALLEL=1
	VERIFY=-h
	VERBOSE=-q
	CUTOFF=
	UNDOS=
	while getopts c:efHij:l:rS:t:uvq opt
	do	case "$opt" in
		c) CUTOFF=-c$OPTARG;;
		e) EX=YES;;
		f) FORCE=YES;;
		H) VERIFY=;;
		i) INC=YES;;
		j) PARALLEL=$OPTARG;;
		l) LIST=$OPTARG;;
		S) SYMBOL=-S$OPTARG;;
		r) RENAMES=NO;;
		t) TYPE=$OPTARG;;
		q) QUIET=-q; export _BK_SHUT_UP=YES;;
		u) UNDOS=-u;;
		v) VERBOSE=;;
		esac
	done
	shift `expr $OPTIND - 1`
	if [ X"$1" = X -o X"$2" = X -o X"$3" != X ]
	then	bk help -s import; exit 1;
	fi
	gettype $TYPE
	if [ $TYPE = patch ]
	then	if [ ! -f "$1" ]
		then	echo import: "$1" is not a patch file
			exit 1
		fi
		if [ X"$LIST" != X ]
		then	echo import: no lists allowed with patch files
			exit 1
		fi
		if [ "$EX" != NO -o $INC != NO ]
		then	echo import: no include/excludes allowed with patch files
			exit 1
		fi
	else	if [ ! -d "$1" ]
		then	echo import: "$1" is not a directory
			exit 1
		fi
	fi
	if [ ! -d "$2" ]
	then	echo import: "$2" is not a directory, run setup first
		exit 1
	fi
	if [ ! -d "$2/BitKeeper" ]
	then	echo "$2 is not a BitKeeper package"; exit 1
	fi
	HERE=`bk pwd`
	if [ $TYPE != patch ]
	then	cd "$1"
		FROM=`bk pwd`
		cd "$HERE"
	else	FROM="$1"
	fi
	cd "$2"
	TO="`bk pwd`"
	getIncExc
	if [ X"$LIST" != X ]
	then	cd "$HERE"
		if [ ! -s "$LIST" ]
		then	echo Empty file $LIST
			exit 1
		fi
		read path < $LIST
		case "$path" in
		/*) echo \
	    "Absolute pathnames are disallowed, they should relative to $FROM"
		    exit 1;;
		esac
		cd "$FROM"
		if [ ! -f "$path" ]
		then	echo No such file: $FROM/$path
			exit 1
		fi
		cd "$HERE"
		sed 's|^\./||'< $LIST > ${TMP}import$$
	else	if [ $TYPE != patch ]
		then	if [ X$QUIET = X ]
			then	echo Finding files in $FROM
			fi
			cd "$FROM"
			cmd="bk _find"
			if [ X"$INCLUDE" != X ]
			then	cmd="$cmd | egrep '$INCLUDE'"
			fi
			if [ X"$EXCLUDE" != X ]
			then	cmd="$cmd | egrep -v '$EXCLUDE'"
			fi
			eval "$cmd" > ${TMP}import$$
			if [ X$QUIET = X ]; then echo OK; fi
		else	echo "" > ${TMP}import$$
		fi
	fi
	if [ $TYPE != patch ]
	then	if [ X$QUIET = X ]
		then	echo Checking to make sure there are no files already in
			echo "	$TO"
		fi
		cd "$TO"
		while read x
		do	if [ -e "$x" ]
			then	echo "import: $x exists, entire import aborted"
				rm -f ${TMP}import$$
				exit 1
			fi
		done < ${TMP}import$$
		if [ $TYPE != SCCS ]
		then	bk _g2sccs < ${TMP}import$$ > ${TMP}sccs$$
			while read x
			do	if [ -e "$x" ]
				then	echo \
				    "import: $x exists, entire import aborted"
					rm -f ${TMP}sccs$$ ${TMP}import$$
					exit 1
				fi
			done < ${TMP}sccs$$
			if [ X$QUIET = X ]; then echo OK; fi
		fi
	fi
	rm -f ${TMP}sccs$$
	cd "$TO"
	eval validate_$type \"$FROM\" \"$TO\"
	transfer_$type "$FROM" "$TO"
	eval import_$type \"$FROM\" \"$TO\"
	import_finish "$TO"
}

getIncExc () {
	if [ "$INC" = YES ]
	then	echo End patterns with "." by itself or EOF
		echo $N "File name pattern to include>> " $NL
		while read x
		do	if [ X"$x" = X. ]; then break; fi
			if [ X"$x" = X ]; then break; fi
			if [ "X$INCLUDE" != X ]
			then	INCLUDE="$INCLUDE|$x"
			else	INCLUDE="$x"
			fi
			echo $N "File name pattern to include>> " $NL
		done
	fi
	if [ "$EX" = YES ]
	then	echo End patterns with "." by itself or EOF
		echo $N "File name pattern to exclude>> " $NL
		while read x
		do	if [ X"$x" = X. ]; then break; fi
			if [ X"$x" = X ]; then break; fi
			if [ "X$EXCLUDE" != X ]
			then	EXCLUDE="$EXCLUDE|$x"
			else	EXCLUDE="$x"
			fi
			echo $N "File name pattern to exclude>> " $NL
		done
	fi
}

gettype() {
	type=
	if [ "X$1" != X ]
	then	case "$1" in
		    plain)	type=text;;
		    patch)	type=patch;;
		    RCS|CVS)	type=RCS;;
		    SCCS)	type=SCCS;;
		esac
		if [ X$type != X ]
		then	TYPE=$type
			return
		fi
	fi
	cat <<EOF

BitKeeper can currently handle the following types of imports:

    plain	- these are regular files which are not under revision control
    patch	- a patch file generated by diff -Nur
    SCCS	- SCCS files which are not presently under BitKeeper
    RCS		- files controlled by RCS
    CVS		- files controlled by CVS

If the files you wish to import do not match any of these forms, you will
have to write your own conversion scripts.  See the rcs2sccs program for
an example.  If you write such a script, please consider contributing
it to the BitKeeper project.

EOF
	TRY=yes
	while [ $TRY = yes ]
	do	echo $N "Type of files to import? " $NL
		read type
		TRY=no
		case "$type" in
		    pa*) type=patch;;
		    pl*) type=text;;
		    R*|C*) type=RCS;;
		    S*) type=SCCS;;
		    *)	echo Please use one of plain, patch, RCS, CVS, or SCCS
			TRY=yes
		    	;;
		esac
	done
	TYPE=$type
}


transfer_RCS() { transfer "$@"; }
transfer_SCCS() { transfer "$@"; }
transfer_text() { transfer "$@"; }
transfer_patch() { return; }

transfer() {
	FROM="$1"
	TO="$2"
	TYPE="$3"
	NFILES=`wc -l < ${TMP}import$$ | sed 's/ //g'`
	if [ $FORCE = NO ]
	then	echo
		echo $N "Would you like to edit the list of $NFILES files to be imported? " $NL
		read x
		echo ""
		case X"$x" in
		    Xy*)
			echo $N "Editor to use [$EDITOR] " $NL
			read editor
			echo
			if [ X$editor != X ]
			then	eval $editor ${TMP}import$$
			else	eval $EDITOR ${TMP}import$$
			fi
			NFILES=`wc -l < ${TMP}import$$ | sed 's/ //g'`
		esac
	fi
	if [ X$QUIET = X ]
	then	echo Transfering files
		echo "	from $FROM"
		echo "	to   $TO"
	fi
	cd "$FROM"
	bk sfio -omq < ${TMP}import$$ | (cd "$TO" && bk sfio -im $VERBOSE ) || exit 1
}

import_patch() {

	PATCH=$1
	PNAME=`basename $PATCH`
	SAVE=$USER
	USER=patch
	export USER
	Q=$QUIET
	cd "$2"

	# This must be done after we cd to $2
	case `bk version` in
	*Basic*)	RENAMES=NO
			;;
	esac
	
	echo Locking files in `pwd` ...
	bk -r get -eq
	echo Patching...
	(cd "$HERE" && cat "$PATCH") |
	    bk patch -p1 -ZsE -z '=-PaTcH_BaCkUp!' --forcetime --lognames > \
		${TMP}plog$$ 2>&1
	cat ${TMP}plog$$
	bk sfiles -x | grep '=-PaTcH_BaCkUp!$' | bk _unlink
	REJECTS=NO
	find .  -name '*.rej' -print > ${TMP}rejects$$
	while [ -s ${TMP}rejects$$ ]
	do 	echo "Patch rejects:"
		cat ${TMP}rejects$$
		echo
		echo Dropping you into a shell to clean the rejects.
		echo Please fix the rejects and then exit the shell 
		echo to continue the import
		sh -i
		find .  -name '*.rej' -print > ${TMP}rejects$$
	done
	grep '^Creating file ' ${TMP}plog$$ |
	    sed 's/Creating file //' > ${TMP}creates$$
	grep '^Removing file ' ${TMP}plog$$ |
	    sed 's/Removing file //' > ${TMP}deletes$$
	if [ $RENAMES = YES ]
	then	echo Checking for potential renames in `pwd` ...
		# Go look for renames
		if [ -s ${TMP}deletes$$ -a -s ${TMP}creates$$ ]
		then	(
			if [ -s ${TMP}deletes$$ ]
			then	cat ${TMP}deletes$$
			fi
			echo ""
			if [ -s ${TMP}creates$$ ]
			then	cat ${TMP}creates$$
	    		fi ) | bk renametool $Q
		fi

		echo Checking in new or modified files in `pwd` ...
		# Do the deletes automatically
		if [ -s ${TMP}deletes$$ -a ! -s ${TMP}creates$$ ]
		then	bk rm - < ${TMP}deletes$$
		fi
		# Do the creates automatically
		if [ ! -s ${TMP}deletes$$ -a -s ${TMP}creates$$ ]
		then	bk new $Q -G -y"Import patch $PNAME" - < ${TMP}creates$$
		fi
	else	# Just delete and create
		echo Checking in new or modified files in `pwd` ...
		bk rm - < ${TMP}deletes$$
		bk new $Q -G -y"Import patch $PNAME" - < ${TMP}creates$$
	fi
	rm -f ${TMP}creates$$ ${TMP}deletes$$

	if [ X$Q = X ]
	then	bk -r clean -q
	fi

	bk -r ci $VERBOSE -G -y"Import patch $PNAME"

	bk sfiles -x | grep -v '^BitKeeper/' > ${TMP}extras$$
	if [ -s ${TMP}extras$$ ]
	then	echo There were extra files, patch aborted, here is the list
		cat ${TMP}extras$$
		echo
		echo "Patch aborted, you must clean up by hand, XXX"
		Done 1
    	fi

	USER=$SAVE
	# Ask about logging before commit, commit reads stdin.
	bk _loggingask
	if [ $? -eq 1 ]
	then 	Done 1
	fi
	echo Creating changeset for $PNAME in `pwd` ...
	bk sfiles -C | bk commit $SYMBOL -a -y"`basename $PNAME`" -
	echo Done.
	Done 0
}

import_text () {
	Q=$QUIET

	cd "$2"
	if [ X$QUIET = X ]; then echo Checking in plain text files...; fi
	CLOCK_DRIFT=1 bk ci -1i $VERBOSE - < ${TMP}import$$ || exit 1
}

import_RCS () {
	cd "$2"
	echo Converting RCS files.
	echo WARNING: Branches will be discarded.
	if [ $PARALLEL -eq 1 ]
	then	bk rcs2sccs $UNDOS $CUTOFF $VERIFY $QUIET - < ${TMP}import$$ ||
		    exit 1
		bk _unlink < ${TMP}import$$
		return
	fi
	LINES=`wc -l < ${TMP}import$$`
	LINES=`expr $LINES / $PARALLEL`
	split -$LINES ${TMP}import$$ ${TMP}split$$
	for i in ${TMP}split$$*
	do	bk rcs2sccs $UNDOS $CUTOFF $VERIFY $QUIET -q - < $i &
	done
	wait
	bk _unlink < ${TMP}import$$
}

import_SCCS () {
	cd "$2"
	echo Checking for and fixing Teamware corruption...
	bk sfiles | bk renumber -q -
	if [ -s ${TMP}reparent$$ ]
	then	echo Reparenting files from some other BitKeeper package...
		sed 's/ BitKeeper$//' < ${TMP}reparent$$ | \
		while read x
		do	if [ -f "$x" ]
			then	echo "$x"
			fi
		done | bk admin -CC -
		echo OK
	fi
	rm -f ${TMP}reparent$$
	echo Making sure all files have pathnames, proper dates, and checksums
	bk sfiles -g | while read x
	do	bk admin -0q "$x"
		bk admin -q -u -p"$x" "$x"
		bk rechksum -f "$x"
	done
}

import_finish () {
	cd "$1"
	if [ X$QUIET = X ]; then echo ""; fi
	if [ X$QUIET = X ]; then echo Validating all SCCS files; fi
	bk sfiles | bk admin -hhhq - > ${TMP}admin$$
	if [ -s ${TMP}admin$$ ]
	then	echo Import failed because
		cat ${TMP}admin$$
		exit 1
	fi
	if [ X$QUIET = X ]; then echo OK; fi
	
	rm -f ${TMP}import$$ ${TMP}admin$$
	bk sfiles -r
	# So it doesn't run consistency check.
	touch BitKeeper/etc/SCCS/x.marked
	if [ X$QUIET = X ]
	then echo "Creating initial changeset (should be +$NFILES)"
	fi
	bk commit $QUIET $SYMBOL -y'Import changeset'
}

validate_SCCS () {
	FROM="$1"
	TO="$2"
	cd "$FROM"
	grep 'SCCS/s\.' ${TMP}import$$ > ${TMP}sccs$$
	grep -v 'SCCS/s\.' ${TMP}import$$ > ${TMP}notsccs$$
	if [ -s ${TMP}sccs$$ -a -s ${TMP}notsccs$$ ]
	then	NOT=`wc -l < ${TMP}notsccs$$ | sed 's/ //g'`
		echo
		echo Skipping $NOT non-SCCS files
		echo $N "Do you want to see this list of files? [No] " $NL
		read x
		case "$x" in
		y*)	sed 's/^/	/' < ${TMP}notsccs$$ | more ;;
		esac
		mv ${TMP}sccs$$ ${TMP}import$$
	fi
	rm -f ${TMP}notsccs$$ ${TMP}sccs$$
	bk sfiles -cg $FROM > ${TMP}changed$$
	if [ -s ${TMP}changed$$ ]
	then	echo The following files are locked and modified in $FROM
		cat ${TMP}changed$$
		echo
		echo Can not import unchecked in SCCS files
		exit 1
	fi
	rm -f ${TMP}changed$$
	grep 'SCCS/s\.' ${TMP}import$$ | prs -hr -d':PN: :TYPE:' - | grep ' BitKeeper' > ${TMP}reparent$$
	if [ -s ${TMP}reparent$$ ]
	then	cat <<EOF

You are trying to import BitKeeper files into a BitKeeper package.
We can do this, but it means that you are goint to "reparent" these
files under a new ChangeSet file.  In general, that's not a good idea,
because you will lose all the old ChangeSet history in the copied files.
We can do it, but don't do it unless you know what you are doing.

The following files are marked as BitKeeper files:
EOF
		sed 's/ BitKeeper$//' < ${TMP}reparent$$ | sed 's/^/	/'
		echo ""
		echo $N "Reparent the BitKeeper files? [No] " $NL
		read x
		case "$x" in
		y*)	;;
		*)	rm -f ${TMP}sccs$$ ${TMP}import$$ ${TMP}reparent$$
			exit 1
		esac
		echo $N "Are you sure? [No] " $NL
		read x
		case "$x" in
		y*)	;;
		*)	rm -f ${TMP}sccs$$ ${TMP}import$$
			exit 1
		esac
		echo OK
	fi
}

validate_RCS () {
	grep ',v$' ${TMP}import$$ >${TMP}rcs$$
	# Filter out CVS repository metadata here.
	grep -v ',v$' ${TMP}import$$ | egrep -v 'CVS|#cvs' >${TMP}notrcs$$
	if [ -s ${TMP}rcs$$ -a -s ${TMP}notrcs$$ ]
	then	NOT=`wc -l < ${TMP}notrcs$$ | sed 's/ //g'`
		echo
		echo Skipping $NOT non-RCS files
		echo $N "Do you want to see this list of files? [No] " $NL
		read x
		case "$x" in
		y*)	sed 's/^/	/' < ${TMP}notrcs$$ | more ;;
		esac
	fi
	mv ${TMP}rcs$$ ${TMP}import$$
	rm -f ${TMP}notrcs$$
}

validate_text () {
	FROM="$1"
	TO="$2"
	cd "$FROM"
	egrep 'SCCS/s\.|,v$' ${TMP}import$$ > ${TMP}nottext$$
	egrep -v 'SCCS/s\.|,v$' ${TMP}import$$ > ${TMP}text$$
	if [ -s ${TMP}text$$ -a -s ${TMP}nottext$$ ]
	then	NOT=`wc -l < ${TMP}nottext$$ | sed 's/ //g'`
		echo
		echo Skipping $NOT non-RCS files
		echo $N "Do you want to see this list of files? [No] " $NL
		read x
		case "$x" in
		y*)	sed 's/^/	/' < ${TMP}nottext$$ | more ;;
		esac
		mv ${TMP}text$$ ${TMP}import$$
		rm -f ${TMP}nottext$$
	fi
	rm -f ${TMP}nottext$$ ${TMP}text$$
}

# Make sure there are no locked/extra files
validate_patch() {
	cd "$2"
	echo Make sure there are no locked files in `pwd` ...
	bk sfiles -l | grep -v BitKeeper/ > ${TMP}locked$$
	if [ -s ${TMP}locked$$ ]
	then	echo Not patching because of locked files:
		cat ${TMP}locked$$
		Done 1
    	fi
	echo Make sure there are no extra files in `pwd` ...
	bk sfiles -x | grep -v BitKeeper/ > ${TMP}extras$$
	if [ -s ${TMP}extras$$ ]
	then	echo Not patching because of extra files:
		cat ${TMP}extras$$
		Done 1
    	fi
	rm -f ${TMP}locked$$ ${TMP}extras$$
}

Done() {
	for i in rejects plog extras locked import sccs
	do	rm -f ${TMP}${i}$$
	done
	exit $1
}

init() {
	__platformInit;
	if [ '-n foo' = "`echo -n foo`" ]
	then    NL='\c'
	        N=
	else    NL=
		N=-n
	fi
	if [ X$EDITOR = X ]
	then	EDITOR=vi
	fi
}

init
import "$@"
exit 0
