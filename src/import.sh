#! @SH@

# import.sh - import various sorts of files into BitKeeper
# TODO
#	we allow repeated imports on patches but don't error check the other
#	cases.  We should fail if the repository is not empty.
# %W% %@%

usage() {
	cat <<EOF
Usage: import [-efirv] [-l<list>] [-t<type] from_dir to_dir

	-e	prompts for regular expression to exclude from file list
	-f	force the import to not ask questions
	-i	prompts for regular expression to include from file list
	-l<l>	list of files to import is in <l>
	-t<t>	type of imported files is <t> where t is plain|patch|RCS|CVS
	-r	do not do renames when doing patch imports
	-v	be more verbose
EOF
	exit 0
}

import() {
	if [ X"$1" = "X--help" ]
	then	usage
	fi
	INCLUDE=""
	EXCLUDE=""
	LIST=""
	INC=NO
	EX=NO
	TYPE=
	NEWLOD=
	RENAMES=YES
	QUIET=-q
	SYMBOL=
	FORCE=NO
	while getopts efil:LrS:t:v opt
	do	case "$opt" in
		e) EX=YES;;
		f) FORCE=YES;;
		i) INC=YES;;
		l) LIST=$OPTARG;;
		L) NEWLOD=-L;;
		S) SYMBOL=-S$OPTARG;;
		r) RENAMES=NO;;
		t) TYPE=$OPTARG;;
		v) QUIET=;;
		esac
	done
	shift `expr $OPTIND - 1`
	if [ X"$1" = X -o X"$2" = X -o X"$3" != X ]
	then	usage
	fi
	gettype $TYPE
	if [ $TYPE = patch ]
	then	if [ ! -f "$1" ]
		then	echo import: "$1" is not a patch file
			exit 1
		fi
		if [ X"$LIST" != X ]
		then	echo import: no lists allowed with patch files
			exit 1
		fi
		if [ "$EX" != NO -o $INC != NO ]
		then	echo import: no include/excludes allowed with patch files
			exit 1
		fi
	else	if [ ! -d "$1" ]
		then	echo import: "$1" is not a directory
			exit 1
		fi
	fi
	if [ ! -d "$2" ]
	then	echo import: "$2" is not a directory, run setup first
		exit 1
	fi
	if [ ! -d "$2/BitKeeper" ]
	then	echo "$2 is not a BitKeeper project"; exit 1
	fi
	HERE=`pwd`
	if [ $TYPE != patch ]
	then	cd $1
		FROM=`pwd`
		cd $HERE
	else	FROM=$1
	fi
	cd $2
	TO=`pwd`
	getIncExc
	if [ X"$LIST" != X ]
	then	cd $HERE
		if [ ! -s "$LIST" ]
		then	echo Empty file $LIST
			exit 1
		fi
		read path < $LIST
		case "$path" in
		/*) echo \
	    "Absolute pathnames are disallowed, they should relative to $FROM"
		    exit 1;;
		esac
		cd $FROM
		if [ ! -f $path ]
		then	echo No such file: $FROM/$path
			exit 1
		fi
		cd $HERE
		sed 's|^\./||'< $LIST > ${TMP}import$$
	else	if [ $TYPE != patch ]
		then	echo Finding files in $FROM
			cd $FROM
			cmd="bk files"
			if [ X"$INCLUDE" != X ]
			then	cmd="$cmd | egrep '$INCLUDE'"
			fi
			if [ X"$EXCLUDE" != X ]
			then	cmd="$cmd | egrep -v '$EXCLUDE'"
			fi
			eval "$cmd" > ${TMP}import$$
			echo OK
		else	echo "" > ${TMP}import$$
		fi
	fi
	if [ $TYPE != patch ]
	then	echo Checking to make sure there are no files
		echo already in $TO
		cd $TO
		while read x
		do	if [ -e $x ]
			then	echo import: $x exists, entire import aborted
				rm -f ${TMP}import$$
				exit 1
			fi
		done < ${TMP}import$$
		if [ $TYPE != SCCS ]
		then	bk g2sccs < ${TMP}import$$ > ${TMP}sccs$$
			while read x
			do	if [ -e $x ]
				then	echo \
				    "import: $x exists, entire import aborted"
					rm -f ${TMP}sccs$$ ${TMP}import$$
					exit 1
				fi
			done < ${TMP}sccs$$
			echo OK
		fi
	fi
	rm -f ${TMP}sccs$$
	cd $TO
	eval validate_$type $FROM $TO
	transfer_$type $FROM $TO
	eval import_$type $FROM $TO
	import_finish $TO
}

getIncExc () {
	if [ "$INC" = YES ]
	then	echo End patterns with "." by itself or EOF
		echo $N "File name pattern to include>> " $NL
		while read x
		do	if [ X"$x" = X. ]; then break; fi
			if [ X"$x" = X ]; then break; fi
			if [ "X$INCLUDE" != X ]
			then	INCLUDE="$INCLUDE|$x"
			else	INCLUDE="$x"
			fi
			echo $N "File name pattern to include>> " $NL
		done
	fi
	if [ "$EX" = YES ]
	then	echo End patterns with "." by itself or EOF
		echo $N "File name pattern to exclude>> " $NL
		while read x
		do	if [ X"$x" = X. ]; then break; fi
			if [ X"$x" = X ]; then break; fi
			if [ "X$EXCLUDE" != X ]
			then	EXCLUDE="$EXCLUDE|$x"
			else	EXCLUDE="$x"
			fi
			echo $N "File name pattern to exclude>> " $NL
		done
	fi
}

gettype() {
	type=
	if [ "X$1" != X ]
	then	case "$1" in
		    plain)	type=text;;
		    patch)	type=patch;;
		    RCS|CVS)	type=RCS;;
		    SCCS)	type=SCCS;;
		esac
		if [ X$type != X ]
		then	TYPE=$type
			return
		fi
	fi
	cat <<EOF

BitKeeper can currently handle the following types of imports:

    plain	- these are regular files which are not under revision control
    patch	- a patch file generated by diff -Nur
    SCCS	- SCCS files which are not presently under BitKeeper
    RCS		- files controlled by RCS
    CVS		- files controlled by CVS

If the files you wish to import do not match any of these forms, you will
have to write your own conversion scripts.  See the rcs2sccs perl script
for an example.  If you write such a script, please consider contributing
it to the BitKeeper project.

EOF
	TRY=yes
	while [ $TRY = yes ]
	do	echo $N "Type of files to import? " $NL
		read type
		TRY=no
		case "$type" in
		    pa*) type=patch;;
		    pl*) type=text;;
		    R*|C*) type=RCS;;
		    S*) type=SCCS;;
		    *)	echo Please use one of plain, patch, RCS, CVS, or SCCS
			TRY=yes
		    	;;
		esac
	done
	TYPE=$type
}


transfer_RCS() { transfer "$@"; }
transfer_SCCS() { transfer "$@"; }
transfer_text() { transfer "$@"; }
transfer_patch() { return; }

transfer() {
	FROM=$1
	TO=$2
	TYPE=$3
	NFILES=`wc -l < ${TMP}import$$ | sed 's/ //g'`
	if [ $FORCE = NO ]
	then	echo
		echo $N "Would you like to edit the list of $NFILES files to be imported? " $NL
		read x
		echo ""
		case X"$x" in
		    Xy*)
			echo $N "Editor to use [$EDITOR] " $NL
			read editor
			echo
			if [ X$editor != X ]
			then	eval $editor ${TMP}import$$
			else	eval $EDITOR ${TMP}import$$
			fi
			NFILES=`wc -l < ${TMP}import$$ | sed 's/ //g'`
		esac
	fi
	echo Importing files
	echo "	from $FROM"
	echo "	to   $TO"
	cd $FROM
	bk sfio -omq < ${TMP}import$$ | (cd $TO && bk sfio -im $QUIET ) || exit 1
}

import_patch() {

	PATCH=$1
	PNAME=`basename $PATCH`
	SAVE=$USER
	USER=patch
	export USER
	Q=$QUIET
	cd $2
	echo Locking files in `pwd` ...
	bk -r get -eq
	echo Patching...
	(cd $HERE && cat $PATCH) |
	    bk patch -p1 -ZsE -z '=-PaTcH_BaCkUp!' --forcetime --lognames > \
		${TMP}plog$$ 2>&1
	cat ${TMP}plog$$
	bk sfiles -x | grep '=-PaTcH_BaCkUp!$' | xargs rm -f
	REJECTS=NO
	find .  -name '*.rej' -print > ${TMP}rejects$$
	while [ -s ${TMP}rejects$$ ]
	do 	echo "Patch rejects:"
		cat ${TMP}rejects$$
		echo
		echo Dropping you into a shell to clean the rejects.
		echo Please fix the rejects and then exit the shell 
		echo to continue the import
		sh -i
		find .  -name '*.rej' -print > ${TMP}rejects$$
	done
	grep '^Creating file ' ${TMP}plog$$ |
	    sed 's/Creating file //' > ${TMP}creates$$
	grep '^Removing file ' ${TMP}plog$$ |
	    sed 's/Removing file //' > ${TMP}deletes$$
	if [ $RENAMES = YES ]
	then	echo Checking for potential renames in `pwd` ...
		# Go look for renames
		if [ -s ${TMP}deletes$$ -a -s ${TMP}creates$$ ]
		then	(
			if [ -s ${TMP}deletes$$ ]
			then	cat ${TMP}deletes$$
			fi
			echo ""
			if [ -s ${TMP}creates$$ ]
			then	cat ${TMP}creates$$
	    		fi ) | bk renametool $Q
		fi

		echo Checking in new or modified files in `pwd` ...
		# Do the deletes automatically
		if [ -s ${TMP}deletes$$ -a ! -s ${TMP}creates$$ ]
		then	bk rm - < ${TMP}deletes$$
		fi
		# Do the creates automatically
		if [ ! -s ${TMP}deletes$$ -a -s ${TMP}creates$$ ]
		then	bk new $Q -G -y"Import patch $PNAME" - < ${TMP}creates$$
		fi
	else	# Just delete and create
		echo Checking in new or modified files in `pwd` ...
		bk rm - < ${TMP}deletes$$
		bk new $Q -G -y"Import patch $PNAME" - < ${TMP}creates$$
	fi
	rm -f ${TMP}creates$$ ${TMP}deletes$$

	if [ X$Q = X ]
	then	bk -r clean -q
	fi

	bk -r ci $Q -G -y"Import patch $PNAME"

	bk sfiles -x | grep -v '^BitKeeper/' > ${TMP}extras$$
	if [ -s ${TMP}extras$$ ]
	then	echo There were extra files, patch aborted, here is the list
		cat ${TMP}extras$$
		echo
		echo "Patch aborted, you must clean up by hand, XXX"
		Done 1
    	fi

	USER=$SAVE
	echo Creating changeset for $PNAME in `pwd` ...
	bk sfiles -C | bk cset $SYMBOL $NEWLOD -y"`basename $PNAME`" -
	echo Done.
	Done 0
}

import_text () {
	Q=$QUIET

	cd $2
	echo Checking in plain text files...
	bk ci -i $Q - < ${TMP}import$$ || exit 1
}

import_RCS () {
	cd $2
	echo Converting RCS files.
	echo WARNING: Branches will be discarded.
	echo Ignore errors relating to missing newlines at EOF.
	bk rcs2sccs -hst - < ${TMP}import$$ || exit 1
	xargs rm -f < ${TMP}import$$
}

import_SCCS () {
	cd $2
	echo Checking for and fixing Teamware corruption...
	bk sfiles | bk renumber -q -
	if [ -s ${TMP}reparent$$ ]
	then	echo Reparenting files from some other BitKeeper project...
		sed 's/ BitKeeper$//' < ${TMP}reparent$$ | \
		while read x
		do	if [ -f $x ]
			then	echo $x
			fi
		done | bk admin -CC -
		echo OK
	fi
	rm -f ${TMP}reparent$$
	echo Making sure all files have pathnames, proper dates, and checksums
	bk sfiles -g | while read x
	do	bk admin -0q $x
		bk admin -q -u -p$x $x
		bk rechksum -f $x
	done
}

import_finish () {
	cd $1
	echo ""
	echo Validating all SCCS files
	bk sfiles | bk admin -hhhq - > ${TMP}admin$$
	if [ -s ${TMP}admin$$ ]
	then	echo Import failed because
		cat ${TMP}admin$$
		exit 1
	fi
	echo OK
	
	rm -f ${TMP}import$$ ${TMP}admin$$
	bk sfiles -r
	# So it doesn't run consistency check.
	touch BitKeeper/etc/SCCS/x.marked
	echo "Creating initial changeset (should have $NFILES + 1 lines)"
	bk commit $SYMBOL -y'Import changeset'
}

validate_SCCS () {
	FROM=$1
	TO=$2
	cd $FROM
	grep 'SCCS/s\.' ${TMP}import$$ > ${TMP}sccs$$
	grep -v 'SCCS/s\.' ${TMP}import$$ > ${TMP}notsccs$$
	if [ -s ${TMP}sccs$$ -a -s ${TMP}notsccs$$ ]
	then	NOT=`wc -l < ${TMP}notsccs$$ | sed 's/ //g'`
		echo
		echo Skipping $NOT non-SCCS files
		echo $N "Do you want to see this list of files? [No] " $NL
		read x
		case "$x" in
		y*)	sed 's/^/	/' < ${TMP}notsccs$$ | more ;;
		esac
		mv ${TMP}sccs$$ ${TMP}import$$
	fi
	rm -f ${TMP}notsccs$$ ${TMP}sccs$$
	bk sfiles -cg $FROM > ${TMP}changed$$
	if [ -s ${TMP}changed$$ ]
	then	echo The following files are locked and modified in $FROM
		cat ${TMP}changed$$
		echo
		echo Can not import unchecked in SCCS files
		exit 1
	fi
	rm -f ${TMP}changed$$
	grep 'SCCS/s\.' ${TMP}import$$ | prs -hr -d':PN: :TYPE:' - | grep ' BitKeeper' > ${TMP}reparent$$
	if [ -s ${TMP}reparent$$ ]
	then	cat <<EOF

You are trying to import BitKeeper files into a BitKeeper project.
We can do this, but it means that you are goint to "reparent" these
files under a new ChangeSet file.  In general, that's not a good idea,
because you will lose all the old ChangeSet history in the copied files.
We can do it, but don't do it unless you know what you are doing.

The following files are marked as BitKeeper files:
EOF
		sed 's/ BitKeeper$//' < ${TMP}reparent$$ | sed 's/^/	/'
		echo ""
		echo $N "Reparent the BitKeeper files? [No] " $NL
		read x
		case "$x" in
		y*)	;;
		*)	rm -f ${TMP}sccs$$ ${TMP}import$$ ${TMP}reparent$$
			exit 1
		esac
		echo $N "Are you sure? [No] " $NL
		read x
		case "$x" in
		y*)	;;
		*)	rm -f ${TMP}sccs$$ ${TMP}import$$
			exit 1
		esac
		echo OK
	fi
}

validate_RCS () {
	grep ',v$' ${TMP}import$$ >${TMP}rcs$$
	# Filter out CVS repository metadata here.
	grep -v ',v$' ${TMP}import$$ | egrep -v 'CVS|#cvs' >${TMP}notrcs$$
	if [ -s ${TMP}rcs$$ -a -s ${TMP}notrcs$$ ]
	then	NOT=`wc -l < ${TMP}notrcs$$ | sed 's/ //g'`
		echo
		echo Skipping $NOT non-RCS files
		echo $N "Do you want to see this list of files? [No] " $NL
		read x
		case "$x" in
		y*)	sed 's/^/	/' < ${TMP}notrcs$$ | more ;;
		esac
	fi
	mv ${TMP}rcs$$ ${TMP}import$$
	rm -f ${TMP}notrcs$$
}

validate_text () {
	FROM=$1
	TO=$2
	cd $FROM
	egrep 'SCCS/s\.|,v$' ${TMP}import$$ > ${TMP}nottext$$
	egrep -v 'SCCS/s\.|,v$' ${TMP}import$$ > ${TMP}text$$
	if [ -s ${TMP}text$$ -a -s ${TMP}nottext$$ ]
	then	NOT=`wc -l < ${TMP}nottext$$ | sed 's/ //g'`
		echo
		echo Skipping $NOT non-RCS files
		echo $N "Do you want to see this list of files? [No] " $NL
		read x
		case "$x" in
		y*)	sed 's/^/	/' < ${TMP}nottext$$ | more ;;
		esac
		mv ${TMP}text$$ ${TMP}import$$
		rm -f ${TMP}nottext$$
	fi
	rm -f ${TMP}nottext$$ ${TMP}text$$
}

# Make sure there are no locked/extra files
validate_patch() {
	cd $2
	echo Make sure there are no locked files in `pwd` ...
	bk sfiles -l | grep -v BitKeeper/ > ${TMP}locked$$
	if [ -s ${TMP}locked$$ ]
	then	echo Not patching because of locked files:
		cat ${TMP}locked$$
		Done 1
    	fi
	echo Make sure there are no extra files in `pwd` ...
	bk sfiles -x | grep -v BitKeeper/ > ${TMP}extras$$
	if [ -s ${TMP}extras$$ ]
	then	echo Not patching because of extra files:
		cat ${TMP}extras$$
		Done 1
    	fi
	rm -f ${TMP}locked$$ ${TMP}extras$$
}

Done() {
	for i in rejects plog extras locked import sccs
	do	rm -f ${TMP}${i}$$
	done
	exit $1
}

init() {
	__platformInit;
	if [ '-n foo' = "`echo -n foo`" ]
	then    NL='\c'
	        N=
	else    NL=
		N=-n
	fi
	if [ X$EDITOR = X ]
	then	EDITOR=vi
	fi
}

init
__logCommand "$@"
import "$@"
exit 0
