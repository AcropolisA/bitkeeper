# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Copyright (c) 2004 Larry McVoy
# %K%

test -d $HERE/home || mkdir $HERE/home
export BK_TEST_HOME=$HERE/home
OUT=$HERE/out
RC=`bk dotbk`/rev.rc

echo $N Create initial repository ...................................$NL
commercial project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
echo OK

echo $N Create some data ............................................$NL
cd $HERE/project/BitKeeper/etc
mkdir $HERE/project/src
cd $HERE/project/src
for f in file1 file2 file3 file4 file5 ; do
    echo "this is $f" > $f 
    bk ci $Q -i -y'new file' $f
    if [ ! -f SCCS/s.$f ]; then echo failed to create file $f ; exit 1 ; fi
done
bk commit $Q -y'initial checkin' 
bk tag $Q "BabySteps"
for f in file1 file2 file3 ; do
    bk get $Q -e $f
    echo "Line two" >> $f
    bk ci $Q -y'added a second line' $f
done
bk commit $Q -y'added a second line to file1, file2 and file3'
echo OK

echo $N Create dotbk/rev.rc .........................................$NL
test -f $RC && rm -f $RC
bk guitest revtool >$OUT 2>&1 <<'EOF'
    test_buttonPress Quit
    after 5000 [list exit 99] ;# in case the buttonpress didn't work
EOF
test -f $RC || (echo "failed" ; exit 1; )
echo "OK"

echo $N Bogus command line option ...................................$NL
bk guitest revtool --bogus >$OUT 2>&1 <<'EOF'
    test_buttonPress Quit
    after 5000 [list exit 99] ;# in case the buttonpress didn't work
EOF
if [ $? -ne 1 ]; then echo "failed"; echo "exited $err; expected 1"; exit 1; fi
egrep 'usage:.*bk ' $OUT > $DEV_NULL
if [ "$?" -ne 0 ] ; then echo failed; cat $OUT; exit 1; fi
echo OK

echo $N Normal startup w/no args. ...................................$NL
bk guitest revtool >$OUT 2>&1 <<'EOF'
    global fname
    if {"[pwd]" != "[exec bk root]"} {
        puts "pwd is not bk root"
        exit 1
    }
    if {$::fname != "ChangeSet"} {
        puts "filename is '$::fname'; expected ChangeSet"
        exit 1
    }
    test_buttonPress Quit
    after 5000 [list exit 99] ;# in case the buttonpress didn't work
EOF
if [ $? -ne 0 ]; then echo "failed"; cat $OUT; exit 1; fi
echo OK

echo $N Window title ................................................$NL
bk guitest revtool >$OUT 2>&1 <<'EOF'
    set title [string trim [wm title .]]
    if {"$title" != "revtool: [exec bk root]: ChangeSet"} {
	puts "unexpected title: '$title'"
    }
    exit 0
EOF
if [ -s $OUT ] ; then echo failed; cat $OUT ; exit 1 ; fi
echo OK

# this does a very shallow test for whether the graph is correct;
# it simply checks that one data structure has been initialized. 
echo $N Simple graph test ...........................................$NL
bk guitest revtool >$OUT 2>&1 <<'EOF'
    global rev2date w
    set revs [lsort [array names rev2date]]
    if {$revs != {1.1-bk 1.2-bk 1.3-bk}} {
	puts "unexpected revisions: $revs"
	exit 1
    }
    exit 0
EOF
if [ $? -ne 0 ]; then echo failed; cat $OUT; exit 1; fi
if [ -s $OUT ] ; then echo failed; cat $OUT ; exit 1 ; fi
echo OK

echo $N Test revision given in command line..........................$NL
bk guitest revtool -r1.1 file1 >$OUT 2>&1 <<'EOF'
	global anchor
	if {$anchor ne "1.1-bk"} {
		puts stderr "Revision 1.1 specified in command line, \
		    but not selected in GUI"
		exit 1
	}
	exit 0
EOF
if [ $? -ne 0 ]; then echo failed; cat $OUT; exit 1; fi
if [ -s $OUT ] ; then echo failed; cat $OUT; exit 1; fi
echo OK
