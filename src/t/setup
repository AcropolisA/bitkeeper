# Copyright 1999-2016 BitMover, Inc

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# *IMPORTANT* This file should be kept small, it is called in the main loop
#	      of doit.sh

cores()
{
	# Win32 have no core file
	if [ "$PLATFORM" = "WIN32" ]; then return; fi

	OUT="$BK_REGRESSION/cores"
	find "$BK_REGRESSION" -name core -print > "$OUT"
	test -n "$_BK_MAC_CORES" && {
		# Add in any new MacOS cores
		find /cores -type f -name 'core*' 2>$DEV_NULL \
			| bk _sort > "$OUT".macos
		comm -13 "$_BK_MAC_CORES" "$OUT".macos >> "$OUT"
	}
	if [ -s "$OUT" ]
	then    ls -l "`cat "$OUT"`"
		file "`cat "$OUT"`"
		exit 10
	fi
}


# Note: [ -w file ] always succeeds when you are root.
writable() {
	bk _test -w "$1" || return 1
	return 0
}

checkLocks() {
	if [ -d BitKeeper/readers ]
	then	if [ `find BitKeeper/readers -type f -print | wc -l` -ne 0 ]
		then	echo Failed to remove read lock in `pwd`
			exit 1
		fi
	fi
	if [ -d BitKeeper/writer ]
	then	if [ `find BitKeeper/writer -type f -print | wc -l` -ne 0 ]
		then	echo Failed to remove write lock in `pwd`
			exit 1
		fi
	fi
}

# We need this because some proxy disallow proxy to localhost
# some of our test do http push/pull/clone to localhost
unsetHttpProxy() {
	unset http_proxy HTTP_PROXY_HOST HTTP_PROXY_PORT
	unset SOCKS_HOST SOCKS_PORT SOCKS_SERVER
	unset HTTP_PROXY # workaround for cygwin
}

# Make a commercial config file
_commercial_config() {
        # one more item for nested repos
	test "$1" && echo clone_default: DEFAULT
	cat <<EOF
description: BitKeeper Test repository
email: nobody@nowhere.bk
eoln: unix
keyword: sccs
BAM: 1
lockwait: 0
partial_check: off
EOF
}

# Usage: make_repo type instance
_make_repo() {
	TYPE="$1"
	CF="$2"
	SFIO="$3"
	DEEP="$4"
	REPO="$BK_CACHE/${TYPE}"
	DASH_P=

	test -d "$REPO" && rm -rf "$REPO"		# should not happen
	test "$TYPE" = nested && DASH_P="-P"		# Make it a product
	COMPAT=
	test "$_BKFILE_REGRESSIONS" = "no" && COMPAT=--compat

	bk setup $COMPAT -f -c"$CF" $DASH_P "$REPO" || fail
	test "$TYPE" = nested && { (
		cd "$REPO" || {
			echo failed to create $REPO
			exit 1
		}
		bk setup -C -f gcc
		bk setup -C -f gdb
		bk alias set -C DEFAULT ALL
		bk commit -S -q -y"attach gcc, gdb"
		touch gcc/BitKeeper/tmp/saveme
		touch gdb/BitKeeper/tmp/saveme

		test "$DEEP" = deep && { (
			## Make a deep-nested repo.
			bk setup -C -f gui
			cd gui || {
			    echo failed to create gui repo
			    exit 1
			}
			bk setup -C -f bin
			bk setup -C -f lib
			bk commit -S -q -y"create gui repo"
			touch bin/BitKeeper/tmp/saveme
			touch lib/BitKeeper/tmp/saveme
			cd ..
			bk commit -q -y"attach deep"
		); }
		true
	); return; }

	# Make a cached copy
        (cd "$REPO" && bk _find . -type f | perl -e '
		# Input is a file name per line
		# Output is a sorted file list so that sfiles are always
		# before gfiles And files in same directory are "near"
		# each other. 
		#
		# Good for small lists - does the split each time mysort runs
		# For large data sets, cache the split

		sub mysort {
			my	@a = split(/\//, $a);
			my	@b = split(/\//, $b);
			my	($a0, $b0);

			while (@a || @b) {
				# sort shorter string first
				return (-1) unless @a;
				return (1) unless @b;
				# nab first item
				$a0 = shift @a;
				$b0 = shift @b;
				# look for a difference
				next if $a0 eq $b0;
				# like extsort() - sort SCCS first
				return (-1) if $a0 eq "SCCS";
				return (1) if $b0 eq "SCCS";
				# if this is the last item in one string,
				# sort it first
				return (-1) if !@a and @b;
				return (1) if @a and !@b;
				# else sort alphabetically
				return ($a0 cmp $b0);
			}
			# paranoid - only happens if strings are a dup
			return (0);
		}
		chomp(@list = <>);
		print join("\n", sort mysort @list);
	' | bk sfio -qm -o > "$SFIO")
}

# Usage get_cached_repo dir sfio
_get_cached_repo() {
	mkdir "$1" || exit 1
	cd "$1" || exit 1
	mkdir -p BitKeeper/etc
	bk sfio -qm -i < "$2"
	mkdir -p BitKeeper/tmp		# because sfio does not copy dir
	bk _mkdir BitKeeper/deleted
	bk _mkdir BitKeeper/deleted/SCCS
}

# Get a commercial repo, use cache copy if available
# Usage: commercial dir
commercial() {
	CF="$BK_CACHE/commercial.config"
	SFIO="$BK_CACHE/commercial.sfio"
	test "$_BK_SETUP_NOGONE" && {
		echo "no calling 'commercial' with _BK_SETUP_NOGONE" 1>&2
		exit 1
	}
	test -f "$SFIO" || {
		_commercial_config > "$CF"
		_make_repo commercial "$CF" "$SFIO"
	}
	_get_cached_repo "$1" "$SFIO"
}

fresh_commercial() {
	_commercial_config > .config
	COMPAT=
	test "X$1" = X--compat && {
	     COMPAT=--compat
	     shift
	}
	test "$_BKFILE_REGRESSIONS" = "no" && COMPAT=--compat
	bk setup $COMPAT -f -c.config "$1" || fail
	cd "$1"
}

# 'nested foo' is a form of 'commercial foo' which gives a nested repo.
nested() {
	CF="$BK_CACHE/nested.config"
	REPO="$BK_CACHE/nested"
	test -d "$REPO" || {
		_commercial_config 1 > "$CF"
		_make_repo nested "$CF" ignored "$2"
	}
	bk clone -q "$BK_CACHE/nested" "$1" || exit 1
	cd "$1" || exit 1
	bk parent -qr || exit 1
	bk portal -q . || exit 1
	bk gate -q . || exit 1
	rm BitKeeper/log/urllist
}

fresh_nested() {
	_commercial_config 1 > .config
	COMPAT=
	test "X$1" = X--compat && {
	     COMPAT=--compat
	     shift
	}
	test "$_BKFILE_REGRESSIONS" = "no" && COMPAT=--compat
	bk setup $COMPAT -P -f -c.config "$1" || fail
	cd "$1"
	bk setup -C -f gcc
	bk setup -C -f gdb
	bk alias set -C DEFAULT ALL
	bk commit -q -y"attach gcc, gdb"
}

create_test_files() {
	(
	cd "$1"
	for f in file1 file2 file3 file4 file5 ; do
		echo "this is $f" > $f
		bk ci $Q -i -y'new file' $f || exit 1
	done
	bk commit $Q -y'initial checkin' || exit 1
	)
}

# move a nested component (helper)
mvcomp() {
	 test "BitKeeper/log/PRODUCT" || exit 1
	 mv "$1" "$2"
	 echo "$2" > "$2"/BitKeeper/log/COMPONENT
	 bk edit $Q "$2"/ChangeSet || exit 2
	 bk --cd="$2" commit $Q -S -Fy"Rename $1 -> $2" "$2"/ChangeSet - \
	     < /dev/null || fail 3
	 bk idcache -q
}


echon() {
	echo $NX ${1+"$@"}$NXL
}

# Find an unused port for a bkd
port() {
	if [ "X$1" = X ]
	then	_P=1234
	else	_P=$1
	fi
	# Truncate it down if they pass in 50000
	test $_P -gt 6550 && _P=`expr $_P / 10`
	for i in 1 2 3 4 5 6 7 8 9
	do	bk bkd -cqp$_P$i && {
			_P=$_P$i
			break
		}
	done
	test X$_P = X && exit 1
	echo $_P
}

# args: GOT WANT
cmpfiles() {
	OUTPUT=`bk diff -q --ignore-trailing-cr "$1" "$2"` && return
	case "X$BASH_VERSION" in
	    X[234]*) eval 'echo failed in line $((${BASH_LINENO[0]} - $BOS))';;
	    *) echo failed ;;
	esac
	echo $OUTPUT
	bk diff -u "$1" "$2"
	exit 1
}

# args: GOT WANT
cmpsfiles() {
	a="$BK_TMP/`basename \"$1\"`.$$"
	b="$BK_TMP/`basename \"$2\"`.$$"
	bk _cat "$1" > "$a"
	bk _cat "$2" > "$b"
	bk diff -q --ignore-trailing-cr "$a" "$b" || {
		bk diff -u "$a" "$b"
		exit 1
	}
	rm -f "$a" "$b"
}

# args: GOT WANT, does a byte for byte comparison
checkfiles() {
	cmp -s "$1" "$2" || {
		echo "$1" and "$2" don\'t match
		bk diff -u "$1" "$2"
		exit 1
	}
}

verbose() {
	test -z "$Q" && echo ${1+"$@"}
}

islink() {
	# test -L is not portable - freebsd[34] and mac102 do not support
	perl -e "exit ((-l '$1') ? 0 : 1)"
}

_mtime() {
	bk _stat "$1" | awk -F\| '{print $10}'
}

cd "$HERE" || exit 1

# We need this because ksh on Solaris override $PATH from .profile
PATH="$BK_PATH"

fail() {
	test x$1 = x-f && {
		__outfile=$2
		shift;shift;
	}
	case "X$BASH_VERSION" in
	    X[234]*) eval 'echo failed in line $((${BASH_LINENO[0]} - $BOS))';;
	    *) echo failed ;;
	esac
	test "$*" && echo $*
	test "$__outfile" && {
		echo ----------
		cat "$__outfile"
		echo ----------
	}
	test x$BK_REGRESSION_WAIT != x && {
		echo "pausing -- type ctrl-C to exit"
		echo "pwd is `pwd`"
		sleep 100000
	}
	test x$BK_REGRESSION_NOFAIL == x && exit 1
}

# longpath "/prefix/" total_length
# where prefix can be "" for relative path, or "`/bin/pwd`/" for abs path
# and total length is the length of the made up path including prefix
# path is a deep nest of 15 char dirs separated by / and a "xxx..." file
# name at the end to get the right total size.
longpath() {
	PROG='	$x = $ARGV[1] - length($ARGV[0]);
		$y = int(($x-1)/16);
		print "$ARGV[0]",
		    "abcdefg12345679/" x $y, "x" x ($x - 16*$y), "\n";'
	perl -e "$PROG" "$1" $2
}

test_gui_result() {
	rc_got=$1
	rc_expect=$2
	OUT="$3"

	test $rc_got -ne $rc_expect -o -s "$OUT" && {
		echo "failed"
		test $rc_got -ne $rc_expect && {
			echo "exited $rc_got; expected $rc_expect"
		}
		test -s "$OUT" && {
			cat "$OUT"
		}
		exit 1
	}
	echo "OK"
}

# Ask and wait for the uniq daemon running in <dir> to exit.
kill_uniq() {
	dir=$1; shift
	test -d "$dir" || return
	db=`ls "$dir"`
	test -n "$db" -a -d "$dir/$db" || return
	bk uniq_server $Q --dir="$dir/$db" --quit
}

# Remove the uniqdb(s). Normally you want to call kill_uniq first
# or else the files will reappear when the uniq_daemon exits.
rm_uniq() {
	rm -f "`bk dotbk`/bk-keys/`bk gethost -r`"
	rm -f "/tmp/.bk-keys-$USER"
}

# Return 1 iff <key> exists in the on-disk uniqdb.
# Normally you want to call kill_uniq first.
key_exists()
{
	key=$1; shift
	echo "get .*$key.*" | bk info_shell --uniqdb | grep -q $key
}

# this next line needs to be last, it's line zero of the script (see doit)
BOS=$LINENO
