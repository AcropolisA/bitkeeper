# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Setup code for tests
# Copright (c) 1999 Larry McVoy
# %K%

# *IMPORTANT* This file should be kept small, it is called in the main loop
#	      of doit.sh

cores()
{
	# Win32 have no core file
	if [ "$PLATFORM" = "WIN32" ]; then return; fi

	OUT="$BK_REGRESSION/cores"
	find "$BK_REGRESSION" -name core -print > "$OUT"
	if [ -s "$OUT" ]
	then    ls -l "`cat "$OUT"`"
		file "`cat "$OUT"`"
		exit 10
	fi
}


# Note: [ -w file ] always succeeds when you are root.
writable() {
	bk _test -w "$1" || return 1
	return 0
}

checkLocks() {
	if [ -d BitKeeper/readers ]
	then	if [ `find BitKeeper/readers -type f -print | wc -l` -ne 0 ]
		then	echo Failed to remove read lock in `pwd`
			exit 1
		fi
	fi
	if [ -d BitKeeper/writer ]
	then	if [ `find BitKeeper/writer -type f -print | wc -l` -ne 0 ]
		then	echo Failed to remove write lock in `pwd`
			exit 1
		fi
	fi
}

# We need this because some proxy disallow proxy to localhost
# some of our test do http push/pull/clone to localhost
unsetHttpProxy() {
	unset http_proxy HTTP_PROXY_HOST HTTP_PROXY_PORT
	unset SOCKS_HOST SOCKS_PORT SOCKS_SERVER
	unset HTTP_PROXY # workaround for cygwin
}

# Make a commercial config file
_commercial_config() {
	cat <<EOF
license: $BKL_PRO
licsign1: $BKL_P1
licsign2: $BKL_P2
licsign3: $BKL_P3
description: BitKeeper Test repository
email: nobody@nowhere.bk
eoln: unix
keyword: sccs
BAM: 1
nosync: on
lockwait: 0
EOF
}

# Usage: make_repo type instance
_make_repo() {
	TYPE="$1"
	CF="$2"
	SFIO="$3"
	REPO="$BK_CACHE/${TYPE}"
	DASH_P=

	test -d "$REPO" && rm -rf "$REPO"		# should not happen
	test "$TYPE" = nested && DASH_P="-P"		# Make it a product
	bk setup -a -f -c"$CF" $DASH_P "$REPO" || {
		echo "Setup failed!"
		exit 1
	}
	test "$TYPE" = nested && { (
		cd "$REPO" || {
			echo failed to create $REPO
			exit 1
		}
		bk setup -C -a -f gcc
		bk setup -C -a -f gdb
		bk commit -q -y"attach gcc, gdb"
		touch gcc/BitKeeper/tmp/saveme
		touch gdb/BitKeeper/tmp/saveme
	); return; }

	# Make a cached copy
        (cd "$REPO" && bk _find . -type f | perl -e '
		# Input is a file name per line
		# Output is a sorted file list so that sfiles are always
		# before gfiles And files in same directory are "near"
		# each other. 
		#
		# Good for small lists - does the split each time mysort runs
		# For large data sets, cache the split

		sub mysort {
			my	@a = split(/\//, $a);
			my	@b = split(/\//, $b);
			my	($a0, $b0);

			while (@a || @b) {
				# sort shorter string first
				return (-1) unless @a;
				return (1) unless @b;
				# nab first item
				$a0 = shift @a;
				$b0 = shift @b;
				# look for a difference
				next if $a0 eq $b0;
				# like extsort() - sort SCCS first
				return (-1) if $a0 eq "SCCS";
				return (1) if $b0 eq "SCCS";
				# if this is the last item in one string,
				# sort it first
				return (-1) if !@a and @b;
				return (1) if @a and !@b;
				# else sort alphabetically
				return ($a0 cmp $b0);
			}
			# paranoid - only happens if strings are a dup
			return (0);
		}
		chomp(@list = <>);
		print join("\n", sort mysort @list);
	' | bk sfio -qm -o > "$SFIO")
}

# Usage get_cached_repo dir sfio
_get_cached_repo() {
	mkdir "$1" || exit 1
	cd "$1" || exit 1
	mkdir -p BitKeeper/etc
	bk sfio -qm -i < "$2"
	mkdir -p BitKeeper/tmp		# because sfio does not copy dir
	bk _mkdir BitKeeper/deleted
	bk _mkdir BitKeeper/deleted/SCCS
	bk _eula -a
}

# Get a commercial repo, use cache copy if available
# Usage: commercial dir
commercial() {
	CF="$BK_CACHE/commercial.config"
	SFIO="$BK_CACHE/commercial.sfio"
	test -f "$SFIO" || {
		_commercial_config > "$CF"
		_make_repo commercial "$CF" "$SFIO"
	}
	_get_cached_repo "$1" "$SFIO"
}

fresh_commercial() {
	_commercial_config > c
	bk setup -a -f -cc "$1" || { echo "Setup failed!"; exit 1; }
	cd "$1"
}

# 'nested foo' is a form of 'commercial foo' which gives a nested repo.
nested() {
	CF="$BK_CACHE/nested.config"
	REPO="$BK_CACHE/nested"
	test -d "$REPO" || {
		_commercial_config > "$CF"
		_make_repo nested "$CF" ignored
	}
	(cd "$BK_CACHE"/nested; bk _eula -a)
	bk clone -lq "$BK_CACHE/nested" "$1"
	cd "$1" || exit 1
	bk parent -qr || exit 1
}

# move a nested component (helper)
mvcomp() {
	 mv "$1" "$2"
	 bk edit $Q "$2"/ChangeSet || exit 1
	 bk delta -f $Q -y"Rename $1 -> $2" "$2"/ChangeSet || exit 1
	 echo "$2" > "$2"/BitKeeper/log/COMPONENT
}


echon() {
	echo $NX ${1+"$@"}$NXL
}

# Find an unused port for a bkd
port() {
	if [ "X$1" = X ]
	then	_P=1234
	else	_P=$1
	fi
	# Truncate it down if they pass in 50000
	test $_P -gt 6550 && _P=`expr $_P / 10`
	for i in 1 2 3 4 5 6 7 8 9
	do	bk bkd -cqp$_P$i && {
			_P=$_P$i
			break
		}
	done
	test X$_P = X && exit 1
	echo $_P
}

# args: GOT WANT
cmpfiles() {
	bk diff -q --ignore-trailing-cr "$1" "$2" || {
		bk diff -u "$1" "$2"
		exit 1
	}
}

# args: GOT WANT
cmpsfiles() {
	a="$BK_TMP/`basename \"$1\"`.$$"
	b="$BK_TMP/`basename \"$2\"`.$$"
	bk _cat "$1" > "$a"
	bk _cat "$2" > "$b"
	bk diff -q --ignore-trailing-cr "$a" "$b" || {
		bk diff -u "$a" "$b"
		exit 1
	}
	rm -f "$a" "$b"
}

# args: GOT WANT, does a byte for byte comparison
checkfiles() {
	cmp -s "$1" "$2" || {
		echo "$1" and "$2" don\'t match
		bk diff -u "$1" "$2"
		exit 1
	}
}

verbose() {
	test -z "$Q" && echo ${1+"$@"}
}

islink() {
	# test -L is not portable - freebsd[34] and mac102 do not support
	perl -e "exit ((-l '$1') ? 0 : 1)"
}

_mtime() {
	bk _stat "$1" | awk -F\| '{print $10}'
}

cd "$HERE" || exit 1

# We need this because ksh on Solaris override $PATH from .profile
PATH="$BK_PATH"
