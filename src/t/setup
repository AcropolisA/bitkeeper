
# Setup code for tests
# Copright (c) 1999 Larry McVoy
# %K%

# We need this because cygwin "exec" can not handle "drive:/path" format
win2cygPath()
{
	case "$1" in
	*:\\*)	# convert c:\path to //c/path format
		cygPath="//${1%:\\*}/${1#*:\\}"
		;;
	*:/*)	# convert c:/path to //c/path format
		cygPath="//${1%:/*}/${1#*:/}"
		;;
	*)	cygPath=$1
		;;
	esac
}


# we need this because "if [ -w ... ]" does not work on NT
isWritable()
{
	P=`ls -l $1`
	case $P in 
	    -rw*)
		return 0;
		;;
	    *)
		return 1;
		;;
	esac
}

# check which platform we are running on
# -w => windows
if [ X${OSTYPE} = Xcygwin32 -o X${OSTYPE} = Xuwin ]
then
	PLATFORM="WIN32"
	ROOT=Administrator
	BK_BIN=`cd .. && ./pwd.exe -sf`
	win2cygPath $BK_BIN; _BK_BIN=$cygPath;
	TST_DIR=$TEMP
	TMP=$TEMP
	CAT="bin_mode_cat"
	ECHO="bin_mode_echo"
	RM=rm
	DATE="date"
	DEV_NULL="nul"
	CWD="$BK_BIN/pwd.exe"
	data="data"
	uuencode="uuencode"
	if [ X$OSTYPE = Xuwin ]
	then
		# we are running under the uwin ksh
		# /dev/null in uwin does not always work
		# uwin seems to map all file name to lower case
		# uwin cp command adds .exe for binary files
		BK_BIN=/C/bitkeeper
		TST_DIR=/C/tmp
		RM=/bin/rm
		data="data.exe"
		uuencode="uuencode.exe"
	fi
	binary_data="$BK_BIN/ci.exe"
	binary_data2="$BK_BIN/co.exe"
	PATH=$_BK_BIN:$_BK_BIN/bin/gnu:$PATH
	BK_BIN="$BK_BIN/"
	export PATH BK_BIN
	# It is unlikely that ssh/rsh to localhost will work on NT.
	# We let the user tell us otherwise.
	if [ -z "$DO_REMOTE" ]; then DO_REMOTE=NO; fi
else
	# we are on a unix box
	PLATFORM="UNIX"
	ROOT=root
	ECHO="echo"
	CAT="cat"
	CWD="/bin/pwd"
	if [ -x force_rm.sh ]
	then	RM="force_rm.sh"
	else	RM="/bin/rm -f"
	fi
	DATE=/bin/date
	DEV_NULL="/dev/null"
	BK_BIN="`cd .. && pwd`"
	if [ -d /usr/xpg4/bin ]
	then  PATH=/usr/xpg4/bin:$PATH
	fi
	PATH=$BK_BIN:$BK_BIN/gnu/bin:$PATH
	BK_BIN="$BK_BIN/"
	binary_data=/bin/ls
	binary_data2=/bin/rm
	data="data"
	uuencode="uuencode"
	TST_DIR=/tmp
	TMP=/tmp
	export PATH BK_BIN
	unset CDPATH
	if [ -z "$DO_REMOTE" ]; then DO_REMOTE=YES; fi
fi
export TST_DIR CORES BK_BIN BK_REGRESSION

cores()
{
	if [ "X$REGRESSION" = X ]
	then	echo REGRESSION not set
		exit 1
	fi
	find $REGRESSION -name core -print > cores
	if [ -s cores ]
	then	ls -l `cat cores`
		file `cat cores`
		exit 10
	fi
	${RM} -f cores
}

# [ -w file ] always succeeds when you are root.
writable () {
	[ -f $1 ] || return 1
	case "`ls -l $1 | cut -c1-10`" in
	    *w*) return 0;;
	    *) return 1;;
	esac
}

# We don't want to do this expensive test unless we need to.
check_for_rsh () {
if [ X$DO_REMOTE != XNO ]; then
	if [ X$PREFER_RSH != X ]
	then
		if type rsh >/dev/null 2>&1 &&
			rsh localhost true </dev/null >/dev/null 2>&1
		then	DO_REMOTE=YES
		elif type ssh >/dev/null 2>&1 &&
			ssh -o PasswordAuthentication=no localhost true \
				</dev/null >/dev/null 2>&1
		then	DO_REMOTE=YES
			unset PREFER_RSH
		else	DO_REMOTE=NO
		fi
	else
		if type ssh >/dev/null 2>&1 &&
			ssh -o PasswordAuthentication=no localhost true \
				</dev/null >/dev/null 2>&1
		then	DO_REMOTE=YES
		elif type rsh >/dev/null 2>&1 &&
			rsh localhost true </dev/null >/dev/null 2>&1
		then	DO_REMOTE=YES
			PREFER_RSH=YES
		else	DO_REMOTE=NO
		fi
	fi
	if [ $DO_REMOTE = NO ]
	then	echo Skipping remote resync tests.
		echo To test remote resync, you must be able to rsh 
		echo or ssh to localhost with no password.
	fi
fi
}

if [ X$1 = X-t ]
then
	shift
	if [ X$1 = X ]
	then	echo "-t option needs a argument"
		echo "usage: $0 [-t test_dir] ...."
		exit 1
	fi
	TST_DIR="$1"
	shift
fi
cd ${TST_DIR}


if [ X$1 = X-v ]
then	Q=
	S=
else	Q=-q
	S=-s
fi
if [ '-n foo' = "`echo -n foo`" ]
then	NL='\c'
	N=
else	NL=
	N=-n
fi
export PATH
if [ X$USER = X ]; then USER=$LOGNAME; fi
if [ X$USER = X ]; then USER=`getuser`; fi
# root user is special, remap to a differnt user before we run the test
if [ X$USER = X${ROOT} ]; then USER=${ROOT}-test; fi
if [ X$HOSTNAME = X ]; then HOSTNAME=`gethost`; fi
REGRESSION=$TST_DIR/.regression-$USER
export USER HOSTNAME REGRESSION
if [ -d $REGRESSION ]; then ${RM} -rf $REGRESSION; fi
# save the list of file cuurently in $TMP
# check it when again when we are in clean up
touch $TMP/T.${USER}-$$ $TMP/T.new.${USER}-$$ 
ls -a $TMP > $TMP/T.${USER}-$$
mkdir $REGRESSION || exit 1
cd $REGRESSION || exit 1
mkdir .tmp || exit 1
BK_TMP=$REGRESSION/.tmp
BK_TRACE_LOG=YES
export BK_TMP BK_TRACE_LOG
if [ -d SCCS ]; then echo "There should be no SCCS directory here."; exit 1; fi
