# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Copyright (c) 1999 Larry McVoy
# %K%

cat > foo <<EOF
Hi there, this is file foo.
Hi there, this is file foo.
Hi there, this is file foo.
Hi there, this is file foo.
Hi there, this is file foo.
Hi there, this is file foo.
Hi there, this is file foo.
Hi there, this is file foo.
Hi there, this is file foo.
EOF
mv foo SAVE
ATT=no
for D in "" A/ A/A/A/A/
do	case "$D" in
	"") DOTS=........
	   ;;
	"A/") DOTS=......
	   ;;
	*) DOTS=
	   ;;
	esac
	cd $HERE
	rm -rf root 
	echo $N Create initial changeset ....................................$NL
	no_logging root
	if [ ! -f SCCS/s.ChangeSet ]; then echo failed; exit 1; fi
	if [ X$D != X ]; then mkdir -p $D; fi
	echo OK
	cp ../SAVE ${D}foo
	echo $N checkin with ${D}SCCS/s.foo ${DOTS}.............................$NL
	bk ci $Q -i ${D}foo
	if [ ! -f ${D}SCCS/s.foo ]; then echo Failed to create s.foo.; exit 1; fi
	if [ -f ${D}foo ]; then echo Failed to get foo.; exit 1; fi
	echo OK
	echo $N checkout with ${D}SCCS/s.foo ${DOTS}............................$NL
	bk co $Q ${D}foo
	if [ ! -f ${D}foo ]; then echo Failed to get foo.; exit 1; fi
	if writable ${D}foo; then echo foo is writable; exit 1; fi
	echo OK
	echo $N Verifying data checksum .....................................$NL
	A=`bk prs -r1.1 -hd:DSUM: ${D}foo`
	B=`bk checksum -s < ../SAVE`
	if [ $A -ne $B ]; then echo Failed - chksums $A $B differ; exit 1; fi
	echo OK
	echo $N "cleaning ${D}" ${DOTS}...........................................$NL
	bk clean ${D}
	if [ -f ${D}foo ]; then echo Failed to clean foo.; exit 1; fi
	echo OK
	# XXX - this looks up to far for the pending file
	echo $N "checkout of the directory ${D}" ${DOTS}..........................$NL
	bk co $Q ${D}
	if [ ! -f ${D}foo ]; then echo Failed to get foo.; exit 1; fi
	if writable ${D}foo; then echo foo is writable; exit 1; fi
	echo OK
	if [ $ATT = YES ]
	then
	    # OK, now try it with s.names, no SCCS/
	    echo $N checkin with ${D}s.foo ${DOTS}..................................$NL
	    rm -rf ${D}foo ${D}SCCS
	    cp SAVE ${D}foo
	    bk ci $Q -i ${D}s.foo
	    if [ ! -f ${D}s.foo ]; then echo Failed to create s.foo.; exit 1; fi
	    if [ -f ${D}foo ]; then echo Failed to get foo.; exit 1; fi
	    echo OK
	    echo $N checkout with ${D}s.foo ${DOTS}.................................$NL
	    bk co $Q ${D}s.foo
	    if [ ! -f ${D}foo ]; then echo Failed to get foo.; exit 1; fi
	    if writable ${D}foo; then echo foo is writable; exit 1; fi
	    echo OK
	fi
	echo $N "cleaning ${D}" ${DOTS}...........................................$NL
	bk clean ${D}
	if [ -f ${D}foo ]; then echo Failed to clean foo.; exit 1; fi
	echo OK
	echo $N "checkout of the directory ${D}" ${DOTS}..........................$NL
	bk co $Q ${D}
	if [ ! -f ${D}foo ]; then echo Failed to get foo.; exit 1; fi
	if writable ${D}foo; then echo foo is writable; exit 1; fi
	echo OK
done
cd $HERE
rm -rf root

# need license to work outside of a repository
BK_CONFIG="license:$BKL_P;licsign1:$BKL_P1$BKL_P2$BKL_P3"
export BK_CONFIG

echo $N Check in files named s.something ............................$NL
mkdir -p bar/blech
echo foo > s.foo
echo foo > bar/s.foo
echo foo > bar/blech/s.foo
bk _find . | grep s.foo | bk ci $S -i -
if [ ! -f SCCS/s.s.foo ]; then echo failed on s.s.foo; exit 1; fi
if [ ! -f bar/SCCS/s.s.foo ]; then echo failed on bar/SCCS/s.s.foo; exit 1; fi
if [ ! -f bar/blech/SCCS/s.s.foo ]; then echo failed on bar/blech/s.foo; exit 1; fi
echo OK
echo $N Clean files named s.something ...............................$NL
bk clean; bk clean bar; bk clean bar/blech
if [ -f s.foo ]; then echo failed on s.s.foo; exit 1; fi
if [ -f bar/s.foo ]; then echo failed on bar/SCCS/s.s.foo; exit 1; fi
if [ -f bar/blech/s.foo ]; then echo failed on bar/blech/s.foo; exit 1; fi
echo OK
echo $N Check out files named s.something ...........................$NL
bk co $Q s.foo bar/s.foo bar/blech/s.foo
if [ ! -f s.foo ]; then echo failed on s.foo; exit 1; fi
if [ ! -f bar/s.foo ]; then echo failed on bar/s.foo; exit 1; fi
if [ ! -f bar/blech/s.foo ]; then echo failed on bar/blech/s.foo; exit 1; fi
echo OK
bk clean; bk clean bar; bk clean bar/blech
echo $N get files named s.something using - .........................$NL
bk co $Q - <<EOF
s.foo
bar/s.foo
bar/blech/s.foo
EOF
if [ ! -f s.foo ]; then echo failed on s.foo; exit 1; fi
if [ ! -f bar/s.foo ]; then echo failed on bar/s.foo; exit 1; fi
if [ ! -f bar/blech/s.foo ]; then echo failed on bar/blech/s.foo; exit 1; fi
echo OK
bk clean; bk clean bar; bk clean bar/blech
echo $N get files named SCCS/s.something using - ....................$NL
bk co $Q - <<EOF
SCCS/s.s.foo
bar/SCCS/s.s.foo
bar/blech/SCCS/s.s.foo
EOF
if [ ! -f s.foo ]; then echo failed on s.foo; exit 1; fi
if [ ! -f bar/s.foo ]; then echo failed on bar/s.foo; exit 1; fi
if [ ! -f bar/blech/s.foo ]; then echo failed on bar/blech/s.foo; exit 1; fi
echo OK
echo $N get -S should not check out files again .....................$NL
touch ref
echo "new" > ref
sleep 1
bk co $Q -S s.foo
find . -name ref | grep "^\./foo.c$"
if [ $? -eq 0 ]; then echo failed; exit 1; fi
echo OK
echo $N get -S should ignore modified files .........................$NL
bk co $Q -e s.foo
bk co $Q -S s.foo 2>${DEV_NULL}
if [ $? != 0 ]
then	echo failed to ignore modified file; exit 1
fi
echo OK
