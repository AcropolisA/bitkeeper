# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Because some proxy disallow proxy for localhost
unsetHttpProxy

echo $N Create initial repository ...................................$NL
commercial project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
bk sane 2> sane.out || { echo failed; cat sane.out; exit 1; }
echo OK

echo $N Create some data ............................................$NL
mkdir src
cd src
echo foo > foo.c
echo bar > bar.c
echo h > h.h
bk ci $Q -i foo.c bar.c h.h
BK="`bk bin`/bk"
test $PLATFORM = WIN32 && BK=${BK}.exe
for i in 1 2 3
do	cp $BK bk$i
done
bk new $Q bk?
bk commit $Q -ycset1
if [ ! -f SCCS/s.foo.c ]; then echo failed to create history; exit 1; fi
echo OK

echo $N clone the workspace .........................................$NL
bk clone $Q $HERE/project $HERE/copy || exit 1
cd $HERE/copy
if [ ! -f "BitKeeper/etc/SCCS/x.dfile" ]; then echo failed; exit 1; fi
P=`port 50000`
bk bkd -q -d -p$P -ikill > $HERE/BKD 2>&1
echo OK

echo $N die part way through a clone and make sure we clean locks ...$NL
cd $HERE
BK_DIE_OFFSET=10 bk clone bk://localhost:$P junk > OUT 2>&1
# cat OUT
bk _kill bk://localhost:$P || exit 1
cd $HERE/copy
for i in 1 2 3
do	bk lock -q && break
	sleep $i
done
bk lock -q || {
	echo failed to clean up locks
	bk lock -l
	exit 1
}
cd $HERE
rm -rf junk
echo OK

echo $N Make sure that we leave the pid file there - background .....$NL
cd $HERE/project
rm -f $HERE/LOG
P=`port 51000`
# We want the pid of the process that is running, not the parent process
bk bkd -dqp$P -l$HERE/LOG -P$HERE/PID -ikill &
PARENT=$!
wait $PARENT
test -f $HERE/PID || {
	echo No pid file
	exit 1
}
PID=`cat $HERE/PID`
test X$PID = X && {
	echo Empty pid file
	exit 1
}
test $PARENT = $PID && {
	echo wrong pid in pid file
	exit 1
}
echo OK

echo $N Make sure that commands leave the pid file alone ............$NL
bk changes bk://localhost:$P > /dev/null || exit 1
GOT=`cat $HERE/PID`
test $PID = $GOT || {
	echo Child stomped on pid file
	exit 1
}
echo OK

echo $N Make sure that we support log files - background ............$NL
sleep 1
test -f $HERE/LOG || {
	echo No log file
	exit 1
}
grep -q changes $HERE/LOG || {
	echo bad log file
	cat $HERE/LOG
	exit 1
}
echo OK

echo $N Make sure that we disallow looking out of repo ..............$NL
bk changes -r+ bk://localhost:$P/$HERE/copy > $HERE/WANT 2>&1
grep -q 'ERROR-cannot cd to' $HERE/WANT || {
	echo failed 
	cat $HERE/WANT
	exit 1
}
bk _kill bk://localhost:$P || exit 1
echo OK

# Now we know that $P is an unused port, go grab it
echo $N Make sure that we leave the pid file there - foreground .....$NL
cd $HERE/project
rm -f $HERE/PID $HERE/LOG BitKeeper/log/*log
# I know the "&" seems like it is background but what I mean is that it
# is not a daemon, it's waiting around.  I have to do & to run the test.
bk bkd -ikill -dDp$P -l$HERE/LOG -P$HERE/PID &
WANT=$!
sleep 2
test -f $HERE/PID || {
	echo No pid file
	ls $HERE
	exit 1
}
PID=`cat $HERE/PID`
test X$PID = X && {
	echo Empty pid file
	exit 1
}
kill -0 $WANT || {
	unable to kill $PID
	exit 1
}
# create log file
bk changes -r+ bk://localhost:$P >/dev/null 2>&1
echo OK

echo $N Make sure that we support log files - foreground ............$NL
bk _usleep 10000
test -f $HERE/LOG || {
	echo No log file
	exit 1
}
grep -q changes $HERE/LOG || {
	echo bad log file
	cat $HERE/LOG
	exit 1
}
echo OK

echo $N Make sure that we exit 2 if the port is in use - background .$NL
bk bkd -p$P > OUT 2>&1
test $? -eq 2 || {
	echo failed
	exit 1
}
grep -q use OUT || {
	echo failed
	cat OUT
	exit 1
}
# Flush bkd
bk _kill bk://localhost:$P || exit 1
echo OK

# Win32 note: If bkd binary is on a network drive
# NT will refuse to start the bkd service. (permission denied)
# Please make sure the bk binary is on a local disk
# before you run this test.
echo $N "push a new changeset via bkd (no compression)" ...............$NL
cd $HERE/copy
bk bkd -q -d -p$P -ikill > $HERE/BKD 2>&1
cd $HERE/project/src
echo woo > woo.c
bk ci $Q -i woo.c || exit 1
bk commit $Q -ycset1 || exit 1
bk push $Q -z0 bk://localhost:$P || exit 1
cd $HERE/copy/src
if [ ! -f SCCS/s.woo.c ]; then echo failed; exit 1; fi
bk lock -U $HERE/copy
bk _kill bk://localhost:$P || exit 1
echo OK

echo $N "pull a new changeset via bkd (no compression)" ...............$NL
cd $HERE/project/src
echo zoo > zoo.c
bk ci $Q -i zoo.c
bk commit $Q -ycset1
cd $HERE/project
P=`port 50000`
bk bkd -q -d -p$P -ikill
bk lock -U $HERE/copy        # needed on Freebsd4
cd $HERE/copy/src
bk pull $Q -t -z0 bk://localhost:$P
if [ ! -f SCCS/s.zoo.c ]; then echo failed; exit 1; fi
bk lock -U $HERE/project
bk _kill bk://localhost:$P || exit 1
echo OK

echo $N "pull a new changeset via bkd (with compression)" .............$NL
cd $HERE/project/src
echo boo > boo.c
bk ci $Q -i boo.c
bk commit $Q -ycset1
cd $HERE/project
P=`port 50000`
bk bkd -q -d -p$P -ikill
cd $HERE/copy/src
bk pull -t $Q bk://localhost:$P
if [ ! -f SCCS/s.boo.c ]; then echo failed; exit 1; fi
bk lock -U $HERE/project
bk _kill bk://localhost:$P || exit 1
echo OK

echo $N "pull via bkd -xpull" .........................................$NL
cd $HERE/project
P=`port 50000`
bk bkd -q -xpull -p$P -ikill
cd $HERE/copy/src
bk pull -t bk://localhost:$P > pull.out 2>&1
grep -q "bkd has disabled" pull.out
if [ $? -ne 0 ]; then echo failed; cat pull.out; exit 1; fi
bk lock -U $HERE/project
bk _kill bk://localhost:$P || exit 1
echo OK

echo $N "push a new changeset via bkd (with compression)" .............$NL
cd $HERE/copy
P=`port 50000`
bk bkd -q -d -p$P -ikill -l$HERE/LOG
cd $HERE/project/src
echo aoo > aoo.c
bk ci $Q -i aoo.c
bk commit $Q -ycset1
bk push $Q -z6 bk://localhost:$P
cd $HERE/copy/src
if [ ! -f SCCS/s.aoo.c ]; then echo failed; exit 1; fi
bk lock -U $HERE/copy
bk _kill bk://localhost:$P || exit 1
echo OK

echo $N clone a tree via bkd ........................................$NL
cd $HERE/project
P=`port 50000`
bk bkd -q -d -p$P -ikill
bk clone $Q bk://localhost:$P $HERE/copy2
if [ -f BitKeeper/tmp/clone.sfio ]; then echo failed; exit 1; fi
cd $HERE/copy2/src
if [ ! -f SCCS/s.aoo.c ]; then echo failed; exit 1; fi
bk lock -U $HERE/project
bk _kill bk://localhost:$P || exit 1
echo OK

if [ "$PLATFORM" != "WIN32" ]
then
echo $N clone a tree via bkd with buffer_clone enabled ..............$NL
cd $HERE/project
P=50000
bk bkd -q -Bd -p$P -c1 
while [ $? -eq 2 ]
do	P=`expr $P + 1`
	bk bkd -q -Bd -p$P -c1 
done
rm -rf $HERE/copy2
bk clone $Q bk://localhost:$P $HERE/copy2
if [ ! -f BitKeeper/tmp/clone.sfio ]; then echo failed; exit 1; fi
cd $HERE/copy2/src
if [ ! -f SCCS/s.aoo.c ]; then echo failed; exit 1; fi
echo OK
fi

echo $N "pull a new changeset via bkd -xcd -xpush " ...................$NL
cd $HERE/project/src
echo coo > coo.c
bk ci $Q -i coo.c
bk commit $Q -ycset1
cd $HERE/project
P=`port 50000`
bk bkd -q -d -p$P -xcd -xpush -ikill 
cd $HERE/copy/src
bk pull -t $Q bk://localhost:$P
if [ ! -f SCCS/s.coo.c ]; then echo failed; exit 1; fi
bk lock -U $HERE/project
bk _kill bk://localhost:$P || exit 1
echo OK

echo $N check a push to bkd with a gfile conflict ...................$NL
P=`port 50000`
cd $HERE/project
bk bkd -q -d -p$P -ikill
cd $HERE/project
echo data1 > conflict.c
cd $HERE/copy
echo data2 > old.c
bk new $Q old.c
bk commit $Q -yold.c || exit 1
bk push -c1 $Q bk://localhost:$P || exit 1
bk lock -U $HERE/project
cd $HERE/copy
bk mv old.c conflict.c || exit 1
bk commit $Q -ygconflict
echo "" | bk push -c1 bk://localhost:$P > bk.out 2>&1
grep -q "Did not resolve 1 renames, no conflicts causing abort." bk.out
if [ $? -ne 0 ]; then echo failed; cat bk.out; exit 1; fi
rm -f  $HERE/project/conflict.c
echo OK

echo $N check http pull from bkd ....................................$NL
bk lock -U $HERE/project
cd $HERE/project/src
bk edit $Q bar.c
echo data3 > bar.c
bk delta $Q -ydata3 bar.c
bk commit $Q -ydata3
cd $HERE/copy
bk pull $Q http://localhost:$P/.
if [ $? -ne 0 ]; then echo failed; exit 1; fi
echo OK

echo $N "check when server can't write to BitKeeper/tmp"...............$NL
bk unpull $Q -f|| exit 1
chmod -w $HERE/project/BitKeeper/tmp
bk pull $Q bk://localhost:$P/ || exit 1
chmod +w $HERE/project/BitKeeper/tmp
echo OK

echo $N check http clone from bkd ...................................$NL
cd $HERE
bk clone $Q http://localhost:$P $HERE/project2
if [ $? -ne 0 ]; then echo failed; exit 1; fi
echo OK

echo $N check http clone with bad -r from bkd .......................$NL
bk clone $Q -rbad http://localhost:$P $HERE/junk2
if [ $? -eq 0 ]; then echo failed; exit 1; fi
bk lock -U $HERE/project
bk _kill bk://localhost:$P || exit 1
echo OK

echo $N Make sure bkd -C disallows cd to parent dir .................$NL
cd $HERE/project/src
P=`port 50000`
bk bkd -q -d -C -p$P -ikill
cd $HERE/copy
bk pull bk://localhost:$P/$HERE/project > pull.out 2>&1
grep -q "ERROR-cannot cd to" pull.out
if [ $? -ne 0 ]; then echo failed 1; cat pull.out; exit 1 ; fi
bk pull bk://localhost:$P.. > pull.out 2>&1
grep -q "ERROR-cannot cd to" pull.out
if [ $? -ne 0 ]; then echo failed 2; cat pull.out; exit 1 ; fi
bk pull bk://localhost:$P/sub/../../project > pull.out 2>&1
grep -q "ERROR-cannot cd to" pull.out
if [ $? -ne 0 ]; then echo failed 3; cat pull.out; exit 1 ; fi
bk lock -U $HERE/project
bk _kill bk://localhost:$P || exit 1
echo OK

echo $N Make sure bkd logs requests under the remote user name ......$NL
cd $HERE/project
cp /dev/null BitKeeper/log/repo_log
P=`port 50000`
BK_USER=garbage bk bkd -qdp$P -ikill
cd $HERE/copy
BK_USER=pull_USER bk pull bk://localhost:$P/$HERE/project > pull.out 2>&1
bk _usleep 250000
grep -q pull_USER $HERE/project/BitKeeper/log/repo_log || {
	echo failed to get first name right in pull
	cat $HERE/project/BitKeeper/log/repo_log
	exit 1
}
BK_USER=USER_PULL bk pull bk://localhost:$P/$HERE/project > pull.out 2>&1
bk _usleep 250000
grep -q USER_PULL $HERE/project/BitKeeper/log/repo_log || {
	echo failed to get second name right in pull
	cat $HERE/project/BitKeeper/log/repo_log
	exit 1
}
BK_USER=CLONE bk clone $Q bk://localhost:$P/$HERE/project $HERE/clone
bk _usleep 250000
grep -q CLONE $HERE/project/BitKeeper/log/repo_log || {
	echo failed to get third name right in clone
	cat $HERE/project/BitKeeper/log/repo_log
	exit 1
}
BK_USER=PUSH bk push $Q bk://localhost:$P/$HERE/project 
bk _usleep 250000
grep -q PUSH $HERE/project/BitKeeper/log/repo_log || {
	echo failed to get fourth name right in push
	cat $HERE/project/BitKeeper/log/repo_log
	exit 1
}
bk lock -U $HERE/project
bk _kill bk://localhost:$P || exit 1
bk lock -U
echo OK
