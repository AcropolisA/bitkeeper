# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.


# Copyright (c) 2002 lm
# %K%

echo $N Create initial repository ...................................$NL
commercial project
echo foo > f
BK_USER=adam bk delta $Q -i -y'Initial checkin' f
BK_USER=adam bk commit $Q -y'Initial checkin' || exit 1
bk edit $Q f
BK_USER=second bk delta $Q -y'Second checkin' f
BK_USER=second bk commit $Q -Ssecond -y'Second checkin' || exit 1
bk edit $Q f
BK_USER=third bk delta $Q -y'Third checkin' f
BK_USER=third bk commit $Q -Sthird -y'Third checkin' || exit 1
echo OK

echo $N Check that -/search/ works ..................................$NL
bk changes -/Second/ > XXX
grep -q ChangeSet@1.3 XXX || {
	echo failed to match the 1.3 changeset
	cat XXX
	exit 1
}
for r in 1.1 1.2 1.4
do	
	grep -q ChangeSet@$r XXX && {
		echo matched the $r changeset
		cat XXX
		exit 1
	}
done
bk changes -/second/i > YYY
cmp -s XXX YYY || {
	echo Failed to match when ignoring case
	exit 1
}
echo OK

echo $N Check that -/regex/ works ...................................$NL
bk changes -'/^S.* checkin$/' > XXX
grep -q ChangeSet@1.3 XXX || {
	echo failed to match the 1.3 changeset
	cat XXX
	exit 1
}
for r in 1.1 1.2 1.4
do	
	grep -q ChangeSet@$r XXX && {
		echo matched the $r changeset
		cat XXX
		exit 1
	}
done
echo OK

echo $N Check that -/regex/i works ..................................$NL
bk changes -'/^s.* CHECKIN$/i' > XXX
grep -q ChangeSet@1.3 XXX || {
	echo failed to match the 1.3 changeset
	cat XXX
	exit 1
}
for r in 1.1 1.2 1.4
do	
	grep -q ChangeSet@$r XXX && {
		echo matched the $r changeset
		cat XXX
		exit 1
	}
done
echo OK

echo $N Check that filtering on included users works ................$NL
bk changes -usecond > XXX
grep -q ChangeSet@1.3 XXX || {
	echo failed to match the 1.3 changeset
	cat XXX
	exit 1
}
for r in 1.1 1.2 1.4
do	grep -q ChangeSet@$r XXX && {
		echo matched the $r changeset
		cat XXX
		exit 1
	}
done
bk changes -uadam -usecond > XXX
for r in 1.2 1.3
do	grep -q ChangeSet@$r XXX || {
		echo failed to match the $r changeset
		cat XXX
		exit 1
	}
done
for r in 1.1 1.4
do	grep -q ChangeSet@$r XXX && {
		echo matched the $r changeset
		cat XXX
		exit 1
	}
done
echo OK

echo $N Check that filtering on excluded users works ................$NL
bk changes -Usecond > XXX
grep -q ChangeSet@1.3 XXX && {
	echo matched the 1.3 changeset
	cat XXX
	exit 1
}
for r in 1.1 1.2 1.4
do	grep -q ChangeSet@$r XXX || {
		echo did not match the $r changeset
		cat XXX
		exit 1
	}
done
echo OK

echo $N Check that dspecs work ......................................$NL
cat > WANT <<EOF
1.4
1.3
1.2
1.1
1.0
EOF
bk changes -nd:I: > XXX
cmp -s XXX WANT || {
	echo backward dpsec failed
	cat XXX
	exit 1
}

cat > WANT <<EOF
1.0
1.1
1.2
1.3
1.4
EOF
bk changes -fnd:I: > XXX
cmp -s XXX WANT || {
	echo forward dpsec failed
	cat XXX
	exit 1
}
echo OK

echo $N Check that keys work . ......................................$NL
bk prs -hr1.0.. -nd:KEY: ChangeSet | bk _sort > WANT
bk changes -k | bk _sort > GOT
cmp -s WANT GOT || {
	echo wrong keys
	diff WANT GOT
	exit 1
}
echo OK

echo $N Check that user restrictions work ...........................$NL
bk changes -usecond > GOT
bk changes -rsecond > WANT
cmp -s WANT GOT || {
	echo wrong answer
	diff WANT GOT
	exit 1
}
bk changes -Usecond > GOT
bk changes -r1.4,1.2,1.1,1.0 > WANT
cmp -s WANT GOT || {
	echo wrong answer
	diff WANT GOT
	exit 1
}
echo OK

echo $N Check tag listing ...........................................$NL
bk changes -t > GOT
bk changes -rthird > WANT
bk changes -rsecond >> WANT
cmp -s WANT GOT || {
	echo wrong answer
	diff WANT GOT
	exit 1
}
echo OK

echo $N Check remote/local listings .................................$NL
cd $HERE
bk clone $Q project clone
cd project
ls > LS
bk new $Q LS
BK_USER=joe bk commit $Q -yproject
cd $HERE/clone
echo hi mom > mommy
bk new $Q mommy
BK_USER=jane bk commit $Q -yclone
bk changes -L -nd':I: :P: :C:' > GOT
echo 1.5 jane clone > WANT
cmp -s WANT GOT || {
	echo local only listing failed, got 
	cat GOT
	exit 1
}
bk changes -R -nd':I: :P: :C:' > GOT
echo 1.5 joe project > WANT
cmp -s WANT GOT || {
	echo remote only listing failed, got 
	cat GOT
	exit 1
}
# cut out the newline
bk changes -L -d':I: :P: :C:' > GOT
echon 1.5 jane clone > WANT
cmp -s WANT GOT || {
	echo local only listing failed, got 
	cat GOT
	exit 1
}
bk changes -R -d':I: :P: :C:' > GOT
echo 1.5 joe project > WANT
cmp -s WANT GOT || {
	echo remote only listing failed, got 
	cat GOT
	exit 1
}
echo OK

echo $N Check remote dspec listing ..................................$NL
cd $HERE/clone
bk changes -nd':I: :P: :C:' > WANT
cd $HERE
bk changes -nd':I: :P: :C:' $HERE/clone > GOT
cmp -s clone/WANT GOT || {
	echo wrong answer
	diff WANT GOT
	exit 1
}
echo OK

echo $N Check remote search combined with dspec .....................$NL
# The /dev/null is because we exit so fast that the bkd can't update the
# logs, at least that is my theory.
cd $HERE/clone
bk changes -/Second/ -nd':I: :P: :C:' ../project > GOT 2>/dev/null
echo 1.3 second Second checkin > WANT
cmp -s WANT GOT || {
	echo remote only listing failed, got 
	cat GOT
	exit 1
}
echo OK

echo $N Check remote key listing ....................................$NL
bk prs -hr1.0.. -nd:KEY: ChangeSet | bk _sort > WANT
cd $HERE
bk changes -k $HERE/clone | bk _sort > GOT
cmp -s clone/WANT GOT || {
	echo wrong keys
	diff WANT GOT
	diff clone/WANT GOT
	exit 1
}
echo OK

echo $N Check remote verbose listing ................................$NL
cd $HERE/clone
bk changes -vr+ | bk undos > WANT
cd $HERE
bk changes -vr+ $HERE/clone > GOT
cmp -s clone/WANT GOT || {
	echo wrong answer
	diff clone/WANT GOT
	exit 1
}
echo OK

echo $N Check bk changes -R url1 url2 ...............................$NL
cd $HERE
bk clone $Q  clone clone2
cd $HERE/project
bk changes -R -k $HERE/clone > keylist1
bk changes -R -D -k $HERE/clone $HERE/clone2 > keylist2
cmp -s keylist1 keylist2 || { echo failed; exit 1; }
cd $HERE/clone2
waitForUnlock $HERE/clone2
bk edit $Q f
echo "new" >> f
bk delta $Q -ynew f
bk commit $Q -ynew
cd $HERE/project
bk changes -R -D -k $HERE/clone $HERE/clone2 > keylist2
cmp -s keylist1 keylist2 && { echo failed; exit 1; }
bk prs -nhr+ -d':KEY:' $HERE/clone2/ChangeSet >> keylist1
bk _sort < keylist1 > keylist1_sorted
bk _sort < keylist2 > keylist2_sorted
cmp -s keylist1_sorted keylist2_sorted || { echo failed; exit 1; }
echo OK

echo $N Check bk changes -R - .......................................$NL
cd $HERE/clone
bk changes -k -r+ > $HERE/K1
cd $HERE/clone2
bk changes -k -r+ > $HERE/K2
cd $HERE/project
echo $HERE/clone | bk changes -D -R -k - > GOT
checkfiles GOT $HERE/K1
( echo $HERE/clone
  echo $HERE/clone2 ) | bk changes -D -R -k - | bk _sort > GOT
cat $HERE/K1 $HERE/K2 | bk _sort > WANT
checkfiles WANT GOT
echo OK

echo $N Check bk changes -L - .......................................$NL
( echo $HERE/clone2
  echo $HERE/project ) | bk changes -k -L - > GOT
bk changes -r+ -k $HERE/project > WANT
checkfiles WANT GOT
echo OK

echo $N Check bk changes - ..........................................$NL
bk changes -r+ -k | bk changes - > GOT
bk changes -r+ > WANT
checkfiles WANT GOT
bk changes -k | bk changes - > GOT
bk changes > WANT
checkfiles WANT GOT
echo OK

echo $N Check that changes -L/-R in a subdirectory works ............$NL
cd $HERE/project
mkdir subdir
cd subdir
bk changes -R -k $HERE/clone > GOT
checkfiles $HERE/K1 GOT
bk changes -L -k $HERE/clone > GOT
bk changes -r+ -k > WANT
checkfiles WANT GOT
echo OK

echo $N Demonstrate out of order changesets .........................$NL
commercial p
touch foo
bk new $Q foo
# The long string needed to overcome fudges.
# 1 more than need for that case where the seconds wrap during the test
bk mv foo bar
bk mv bar b
bk mv b foo
bk mv foo fee
bk commit $Q -yy
files=`bk changes -T -r+ -v -d:DPN:`
if [ "$files" != "ChangeSetfeefoobbarfoofoo" ]
then	echo failed; exit 1;
else	echo OK
fi
cd $HERE
rm -rf p

echo $N Demonstrate the other way they can be out of order ..........$NL
commercial p
touch foo
bk new $Q foo
cd $HERE
bk clone $Q p c2
cd c2
touch bar
bk new $Q bar
bk commit $Q -yq
cd $HERE/p
bk commit $Q -ya
cd $HERE/c2
bk pull $Q || exit 1
files=`bk changes -r1.1.1.1,1.2 -v -d:DPN:`
if [ "$files" != "ChangeSetfoofooChangeSetbarbar" ]
then	echo failed; exit 1;
else	echo OK
fi
cd $HERE
rm -rf p

echo $N Does combining restrictions work ............................$NL
cd project
revs=`bk changes -c-1Y -ujoe -d:REV:`
test X$revs != X1.5 && {
	echo failed
	exit 1
}
echo OK

echo $N "Make sure no auto indent for -d<dspec>"  ......................$NL
bk changes -r+ -v -d':DPN:\n' > changes.out
bk undos <<EOF > ref
ChangeSet
LS
LS
EOF
cmp -s ref changes.out || { echo failed; exit 1; }
echo OK

echo $N Verify changes -L works with tags ...........................$NL
cd $HERE/clone
bk tag $Q -r1.2 bar
bk changes -L -nd':REV: :COMMENTS: :SYMBOL:' > chgs
cat <<EOF > expect
1.2  bar
1.5 C clone
 
EOF
bk diff -u expect chgs || {
	echo changes returned wrong data
	exit 1
}
echo OK

echo $N Change changes on a remote repository .......................$NL
key=`bk prs -r+ -hnd:KEY: ChangeSet`
cd $HERE
key2=`bk changes -r+ -nd:KEY: clone`
if [ "$key" != "$key2" ]
then	echo Remote changes failed
	echo $key vs $key2
	exit 1
fi
echo OK

echo $N Demonstrate how pull -nl works ..............................$NL
cd $HERE
bk clone $Q project merge
cd merge
bk pull $Q ../clone
cd ../project
bk pull $Q ../clone
# XXX strange -q suppress all output
bk pull -n ../merge >junk 2> out
grep -q "1.6" out || {
	echo bk pull -n had wrong output:
	cat out
	exit 1
}
# XXX but -q "works" here
bk pull -nl $Q ../merge 2> out
grep -q "1.6" out || {
	echo bk pull -nl had wrong output:
	cat out
	exit 1
}
echo OK

echo $N Check superset with no changes...............................$NL
cd $HERE
bk clone $Q project superset
cd superset
bk superset > ../GOT
test $? -ne 0 && {
	echo superset with no changes should exit 0
	exit 1
}
GOT=`cat ../GOT`
test "X$GOT" != "X" && {
	echo superset with no changes should be silent
	exit 1
}
echo OK

echo $N Check superset with changes..................................$NL
cd $HERE/superset
echo FOO > FOO
bk new $Q FOO
BK_USER=joe bk commit $Q -yproject
echo BAR > BAR
bk superset > ../GOT
test $? -ne 1 && {
	echo superset with changes should exit 1
	exit 1
}
grep FOO ../GOT >/dev/null || {
	echo superset missed a changeset
	exit 1
}
grep BAR ../GOT >/dev/null || {
	echo superset missed an extra file
	exit 1
}
echo OK

echo $N Check date formats ..........................................$NL
Y=`bk prs -Yhnd:Dy: -r+ ChangeSet`
bk changes -nd:Dy: > OUT
bk changes -v -nd:Dy: >> OUT
test `grep -v 1971 OUT | bk _sort -u` = $Y || {
	echo not all YEAR4 dates
	exit 1
}
echo OK

echo $N Check that changes -L -R works ..............................$NL
cd $HERE
bk clone $Q project clone1
cd clone1
bk edit $Q f
bk delta $Q -y'clone1 delta 1' f
bk commit $Q -y'clone1 checkin 1' || exit 1

cd $HERE
rm -rf clone2
bk clone $Q project clone2 || exit 1
cd clone2 || exit 1
bk edit $Q f
bk delta $Q -y'clone2 delta' f
bk commit $Q -y'clone2 checkin' || exit 1

(bk changes -kL ../clone1; bk changes -kR ../clone1) > WANT
bk changes -k -L -R ../clone1 | grep -v '^==== ' > GOT
checkfiles WANT GOT
echo OK

