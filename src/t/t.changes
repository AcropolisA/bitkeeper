# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.


# Copyright (c) 2002 lm
# %K%

echo $N Create initial repository ...................................$NL
commercial project
echo foo > f
BK_USER=adam bk delta $Q -i -y'Initial checkin' f
BK_USER=adam bk commit $Q -y'Initial checkin' || exit 1
bk edit $Q f
BK_USER=second bk delta $Q -fy'Second checkin' f
BK_USER=second bk commit $Q -Ssecond -y'Second checkin' || exit 1
bk edit $Q f
BK_USER=third bk delta $Q -fy'Third checkin' f
BK_USER=third bk commit $Q -Sthird -y'Third checkin' || exit 1
echo OK

echo $N Check that -/search/ works ..................................$NL
bk changes -/Second/ > XXX
grep -q ChangeSet@1.3 XXX || {
	echo failed to match the 1.3 changeset
	cat XXX
	exit 1
}
for r in 1.1 1.2 1.4
do
	grep -q ChangeSet@$r XXX && {
		echo matched the $r changeset
		cat XXX
		exit 1
	}
done
bk changes -/second/i > YYY
checkfiles XXX YYY
echo OK

echo $N Check that -/regex/ works ...................................$NL
bk changes -'/^S.* checkin$/' > XXX
grep -q ChangeSet@1.3 XXX || {
	echo failed to match the 1.3 changeset
	cat XXX
	exit 1
}
for r in 1.1 1.2 1.4
do	
	grep -q ChangeSet@$r XXX && {
		echo matched the $r changeset
		cat XXX
		exit 1
	}
done
echo OK

echo $N Check that -/regex/i works ..................................$NL
bk changes -'/^s.* CHECKIN$/i' > XXX
grep -q ChangeSet@1.3 XXX || {
	echo failed to match the 1.3 changeset
	cat XXX
	exit 1
}
for r in 1.1 1.2 1.4
do	
	grep -q ChangeSet@$r XXX && {
		echo matched the $r changeset
		cat XXX
		exit 1
	}
done
echo OK

echo $N Check that filtering on included users works ................$NL
bk changes -usecond > XXX
grep -q ChangeSet@1.3 XXX || {
	echo failed to match the 1.3 changeset
	cat XXX
	exit 1
}
for r in 1.1 1.2 1.4
do	grep -q ChangeSet@$r XXX && {
		echo matched the $r changeset
		cat XXX
		exit 1
	}
done
bk changes -uadam -usecond > XXX
for r in 1.2 1.3
do	grep -q ChangeSet@$r XXX || {
		echo failed to match the $r changeset
		cat XXX
		exit 1
	}
done
for r in 1.1 1.4
do	grep -q ChangeSet@$r XXX && {
		echo matched the $r changeset
		cat XXX
		exit 1
	}
done
echo OK

echo $N Check that filtering on excluded users works ................$NL
bk changes -Usecond > XXX
grep -q ChangeSet@1.3 XXX && {
	echo matched the 1.3 changeset
	cat XXX
	exit 1
}
for r in 1.1 1.2 1.4
do	grep -q ChangeSet@$r XXX || {
		echo did not match the $r changeset
		cat XXX
		exit 1
	}
done
echo OK

echo $N Check that dspecs work ......................................$NL
cat > WANT <<EOF
1.4
1.3
1.2
1.1
1.0
EOF
bk changes -nd:I: > XXX
checkfiles XXX WANT

cat > WANT <<EOF
1.0
1.1
1.2
1.3
1.4
EOF
bk changes -fnd:I: > XXX
checkfiles XXX WANT
echo OK

echo $N Check that keys work . ......................................$NL
bk prs -r.. -hnd:KEY: ChangeSet | bk sort > WANT
bk changes -k | bk sort > GOT
checkfiles WANT GOT
echo OK

echo $N Check that user restrictions work ...........................$NL
bk changes -usecond > GOT
bk changes -rsecond > WANT
checkfiles WANT GOT
bk changes -Usecond > GOT
bk changes -r1.4,1.2,1.1,1.0 > WANT
checkfiles WANT GOT
echo OK

echo $N Check tag listing ...........................................$NL
bk changes -t > GOT
bk changes -rthird > WANT
bk changes -rsecond >> WANT
checkfiles WANT GOT
echo OK

echo $N Check that -/regex/t works ..................................$NL
bk changes -/s.*/t -nd:SYMBOL: > GOT
echo second > WANT
cmpfiles WANT GOT
bk changes -/t*/gt -nd:SYMBOL: > GOT
echo third > WANT
cmpfiles WANT GOT
echo OK

echo $N Check remote/local listings .................................$NL
cd "$HERE"
bk clone $Q project clone
cd project
ls > LS
bk new $Q LS
BK_USER=joe bk commit $Q -yproject
cd "$HERE/clone"
echo hi mom > mommy
bk new $Q mommy
BK_USER=jane bk commit $Q -yclone
bk changes -L -qnd':I: :P: :C:' > GOT
echo 1.5 jane clone > WANT
checkfiles WANT GOT
bk changes -R -qnd':I: :P: :C:' > GOT
echo 1.5 joe project > WANT
checkfiles WANT GOT
# cut out the newline
bk changes -L -qd':I: :P: :C:' > GOT
echon 1.5 jane clone > WANT
checkfiles WANT GOT
bk changes -R -qd':I: :P: :C:' > GOT
echo 1.5 joe project > WANT
checkfiles WANT GOT
echo OK

echo $N Check remote dspec listing ..................................$NL
cd "$HERE/clone"
bk changes -qnd':I: :P: :C:' > WANT
cd "$HERE"
bk changes -qnd':I: :P: :C:' "$HERE/clone" > GOT
checkfiles clone/WANT GOT
echo OK

echo $N Check remote search combined with dspec .....................$NL
# The /dev/null is because we exit so fast that the bkd can't update the
# logs, at least that is my theory.
cd "$HERE/clone"
bk changes -/Second/ -qnd':I: :P: :C:' ../project > GOT 2>/dev/null
echo 1.3 second Second checkin > WANT
checkfiles WANT GOT
echo OK

echo $N Check remote key listing ....................................$NL
bk prs -r.. -h -nd:KEY: ChangeSet | bk sort > WANT
cd "$HERE"
bk changes -k "$HERE/clone" | bk sort > GOT
checkfiles clone/WANT GOT
echo OK

echo $N Check remote verbose listing ................................$NL
cd "$HERE/clone"
bk changes -qvr+ | bk undos > WANT
cd "$HERE"
bk changes -qvr+ "$HERE/clone" > GOT
checkfiles clone/WANT GOT
echo OK

echo $N Check bk changes -R url1 url2 ...............................$NL
cd "$HERE"
bk clone $Q  clone clone2
cd "$HERE/project"
bk changes -R -k "$HERE/clone" > keylist1
bk changes -R -k "$HERE/clone" "$HERE/clone2" > keylist2
checkfiles keylist1 keylist2
cd "$HERE/clone2"
bk lock -U
bk edit $Q f
echo "new" >> f
bk delta $Q -ynew f
bk commit $Q -ynew
cd "$HERE/project"
bk changes -R -k "$HERE/clone" "$HERE/clone2" > keylist2
cmp -s keylist1 keylist2 && { echo new key did not appear; exit 1; }
bk prs -nhr+ -d':KEY:' "$HERE/clone2/ChangeSet" >> keylist1
bk sort < keylist1 > keylist1sorted
bk sort < keylist2 > keylist2sorted
checkfiles keylist1sorted keylist2sorted
echo OK

echo $N Check bk changes -R - .......................................$NL
cd "$HERE/clone"
bk changes -k -r+ > "$HERE/K1"
cd "$HERE/clone2"
bk changes -k -r+ > "$HERE/K2"
cd "$HERE/project"
echo "$HERE/clone" | bk changes -R -k - > GOT
checkfiles GOT "$HERE/K1"
( echo "$HERE/clone"
  echo "$HERE/clone2" ) | bk changes -R -k - | bk sort > GOT
cat "$HERE/K1" "$HERE/K2" | bk sort > WANT
checkfiles WANT GOT
echo OK

echo $N Check bk changes -L - .......................................$NL
# PWD=project
( echo "$HERE/clone"
  echo "$HERE/clone2" ) | bk changes -k -L - > GOT
bk changes -r+ -k > WANT
checkfiles WANT GOT
echo OK

echo $N Check bk changes - ..........................................$NL
bk changes -r+ -k | bk changes - > GOT
bk changes -r+ > WANT
checkfiles WANT GOT
bk changes -k | bk changes - > GOT
bk changes > WANT
checkfiles WANT GOT
echo OK

echo $N Check bk changes - url is an error ..........................$NL
# PWD=project
echo + | bk changes - ../clone 2> ERR && {
	echo "failed (it worked)"
	exit 1
}
grep -q "either '-' or URL list" ERR || {
	echo failed
	exit 1
}
cd "$HERE"
echo + | bk changes - project 2> ERR && {
	echo "failed (it worked)"
	exit 1
}
grep -q "either '-' or URL list" ERR || {
	echo failed
	exit 1
}
echo OK

echo $N Check that changes -L/-R in a subdirectory works ............$NL
cd "$HERE/project"
mkdir subdir
cd subdir
bk changes -R -k "$HERE/clone" > GOT
checkfiles "$HERE/K1" GOT
bk changes -L -k "$HERE/clone" > GOT
bk changes -r+ -k > WANT
checkfiles WANT GOT
echo OK

echo $N Demonstrate out of order changesets .........................$NL
commercial p
touch foo
bk new $Q foo
# The long string needed to overcome fudges.
# 1 more than need for that case where the seconds wrap during the test
bk mv foo bar
bk mv bar b
bk mv b foo
bk mv foo fee
bk commit $Q -yy
files=`bk changes -T -r+ -v -d:DPN:`
if [ "$files" != "ChangeSetfeefoobbarfoofoo" ]
then	echo failed; exit 1;
else	echo OK
fi
cd "$HERE"
rm -rf p

echo $N Demonstrate the other way they can be out of order ..........$NL
commercial p
touch foo
bk new $Q foo
cd "$HERE"
bk clone $Q p c2
cd c2
touch bar
bk new $Q bar
bk commit $Q -yq
cd "$HERE/p"
bk commit $Q -ya
cd "$HERE/c2"
bk pull $Q || exit 1
files=`bk changes -r1.1.1.1,1.2 -v -d:DPN:`
if [ "$files" != "ChangeSetfoofooChangeSetbarbar" ]
then	echo failed; exit 1;
else	echo OK
fi
cd "$HERE"
rm -rf p

echo $N Does combining restrictions work ............................$NL
cd project
revs=`bk changes -c-1Y -ujoe -d:REV:`
test X$revs != X1.5 && {
	echo failed
	exit 1
}
echo OK

echo $N "Make sure no auto indent for -d<dspec>"  ......................$NL
bk changes -r+ -v -d':DPN:\n' > changes.out
bk undos <<EOF > ref
ChangeSet
LS
LS
EOF
checkfiles ref changes.out
echo OK

echo $N Verify changes -L works with tags ...........................$NL
cd "$HERE/clone"
bk tag $Q -r1.2 bar
bk changes -aL -qnd':REV: :COMMENTS: :SYMBOL:' > chgs
cat <<EOF > expect
1.2  bar
1.5 C clone
 
EOF
bk diff -u expect chgs || {
	echo changes returned wrong data
	exit 1
}
echo OK

echo $N Change changes on a remote repository .......................$NL
key=`bk prs -r+ -hnd:KEY: ChangeSet`
cd "$HERE"
key2=`bk changes -r+ -qnd:KEY: clone`
if [ "$key" != "$key2" ]
then	echo Remote changes failed
	echo $key vs $key2
	exit 1
fi
echo OK

echo $N Demonstrate how pull -nl works ..............................$NL
cd "$HERE"
bk clone $Q project merge
cd merge
bk pull $Q ../clone
cd ../project
bk pull $Q ../clone
# XXX strange -q suppress all output
bk pull -n ../merge >junk 2> out
grep -q "1.6" out || {
	echo bk pull -n had wrong output:
	cat out
	exit 1
}
# XXX but -q "works" here
bk pull -nl $Q ../merge 2> out
grep -q "1.6" out || {
	echo bk pull -nl had wrong output:
	cat out
	exit 1
}
echo OK

echo $N Check date formats ..........................................$NL
Y=`bk prs -Yhnd:Dy: -r+ ChangeSet`
bk changes -nd:Dy: > OUT || exit 1
bk changes -v -nd:Dy: >> OUT || exit 1
test `grep -v 1971 OUT | bk sort -u` = $Y || {
	echo not all YEAR4 dates
	exit 1
}
echo OK

echo $N Check that changes -L -R works ..............................$NL
cd "$HERE"
bk clone $Q project clone1
cd clone1
bk edit $Q f
bk delta $Q -fy'clone1 delta 1' f
bk commit $Q -y'clone1 checkin 1' || exit 1

cd "$HERE"
rm -rf clone2
bk clone $Q clone1 clone2 || exit 1
cd clone2 || exit 1
bk edit $Q f
bk delta $Q -fy'clone2 delta' f
bk commit $Q -y'clone2 checkin' || exit 1

(bk changes -kL ../clone1; bk changes -kR ../clone1) > WANT
bk changes -qand:KEY: -L -R ../clone1 > GOT
checkfiles WANT GOT
echo OK

echo $N Test changes -L repo1 repo2 .................................$NL
cd "$HERE/clone1"
echo jj > baz
bk new $Q baz || exit 1
bk commit $Q -ybaz || exit 1
bk changes -qand:C: -L ../project > p1
bk changes -qand:C: -L ../clone2  > c1
cat p1 c1 > WANT
bk changes -L -qand:C: ../project ../clone2 > GOT
checkfiles WANT GOT
echo OK

echo $N Test changes -L repo2 repo1 .................................$NL
cat c1 p1 > WANT
bk changes -L -qand:C: ../clone2 ../project > GOT
checkfiles WANT GOT
echo OK

echo $N Test changes -D -L repo1 repo2 ..............................$NL
cd "$HERE/clone1"
bk changes -qand:C: -L ../project > p1
bk changes -qand:C: -L ../clone2  > c1
comm -12 p1 c1 > WANT
bk changes -qand:C: -D -L ../project ../clone2 | sort > GOT
checkfiles WANT GOT
echo OK

echo $N Set up for include/exclude tests ............................$NL
cd "$HERE/project"
for i in man src html
do	mkdir $i
done
for i in foo bar blech
do	echo $i > man/${i}.1
	echo $i > src/${i}.c
	echo $i > src/${i}.h
	echo $i > html/${i}.html
done
bk extras | bk new $Q -
bk commit $Q -ywhatever
echo OK

echo $N Demonstrate saving data across csets ........................$NL
# XXX just need a '$end{$if($1){</CSET>}}' to be complete
bk changes -r..1.2 -vf \
   -d'$if(:CHANGESET:){${2=}$if($1){</CSET>\n}$else{${1=1}}<CSET rev=:I:>\n}$else{  <FILE path=$if(:DPN:=$2){SAME}$else{:DPN:${2=:DPN:}} rev=:I:>\n    :USER:@:HOST:\n  </FILE>\n}' > GOT
cat > WANT <<EOF
<CSET rev=1.0>
</CSET>
<CSET rev=1.1>
  <FILE path=BitKeeper/etc/collapsed rev=1.0>
    bk@bk_regression.bk
  </FILE>
  <FILE path=SAME rev=1.1>
    bk@bk_regression.bk
  </FILE>
  <FILE path=BitKeeper/etc/config rev=1.0>
    bk@bk_regression.bk
  </FILE>
  <FILE path=SAME rev=1.1>
    bk@bk_regression.bk
  </FILE>
  <FILE path=BitKeeper/etc/gone rev=1.0>
    bk@bk_regression.bk
  </FILE>
  <FILE path=SAME rev=1.1>
    bk@bk_regression.bk
  </FILE>
  <FILE path=BitKeeper/etc/ignore rev=1.0>
    bk@bk_regression.bk
  </FILE>
  <FILE path=SAME rev=1.1>
    bk@bk_regression.bk
  </FILE>
</CSET>
<CSET rev=1.2>
  <FILE path=f rev=1.0>
    adam@bk_regression.bk
  </FILE>
  <FILE path=SAME rev=1.1>
    adam@bk_regression.bk
  </FILE>
EOF
cmpfiles WANT GOT
echo OK

echo $N Show usernames like the default dspec .......................$NL
bk changes -v -r..1.6 \
  -d':INDENT::DPN:@:I:'\
'${1=:P:$if(:HT:){@:HT:}}'\
'$if(:CHANGESET: && !:COMPONENT:){'\
', DATE, $1${0=$1}}'\
'$else{$if($0!=$1){, $1}}'\
'$unless(:CHANGESET:){ +:LI: -:LD:}\n'\
'$unless(:REV: = 1.0 || :REV: = 1.1){$each(:C:){:INDENT:  (:C:)\n}}' > GOT || {
   exit 1
}
cat <<EOF >A
ChangeSet@1.4.1.1, DATE, jane@bk_regression.bk
  clone
  mommy@1.1, bk@bk_regression.bk +1 -0
  mommy@1.0, bk@bk_regression.bk +0 -0
ChangeSet@1.5, DATE, joe@bk_regression.bk
  project
  LS@1.1, bk@bk_regression.bk +7 -0
  LS@1.0, bk@bk_regression.bk +0 -0
ChangeSet@1.4, DATE, third@bk_regression.bk
  Third checkin
  f@1.3 +0 -0
    Third checkin
ChangeSet@1.3, DATE, second@bk_regression.bk
  Second checkin
  f@1.2 +0 -0
    Second checkin
ChangeSet@1.2, DATE, adam@bk_regression.bk
  Initial checkin
  f@1.1 +1 -0
  f@1.0 +0 -0
ChangeSet@1.1, DATE, bk@bk_regression.bk
  BitKeeper/etc/collapsed@1.1 +1 -0
  BitKeeper/etc/collapsed@1.0 +0 -0
  BitKeeper/etc/config@1.1 +11 -0
  BitKeeper/etc/config@1.0 +0 -0
  BitKeeper/etc/gone@1.1 +1 -0
  BitKeeper/etc/gone@1.0 +0 -0
  BitKeeper/etc/ignore@1.1 +1 -0
  BitKeeper/etc/ignore@1.0 +0 -0
ChangeSet@1.0, DATE, bk@bk_regression.bk
EOF
cat <<EOF >B
ChangeSet@1.4.1.1, DATE, joe@bk_regression.bk
  project
  LS@1.1, bk@bk_regression.bk +7 -0
  LS@1.0, bk@bk_regression.bk +0 -0
ChangeSet@1.5, DATE, jane@bk_regression.bk
  clone
  mommy@1.1, bk@bk_regression.bk +1 -0
  mommy@1.0, bk@bk_regression.bk +0 -0
ChangeSet@1.4, DATE, third@bk_regression.bk
  Third checkin
  f@1.3 +0 -0
    Third checkin
ChangeSet@1.3, DATE, second@bk_regression.bk
  Second checkin
  f@1.2 +0 -0
    Second checkin
ChangeSet@1.2, DATE, adam@bk_regression.bk
  Initial checkin
  f@1.1 +1 -0
  f@1.0 +0 -0
ChangeSet@1.1, DATE, bk@bk_regression.bk
  BitKeeper/etc/collapsed@1.1 +1 -0
  BitKeeper/etc/collapsed@1.0 +0 -0
  BitKeeper/etc/config@1.1 +11 -0
  BitKeeper/etc/config@1.0 +0 -0
  BitKeeper/etc/gone@1.1 +1 -0
  BitKeeper/etc/gone@1.0 +0 -0
  BitKeeper/etc/ignore@1.1 +1 -0
  BitKeeper/etc/ignore@1.0 +0 -0
ChangeSet@1.0, DATE, bk@bk_regression.bk
EOF
cmp -s A GOT || cmp -s B GOT || {
	echo failed on both graphs
	cat GOT
	exit 1
}
echo OK

echo $N Exclude src subdirectory ....................................$NL
bk changes -vr+ -x'src/*' -nd:GFILE: > GOT
bk changes -vr+ -nd:GFILE: | grep -v src/ > WANT
checkfiles GOT WANT
echo OK

echo $N Exclude man and html subdirectories .........................$NL
bk changes -vr+ -x'man/*' -x'html/*' -nd:GFILE: > GOT
bk changes -vr+ -nd:GFILE: | grep -v man/ | grep -v html/ > WANT
checkfiles GOT WANT
echo OK

echo $N Exclude all .c and .h files .................................$NL
bk changes -vr+ -x'*.[ch]' -nd:GFILE: > GOT
bk changes -vr+ -nd:GFILE: | egrep -v '.*\.[ch]$' > WANT
checkfiles GOT WANT
echo OK

echo $N Include html pages only .....................................$NL
bk changes -vr+ -i'*.html' -nd:GFILE: | grep -v ChangeSet > GOT
bk changes -vr+ -nd:GFILE: | egrep '.*\.html$' > WANT
checkfiles GOT WANT
echo OK

echo $N Exclude all .c and .h files and include man pages ...........$NL
bk changes -vr+ -x'*.[ch]' -i'*.1' -nd:GFILE: | grep -v ChangeSet > GOT
bk changes -vr+ -nd:GFILE: | egrep -v '.*\.[ch]$' | egrep '.*\.1$' > WANT
checkfiles GOT WANT
echo OK

echo $N Include all .c and .h files .................................$NL
bk changes -vr+ -i'*.[ch]' -nd:GFILE: | grep -v ChangeSet > GOT
bk changes -vr+ -nd:GFILE: | egrep '.*\.[ch]$' > WANT
checkfiles GOT WANT
echo OK

echo $N Include all .c and .h files but exclude src/foo.c ...........$NL
bk changes -vr+ -i'*.[ch]' -xsrc/foo.c -nd:GFILE: | grep -v ChangeSet > GOT
bk changes -vr+ -nd:GFILE: | egrep '.*\.[ch]$' | grep -v src/foo.c > WANT
checkfiles GOT WANT
echo OK

echo $N Test a list of urls, staring with a bad and ending good .....$NL
bk changes -r+ -ndx /sldfjsdf/some/bad/url "$HERE/clone" > OUT 2> ERR && {
	echo failed rc=0
	exit 1
}
echo OK

echo $N Test :GFILE: in a subdirectory ..............................$NL
cd html
bk changes -r+ -nd:GFILE: > OUT || exit 1
test "`cat OUT`" = ChangeSet || exit 1
bk changes -qr+ -nd:GFILE: ../../clone1 > OUT || exit 1
test "`cat OUT`" = ChangeSet || exit 1
bk changes -qL -nd:GFILE: ../../clone1 > OUT || exit 1
test "`cat OUT`" = ChangeSet || exit 1
bk changes -qR -nd:GFILE: ../../clone1 > OUT || exit 1
test "`head -1 OUT`" = ChangeSet || exit 1
echo OK

echo $N Check exit status for changes -L no/such/repo ...............$NL
bk clone $Q -r1.1 "$HERE/project" "$HERE/superset"
cd "$HERE/superset"
bk changes -qL /no/such/repo > OUT 2>&1 && {
	echo should not have exited 0
	exit 1
}
grep -q "illegal, nonexistent, or not package root" OUT || {
	echo Wrong message
	cat OUT
	exit 1
}
echo OK

echo $N Check exit status for changes -R no/such/repo ...............$NL
bk changes -qR /no/such/repo > OUT 2>&1 && {
	echo should not have exited 0
	exit 1
}
grep -q "illegal, nonexistent, or not package root" OUT || {
	echo Wrong message
	cat OUT
	exit 1
}
echo OK

echo $N Check exit status for changes -L repo/with/lock .............$NL
bk lock -wt "$HERE/project" > PORT &
(cd "$HERE/project"; bk lock -L;)
bk changes -qL "$HERE/project" > OUT 2>&1 && {
	echo should not have exited 0
	cat OUT
	bk _kill `cat PORT`
	exit 1
}
grep -q "Can't get read lock on the repository" OUT || {
	echo Wrong message
	cat OUT
	bk _kill `cat PORT`
	exit 1
}
# keep lock going for next one
echo OK

echo $N Check exit status for changes -R repo/with/lock .............$NL
bk changes -qR "$HERE/project" > OUT 2>&1 && {
	echo should not have exited 0
	cat OUT
	bk _kill `cat PORT`
	exit 1
}
grep -q "Can't get read lock on the repository" OUT || {
	echo Wrong message
	cat OUT
	bk _kill `cat PORT`
	exit 1
}
bk _kill `cat PORT`
echo OK

echo $N Check exit status for changes -L different/package ..........$NL
# give me a new root, work with old root'd parent
bk newroot -q
bk changes -qL > OUT 2>&1 && {
	echo should not have exited 0
	cat OUT
	exit 1
}
grep -q "You are trying to synchronize with an unrelated package" OUT || {
	echo Wrong message
	cat OUT
	exit 1
}
echo OK

echo $N Check exit status for changes -R different/package ..........$NL
bk changes -qR > OUT 2>&1 && {
	echo should not have exited 0
	cat OUT
	exit 1
}
grep -q "You are trying to synchronize with an unrelated package" OUT || {
	echo Wrong message
	cat OUT
	exit 1
}
echo OK
