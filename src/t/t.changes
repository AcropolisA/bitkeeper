# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.


# Copyright (c) 2002 lm
# %K%

echo $N Create initial repository ...................................$NL
commercial project
echo foo > f
BK_USER=adam bk delta $Q -i -y'Initial checkin' f
BK_USER=adam bk commit $Q -y'Initial checkin' || exit 1
bk edit $Q f
BK_USER=second bk delta $Q -y'Second checkin' f
BK_USER=second bk commit $Q -Ssecond -y'Second checkin' || exit 1
bk edit $Q f
BK_USER=third bk delta $Q -y'Third checkin' f
BK_USER=third bk commit $Q -Sthird -y'Third checkin' || exit 1
echo OK

echo $N Check that -/search/ works ..................................$NL
bk changes -/Second/ > XXX
grep -q ChangeSet@1.3 XXX || {
	echo failed to match the 1.3 changeset
	cat XXX
	exit 1
}
for r in 1.1 1.2 1.4
do	
	grep -q ChangeSet@$r XXX && {
		echo matched the $r changeset
		cat XXX
		exit 1
	}
done
bk changes -/second/i > YYY
cmp -s XXX YYY || {
	echo Failed to match when ignoring case
	exit 1
}
echo OK

echo $N Check that dspecs work ......................................$NL
cat > WANT <<EOF
1.4
1.3
1.2
1.1
1.0
EOF
bk changes -nd:I: > XXX
cmp -s XXX WANT || {
	echo backward dpsec failed
	cat XXX
	exit 1
}

cat > WANT <<EOF
1.0
1.1
1.2
1.3
1.4
EOF
bk changes -fnd:I: > XXX
cmp -s XXX WANT || {
	echo forward dpsec failed
	cat XXX
	exit 1
}
echo OK

echo $N Check that keys work . ......................................$NL
bk prs -hr1.0.. -nd:KEY: ChangeSet | sort > WANT
bk changes -k | sort > GOT
cmp -s WANT GOT || {
	echo wrong keys
	diff WANT GOT
	exit 1
}
echo OK

echo $N Check that user restrictions work ...........................$NL
bk changes -usecond > GOT
bk changes -rsecond > WANT
cmp -s WANT GOT || {
	echo wrong answer
	diff WANT GOT
	exit 1
}
bk changes -Usecond > GOT
bk changes -r1.4,1.2,1.1,1.0 > WANT
cmp -s WANT GOT || {
	echo wrong answer
	diff WANT GOT
	exit 1
}
echo OK

echo $N Check tag listing ...........................................$NL
bk changes -t > GOT
bk changes -rthird > WANT
bk changes -rsecond >> WANT
cmp -s WANT GOT || {
	echo wrong answer
	diff WANT GOT
	exit 1
}
echo OK

echo $N Check remote/local listings .................................$NL
cd $HERE
bk clone $Q project clone
cd project
ls > LS
bk new $Q LS
BK_USER=joe bk commit $Q -yproject
cd $HERE/clone
echo hi mom > mommy
bk new $Q mommy
BK_USER=jane bk commit $Q -yclone
bk changes -L -nd':I: :P: :C:' > GOT
echo 1.5 jane clone > WANT
cmp -s WANT GOT || {
	echo local only listing failed, got 
	cat GOT
	exit 1
}
bk changes -R -nd':I: :P: :C:' > GOT
echo 1.5 joe project > WANT
cmp -s WANT GOT || {
	echo remote only listing failed, got 
	cat GOT
	exit 1
}
echo OK

echo $N Check remote dspec listing ..................................$NL
cd $HERE/clone
bk changes -nd':I: :P: :C:' > WANT
cd $HERE
bk changes -nd':I: :P: :C:' $HERE/clone > GOT
cmp -s clone/WANT GOT || {
	echo wrong answer
	diff WANT GOT
	exit 1
}
echo OK

echo $N Check remote search combined with dspec .....................$NL
# The /dev/null is because we exit so fast that the bkd can't update the
# logs, at least that is my theory.
cd $HERE/clone
bk changes -/Second/ -nd':I: :P: :C:' ../project > GOT 2>/dev/null
echo 1.3 second Second checkin > WANT
cmp -s WANT GOT || {
	echo remote only listing failed, got 
	cat GOT
	exit 1
}
echo OK

echo $N Check remote key listing ....................................$NL
bk prs -hr1.0.. -nd:KEY: ChangeSet | sort > WANT
cd $HERE
bk changes -k $HERE/clone | sort > GOT
cmp -s clone/WANT GOT || {
	echo wrong keys
	diff WANT GOT
	exit 1
}
echo OK

echo $N Check remote verbose listing ................................$NL
cd $HERE/clone
bk changes -vr+ | bk undos > WANT
cd $HERE
bk changes -vr+ $HERE/clone > GOT
cmp -s clone/WANT GOT || {
	echo wrong answer
	diff clone/WANT GOT
	exit 1
}
echo OK

echo $N Demonstrate out of order changesets .........................$NL
no_logging p
touch foo
bk new $Q foo
# The long string needed to overcome fudges.
# 1 more than need for that case where the seconds wrap during the test
bk mv foo bar
bk mv bar b
bk mv b foo
bk mv foo fee
bk commit $Q -yy
files=`bk changes -r+ -v -d:DPN:`
if [ $files != "ChangeSetfeefoobbarfoofoo" ]
then	echo 'failed (bug 2002-04-19-001)'
else	echo 'bug 2002-04-19-001 passing! fix test.'
	exit 1
fi
cd $HERE
rm -rf p

echo $N Demonstrate the other way they can be out of order ..........$NL
no_logging p
touch foo
bk new $Q foo
cd $HERE
bk clone $Q p c2
cd c2
touch bar
bk new $Q bar
bk commit $Q -yq
cd $HERE/p
bk commit $Q -ya
cd $HERE/c2
bk pull $Q || exit 1
files=`bk changes -r1.1.1.1,1.2 -v -d:DPN:`
if [ $files != "ChangeSetfoofooChangeSetbarbar" ]
then	echo 'failed (bug 2002-04-19-001)'
else	echo 'bug 2002-04-19-001 passing! fix test.'
	exit 1
fi
cd $HERE
rm -rf p

echo $N Does combining restrictions work ............................$NL
cd project
revs=`bk changes -c-1Y -ujoe -d:REV:`
test X$revs != X1.5 && {
	echo failed
	exit 1
}
echo OK

echo $N Verify changes -L works with tags ...........................$NL
cd $HERE/clone
bk tag $Q -r1.2 bar
bk changes -L -nd':REV: :COMMENTS: :SYMBOL:' > chgs
cat <<EOF > expect
1.2  bar
1.5 C clone
 
EOF
bk diff -u expect chgs || {
	echo changes returned wrong data
	exit 1
}
echo OK

echo $N Change changes on a remote repository .......................$NL
key=`bk prs -r+ -hnd:KEY: ChangeSet`
cd $HERE
key2=`bk changes -r+ -nd:KEY: clone`
if [ "$key" != "$key2" ]
then	echo Remote changes failed
	echo $key vs $key2
	exit 1
fi
echo OK

echo $N Demonstrate how pull -nl works ..............................$NL
cd $HERE
bk clone $Q project merge
cd merge
bk pull $Q ../clone
cd ../project
bk pull $Q ../clone
# XXX strange -q suppress all output
bk pull -n ../merge >junk 2> out
grep -q "1.6" out || {
	echo bk pull -n had wrong output:
	cat out
	exit 1
}
# XXX but -q "works" here
bk pull -nl $Q ../merge 2> out
grep -q "1.6" out || {
	echo bk pull -nl had wrong output:
	cat out
	exit 1
}
echo OK

echo $N Check superset with no changes...............................$NL
cd $HERE
bk clone $Q project superset
cd superset
bk superset > ../GOT
test $? -ne 0 && {
	echo superset with no changes should exit 0
	exit 1
}
GOT=`cat ../GOT`
test "X$GOT" != "X" && {
	echo superset with no changes should be silent
	exit 1
}
echo OK

echo $N Check superset with changes..................................$NL
cd $HERE/superset
echo FOO > FOO
bk new $Q FOO
BK_USER=joe bk commit $Q -yproject
echo BAR > BAR
bk superset > ../GOT
test $? -ne 1 && {
	echo superset with changes should exit 1
	exit 1
}
grep FOO ../GOT >/dev/null || {
	echo superset missed a changeset
	exit 1
}
grep BAR ../GOT >/dev/null || {
	echo superset missed an extra file
	exit 1
}
echo OK
