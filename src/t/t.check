# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.


# Copyright (c) 2000 Larry McVoy
# %K%

echo $N Create initial repository ...................................$NL
commercial project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if bk _test ! -f SCCS/s.ChangeSet; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
echo OK

echo $N Create some data ............................................$NL
for dir in d1 d2 d3 d1/sub1 d2/sub1 d3/sub d3/sub2
do	mkdir $dir
	for file in a b c d 
	do	echo "I am $dir/$file: %I%" > $dir/$file
	done
done
echo bam-bam > bam
bk new $Q -b bam
bk sfiles -x | bk ci $Q -i -
if bk _test ! -f d3/sub2/SCCS/s.a; then echo failed to create files; exit 1; fi
echo OK

echo $N Commit the data .............................................$NL
bk commit $S -yCset
if [ `bk sfiles -pC | wc -l` -ne 0 ];
then	echo failed to commit all files; exit 1; fi
echo OK

echo $N Create another changeset ....................................$NL
bk -r edit $Q
bk sfiles -g | grep -v ChangeSet | grep -v BitKeeper | while read x
do	echo more data >> $x
done
bk -r ci $Q -ycset2
bk commit $S -yCset2
if [ `bk sfiles -pC | wc -l` -ne 0 ];
then	echo failed to commit all files; exit 1; fi
echo OK

echo $N Create another changeset ....................................$NL
bk -r edit $Q
bk sfiles -g | grep -v ChangeSet | grep -v BitKeeper | while read x
do	echo more data >> $x
done
bk -r ci $Q -ycset3
bk commit $S -yCset3
if [ `bk sfiles -pC | wc -l` -ne 0 ];
then	echo failed to commit all files; exit 1; fi
echo OK

echo $N Create another changeset with two deltas ....................$NL
bk -r edit $Q
bk sfiles -g | grep -v ChangeSet | grep -v BitKeeper | while read x
do	echo more data >> $x
done
bk -r ci $Q -ycset4
bk -r edit $Q
bk sfiles -g | grep -v ChangeSet | grep -v BitKeeper | while read x
do	echo more data >> $x
done
bk -r ci $Q -ycset4
bk commit $S -yCset4
if [ `bk sfiles -pC | wc -l` -ne 0 ];
then	echo failed to commit all files; exit 1; fi
echo OK

echo $N Make sure that it checks clean ..............................$NL
cd "`bk root`"
rm -f BitKeeper/log/checked
bk -r check -a > OUT 2>&1 || {
	echo failed to exit 0
	cat OUT
	exit 1
}
echo OK

echo $N Make sure that check -a does not add a checked timestamp ....$NL
test -f BitKeeper/log/checked && exit 1
echo OK

echo $N Make sure that check -ac does add a checked timestamp .......$NL
bk -r check -ac
test -f BitKeeper/log/checked || exit 1
echo OK

echo $N Make sure that check -a adds an NFILES ......................$NL
rm BitKeeper/log/NFILES
bk -r check -a
test -f BitKeeper/log/NFILES || exit 1
echo OK

echo $N Make sure that check -a corrects bad NFILES count ...........$NL
WANT=`cat BitKeeper/log/NFILES`
echo 10000 > BitKeeper/log/NFILES
bk -r check -a
GOT=`cat BitKeeper/log/NFILES`
test "$WANT" = "$GOT" || {
	echo failed to update NFILES
	echo WANT=$WANT
	echo GOT=$GOT
	exit 1
}
echo OK

cp -rp "$HERE/project" "$HERE/clean"
echo $N Make sure that it complains if a file is missing, -a case ...$NL
bk _mv d1/sub1/SCCS/s.a d1/sub1/SCCS/junk.a
bk -r check -a > OUT 2>&1
if [ $? -eq 0 ]; then echo failed to exit non-zero; cat OUT; exit 1; fi
if [ ! -s OUT ]; then echo failed; cat OUT; exit 1; fi
echo OK

echo $N Make sure that it complains if a file is missing, - case ....$NL
echo d1/sub1/a | bk check - > OUT 2>&1
if [ $? -eq 0 ]; then echo failed to exit non-zero; cat OUT; exit 1; fi
if [ ! -s OUT ]; then echo failed; cat OUT; exit 1; fi
echo OK

echo $N Make sure that it is happy when we put it back ..............$NL
bk _mv d1/sub1/SCCS/junk.a d1/sub1/SCCS/s.a
bk -r check -a > OUT 2>&1 || {
	exit failed to exit cleanly
	cat OUT
	exit 1
}
echo OK

echo $N Make sure it fixes locked files w/o a gfile with -f .........$NL
bk get -eg $Q BitKeeper/etc/config
bk -r check -af > OUT 2>&1 || {
	echo should have exited cleanly
	exit 1
}
bk _test -f d1/sub1/SCCS/p.a && {
	echo failed to unlock the file
	exit 1
}
echo OK

echo $N Make sure it complains about locked files w/ RO gfile........$NL
bk edit $Q d1/sub1/a
echo "new stuff" > d1/sub1/a
chmod 444 d1/sub1/a
bk -r check -a > OUT 2>&1 && {
	echo should have exited with a failure
	exit 1
}
grep -q 'is locked but not writable' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK

echo $N Make sure unedit will fix the above problem .................$NL
bk unedit d1/sub1/a
bk -r check -a > OUT 2>&1 || {
	echo should have exited cleanly
	exit 1
}
echo OK

echo $N Make sure it fixes locked files w/ unchanged RO gfile........$NL
bk edit $Q d1/sub1/a
bk get $Q -r+ -p d1/sub1/a > d1/sub1/a
chmod 444 d1/sub1/a
bk -r check -a > OUT 2>&1 || {
	echo should have exited with ok status
	exit 1
}
echo OK

echo $N Make sure it complains unlocked files with rw gfile .........$NL
bk get $Q d1/sub1/a
chmod +w d1/sub1/a
bk -r check -a > OUT 2>&1
bk _test -f d1/sub1/SCCS/p.a && {
	echo should not have created lock file
	cat OUT
	exit 1
}
test -w d1/sub1/a || {
	echo should not have unedited file
	cat OUT
	exit 1
}
grep -q 'writable but not locked.' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK

echo $N Make sure it fixes unlocked files with rw gfile with -f .....$NL
bk -r check -af > OUT 2>&1
bk _test -f d1/sub1/SCCS/p.a || {
	echo should have created lock file
	cat OUT
	exit 1
}
test -w d1/sub1/a || {
	echo should not have unedited file
	cat OUT
	exit 1
}
echo OK

echo $N Make sure it autofixes unlocked files with rw gfile .........$NL
bk edit $Q BitKeeper/etc/config
echo "autofix:yes" >> BitKeeper/etc/config
bk _rm d1/sub1/SCCS/p.a
bk -r check -a > OUT 2>&1
bk _test -f d1/sub1/SCCS/p.a || {
	echo should have created lock file
	cat OUT
	exit 1
}
test -w d1/sub1/a || {
	echo should not have unedited file
	cat OUT
	exit 1
}
echo OK

echo $N Make sure it removes p.files when no gfile ..................$NL
rm d1/sub1/a
bk _test -f d1/sub1/SCCS/p.a || {
	echo whoops, where did the p.file go
	exit 1
}
bk -r check -a > OUT 2>&1
bk _test -f d1/sub1/SCCS/p.a && {
	echo should have removed d1/sub1/SCCS/p.a
	exit 1
}
echo OK

echo $N No remove w/o gfile when -i/-x ..............................$NL
bk edit $Q -x+ d1/sub1/a
rm d1/sub1/a
bk -r check -a > OUT 2>&1 && {
	echo should have failed
	exit 1
}
bk _test -f d1/sub1/SCCS/p.a || {
	echo should not have removed d1/sub1/SCCS/p.a
	cat OUT
	exit 1
}
grep -q 'd1/sub1/a has merge.include.exclude but no gfile.' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK

echo $N Make sure it complains about file/dir conflicts .............$NL
bk unedit $Q d1/sub1/a
mkdir d1/sub1/a
bk -r check -a > OUT 2>&1 && {
	echo should have exited with a failure
	cat OUT
	exit 1
}
grep -q 'File/directory conflict: d1/sub1/a' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
rmdir d1/sub1/a
echo OK

echo $N Make sure it complains about copied files ...................$NL
cd "$HERE"
commercial other
echo hi > foo
bk commit $Q -yFOO
bk new $Q foo || exit 1
bk commit $Q -yFOO
cd "$HERE"/project
bk _cp ../other/SCCS/s.foo SCCS/s.foo
bk -r check -a 2>ERR && fail -f ERR should fail
grep -q \
"check: File foo doesn't have any data that matches the local ChangeSet file" \
	ERR || fail -f ERR
bk admin -D foo
bk sfiles -P > /dev/null
bk -r check -a || fail
echo OK

echo $N Make sure commit refuses to commit out of sync files ........$NL
cd "$HERE/clean/d3/sub2"
for i in a b c
do	bk stripdel -qCr+ $i
done
bk stripdel -qCr+ a
for i in a b c
do	bk edit $Q $i
	echo error >> $i
	bk delta $Q -y'out of sync' $i || exit 1
done
bk commit $Q -y'out of sync' > OUT 2>&1 && {
	echo should have failed the commit
	cat OUT
	exit 1
}
echo OK

echo $N Make sure check detects checksum problems ...................$NL
cd "$HERE/project"
echo "foobar" > ff
bk new $Q ff
bk edit $Q ff
bk delta -yfoobar $Q ff
bk admin -Znone ff || exit 1
bk _mv SCCS/s.ff ff.tmp
sed 's/foobar/foobaz/' < ff.tmp > ff.tmp2
bk _mv ff.tmp2 SCCS/s.ff
rm -f ff.tmp
bk check -c ff 2> /dev/null && {
	echo check should have failed
	exit 1
}
bk _rm SCCS/s.ff
echo OK

echo $N Make sure check complains is cset marks are missing .........$NL
cd "$HERE"
bk clone $Q project bad || exit 1
cd bad
bk admin -FSCCS d1/a  || exit 1
bk _rm d1/SCCS/d.a || fail
bk -r check -a >OUT 2>ERRS && {
	echo check should have failed
	exit 1
}
grep -q 'has pending deltas but no d.file' ERRS || {
	echo bad error message
	cat ERRS
	exit 1
}
bk _test -f d1/SCCS/d.a || fail
echo OK

echo $N Show that check will repair dfile errors ....................$NL
bk _rm d1/SCCS/d.a || fail
bk _touch d1/SCCS/d.b || fail
bk _rm BitKeeper/etc/SCCS/x.dfile || fail
# no error because no marker
bk -r check -a || fail
bk _test -f d1/SCCS/d.a || fail		# add missing
bk _test -f d1/SCCS/d.b && fail		# remove extra
bk _test -f BitKeeper/etc/SCCS/x.dfile || fail	# restore marker
cd "$HERE"
rm -rf bad
echo OK

echo $N Make sure check knows about .bk_skip ........................$NL
cd "$HERE"
bk clone $Q project clone || exit 1
cd clone
# this one should print a warning
touch d1/sub1/.bk_skip
bk -r check -a >OUT 2>ERRS && exit 1
rm d1/sub1/.bk_skip
[ -s ERRS ] || {
	echo ".bk_skip didn't cause a warning; output was"
	cat OUT
	echo "error output was empty!"
	exit 1
}
grep "^Missing" ERRS > /dev/null || {
	echo "Wrong errors; output was"
	cat OUT
	echo "error output was"
	cat ERRS
	exit 1
}
echo OK

test -d $TESTDATA/cset-gzipped && {
echo $N Make sure check works with compressed ChangeSet files........$NL
cd "$HERE"
BK_CONFIG="license:$BKL_PRO;licsign1:$BKL_P1$BKL_P2$BKL_P3" \
bk clone $Q $TESTDATA/cset-gzipped p || {
	echo "failed"
	exit 1
}
cd p
BK_CONFIG="license:$BKL_PRO;licsign1:$BKL_P1$BKL_P2$BKL_P3" \
bk -r check -a || {
	echo "failed"
	exit 1
}
echo OK
}
true

echo $N Check without a ChangeSet sfile should give an error ........$NL
cd "$HERE"
rm -rf clone
bk clone $Q project clone || exit 1
cd clone
bk _rm SCCS/s.ChangeSet
bk -r check -a >OUT 2>ERRS
[ -s ERRS ] || {
	echo "check without a ChangeSet sfile didn't cause an error"
	cat OUT
	exit 1
}
# restore repo
bk _cp ../project/SCCS/s.ChangeSet SCCS/s.ChangeSet
echo OK

echo $N Make sure .bk_skip and SCCS/.bk_skip works ..................$NL
# this one should not cause a warning, but the check will complain about
# missing files
cd "$HERE/clone"
bk _touch d1/sub1/SCCS/.bk_skip
bk -r check -a >OUT 2>ERRS
grep -v 'Missing file' ERRS > E2
test -s E2 && {
	echo "Unexpected error output from check; output was"
	cat OUT
	echo "error output was"
	cat ERRS
	exit 1
}
echo OK

echo $N bk check should detect copied sfile .........................$NL
cd "$HERE"
commercial proj2
echo "hi" > foo
bk new $Q foo
bk commit $Q -yfoo
bk _cp SCCS/s.foo SCCS/s.foo2
bk -r check -afc 2> "$HERE/out"
grep -q "Is one of these files copied?" "$HERE/out" || { echo failed; exit 1; }
echo OK

echo $N bk check with partial_check should notice path conflicts ....$NL
commercial proj3
bk edit $Q BitKeeper/etc/config
(grep -v partial_check BitKeeper/etc/config; echo partial_check:yes) > c
cat c > BitKeeper/etc/config
test Xyes = X"`bk config partial_check`" || exit 2
echo hi > foo
bk new $Q -ycomment foo || exit 1
bk commit $Q -ycomment || exit 1
mkdir foo
echo problem > foo/bar
bk new $Q -ycomment2 foo/bar || exit 1
bk commit $Q -ycomment2 2> ERR && {
	echo commit should have failed
	exit 1
}
grep -q "File/directory conflict: foo" ERR || {
	echo wrong error message
	cat ERR
	exit 1
}
echo OK

echo $N bk check with errors should not update checked file .........$NL
cd "$HERE"
commercial proj4
bk edit $Q BitKeeper/etc/config
echo partial_check:yes! >> BitKeeper/etc/config
echo hi > foo
bk new $Q -ycomment foo || exit 1
bk commit $Q -ycomment || exit 1
perl -le 'print scalar(time)' > BitKeeper/log/checked
echo 1 > WANT
cp WANT BitKeeper/log/checked
bk admin -pbusted foo
bk -r check -ac 2>ERR && {
	echo check should have failed
	cat ERR
	exit 1
}
cmpfiles WANT BitKeeper/log/checked
echo OK

echo $N Ancient check file should be needs check ....................$NL
echo 1 > BitKeeper/log/checked
bk needscheck || {
	echo failed, WTF
	cat BitKeeper/log/checked
	exit 1
}
echo OK

echo $N No check file should be needs check .........................$NL
rm BitKeeper/log/checked
bk needscheck || {
	echo failed, WTF
	exit 1
}
echo OK

echo $N Up to date check file should be no check ....................$NL
perl -le 'print scalar(time)' > BitKeeper/log/checked
bk needscheck && {
	echo failed, WTF
	cat BitKeeper/log/checked
	exit 1
}
echo OK

echo $N Check in a subdir because I forgot that one .................$NL
mkdir subdir
cd subdir
bk needscheck && {
	echo failed, WTF
	exit 1
}
rm ../BitKeeper/log/checked
bk needscheck || {
	echo failed, WTF2
	exit 1
}
echo OK

echo $N bk check with no errors should update checked file ..........$NL
cd "$HERE/proj4"
perl -le 'print scalar(time)' > BitKeeper/log/checked
echo 1 > WANT
cp WANT BitKeeper/log/checked
bk admin -pfoo foo
bk -r check -ac 2>ERR || {
	echo check should not have failed
	cat ERR
	exit 1
}
cmp -s WANT BitKeeper/log/checked && {
	echo should have updated the file
	cat GOT
	exit 1
}
echo OK

echo $N Try our pre-outgoing trigger that auto checks ...............$NL
cd "$HERE/proj4"
test -d  BitKeeper/triggers || mkdir  BitKeeper/triggers
cat > BitKeeper/triggers/pre-outgoing.check <<EOF
#!/bin/sh

# only if we need a check
bk needscheck || exit 0

# and not when another one of these triggers are running
test -f BitKeeper/tmp/autocheck.lock && exit 0

# and not when we can't tell ourselves that another is running
test -w BitKeeper/tmp || exit 0

touch BitKeeper/tmp/autocheck.lock

# Run full check in background
bk sh <<SUBEOF >&- 2>&- &
# Uncomment if you want to prove to yourself the locking works
# sleep 1
bk -r check -ac > /dev/null 2>&1
rm -f BitKeeper/tmp/autocheck.lock
SUBEOF

# now return to user and run in parallel with clone
exit 0
EOF
chmod +x BitKeeper/triggers/pre-outgoing.check
rm BitKeeper/log/checked
cd ..
bk clone $Q proj4 proj4.clone
cd proj4
while test -f BitKeeper/tmp/autocheck.lock
do	# echo waiting
	bk _usleep 100000
done
bk needscheck && {
	echo failed to run check
	exit 1
}
echo OK

echo $N Check should clean up any extra dfiles ......................$NL
cd "$HERE"/proj2
bk _rm -f SCCS/s.foo2	# fixup
bk _touch SCCS/d.foo
bk -r check -a || exit 1
bk _test -f SCCS/d.foo && {
	echo should have deleted dfile
	exit 1
}
echo OK

echo $N Test repocheck in a standalone and nested repo ..............$NL
mkdir src
cd src
bk repocheck -q || fail
BK_NOTTY= bk repocheck 2> ERR || fail -f ERR
grep -q '100%.*OK$' ERR || fail -f ERR
cd "$HERE"
nested nest
mkdir src
cd src
bk repocheck -q || fail
BK_NOTTY= bk repocheck > OUT 2> ERR || fail -f ERR
# stderr has the check output
# === Checking /build/.regression lm/sandbox/nest ===
# gcc                                100% |==============================| OK
# gdb                                100% |==============================| OK
# .                                  100% |==============================| OK
grep -q 'gcc.*100%.*OK$' ERR || fail -f ERR
# Bork the repo and see that it says it is borked
rm -fr ../gcc
bk repocheck -q 2> ERR && fail -f ERR
grep -q "check: Not populated: gcc" ERR || fail -f ERR
echo OK

echo $N Test check fixes missing directories in remapped repo .......$NL
cd "$HERE"
bk clone $Q --hide-sccs-dirs project proj-remapped
cd proj-remapped
bk -r clean
rmdir d1/sub1
bk -r check -acf || fail
echo OK

echo $N Try to create a cset with a path conflict ...................$NL
cd ../project
bk mv d2/a foo2 || fail
bk mv d2/b d2/a || fail
# it would be nice if this failed...
echo 'd2/SCCS/s.a|+' | bk commit $Q -ybad - || fail

# but this does
bk check 2>ERR && fail -f ERR should fail
grep -v '|d2/.|' ERR > ERR2
cat <<EOF > WANT
check: two files are committed at the same pathname. (d2/a)
rootkeys:
EOF
cmpfiles ERR2 WANT
echo OK

echo $N Setup what looks like a path conflict but is a gone delta ...$NL
bk edit $Q BitKeeper/etc/gone
bk log -r+ -nd:KEY: d2/a >> BitKeeper/etc/gone
bk stripdel $Q -Cr+ d2/a
bk stripdel $Q -r+ foo2
bk names d2/a foo2
bk check || fail
bk unedit BitKeeper/etc/gone
bk undo $Q -fsr+ || fail
echo OK

echo $N Setup what looks like missing merge but all are gone ........$NL
# take a repo with a 'foo', clone, rm and gone foo in both, pull
cd ../other
bk clone $Q . ../other2
bk rm foo
bk commit $Q -yno-foo
bk _rm -fr BitKeeper/deleted
bk -r check -ag | bk gone $Q -
bk commit $Q -yno-foo
cd ../other2
bk rm foo
bk commit $Q -yno-foo
bk _rm -fr BitKeeper/deleted
bk -r check -ag | bk gone $Q -
bk commit $Q -yno-foo
bk pull $Q || fail
echo OK

echo $N Setup a path conflict in resolve ............................$NL
cd ..
bk clone $Q project copy || fail
cd copy
bk mv d2/b foobar || fail		# commit this move
bk commit $Q -ymv1 || fail
bk mv foobar something_else || fail	# leave this move pending
cd ../project
echo hi > foobar
bk new $Q foobar || fail		# create a new foobar
bk commit $Q -ynew || fail
cd ../copy
bk pull $Q 2>ERR && fail -f ERR should fail
grep -q "check: two files are committed at the same pathname" ERR || fail
echo OK

echo $N See that an unmarked delta gets marked ......................$NL
cd "$HERE"
commercial nomark
touch foo
bk new $Q foo
bk _cp SCCS/s.foo no-mark
bk commit $Q -yfoo
bk _cp no-mark SCCS/s.foo
# Okay, what's check say?
bk -r check -ac 2> ERR || fail -f ERR
cat << EOF > WANT
foo: adding and/or removing missing csetmarks
EOF
cmpfiles WANT ERR
# All fixed
bk -r check -acf || fail
echo OK

# sgi doesn't do the waits correctly
test "`bk gethost -r`" != "sgi.bitmover.com" && {

echo $N Setup check/clone race ......................................$NL
cd "$HERE"
bk clone $Q --sccsdirs project project.noremap
cd project.noremap
mkdir d4
bk mv d3/sub/a d4/anew || fail
bk commit $Q -ymv || fail

bk repocheck -q &
CPID1=$!
bk clone $Q --no-hardlinks . ../junk &
CPID2=$!
bk repocheck -q &
CPID3=$!
bk clone $Q --no-hardlinks . ../junk2 &
CPID4=$!
wait $CPID1 || fail
wait $CPID2 || fail
wait $CPID3 || fail
wait $CPID4 || fail
echo OK

}

true
