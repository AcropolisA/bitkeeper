# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Copyright (c) 1999 Larry McVoy
# %K%

commercial whatever
echo some text >X
echo other text >Y
bk delta $Q -i X Y
echo $N Remove all unmodified files .................................$NL
bk get $Q X
bk get $Q -e Y
bk clean
if [ -f X ] || [ -f Y ]; then	echo failed; exit 1; fi
echo OK
echo $N Remove only files on command line ...........................$NL
bk get $Q X Y
bk clean X
if [ -f X ] || [ ! -f Y ]; then	echo failed; exit 1; fi
echo OK
echo $N unedit should remove even modified files ....................$NL
bk get $Q -e X
echo more text >>X
bk unedit X
if [ -f X ]; then echo failed; exit 1; fi
if bk _test -f SCCS/p.X; then echo failed - still locked; exit 1; fi
echo OK
echo $N unedit should not autoexpand file names .....................$NL
for i in R S T U V
do	ls > $i
	bk new $Q $i
    	bk edit $Q $i
done
bk unedit 2>/dev/null
for i in R S T U V
do	if bk _test ! -f SCCS/p.$i -o ! -w $i
	then	echo failed on $i; exit 1
	fi
done
echo OK
echo $N unlock should not autoexpand file names .....................$NL
bk unlock 2>/dev/null
for i in R S T U V
do	if bk _test ! -f SCCS/p.$i -o ! -w $i
	then	echo failed on $i; exit 1
	fi
done
echo OK
echo $N clean should autoexpand file names ..........................$NL
bk clean 2>/dev/null
for i in R S T U V
do	if bk _test -f SCCS/p.$i -o -w $i
	then	echo failed on $i; exit 1
	fi
done
echo OK
echo $N unlock should fail if gfile is there ........................$NL
bk get $Q -e X
echo more text >>X
bk unlock X 2>/dev/null
if [ $? != 1 ]; then echo failed to exit 1; exit 1; fi
if bk _test ! -f SCCS/p.X; then echo failed to leave p.file; exit 1; fi
echo OK
echo $N unlock -x should work .......................................$NL
touch x.X z.X b.X
bk _mv x.X SCCS/x.X
bk _mv z.X SCCS/z.X
bk _mv b.X SCCS/b.X
bk unlock -x X  2> /dev/null
if [ ! -f X ]; then echo failed; exit 1; fi
if bk _test -f SCCS/x.X; then echo failed - left x; exit 1; fi
if bk _test ! -f SCCS/b.X -o ! -f SCCS/z.X -o ! -f SCCS/p.X
then echo failed - deleted other lock files; ls SCCS/?.X; exit 1; fi
echo OK
echo $N unlock -z should work .......................................$NL
touch x.X z.X b.X
bk _mv x.X SCCS/x.X
bk _mv z.X SCCS/z.X
bk _mv b.X SCCS/b.X
bk unlock -z X 2>/dev/null
if [ ! -f X ]; then echo failed; exit 1; fi
if bk _test -f SCCS/z.X; then echo failed - left z; exit 1; fi
if bk _test ! -f SCCS/b.X -o ! -f SCCS/x.X -o ! -f SCCS/p.X
then echo failed - deleted other lock files; exit 1; fi
echo OK
echo $N unlock -zx should work ......................................$NL
bk _touch SCCS/x.X SCCS/z.X
bk unlock -xz X 2>/dev/null
if [ ! -f X ]; then echo failed; exit 1; fi
if bk _test -f SCCS/z.X -o -f SCCS/x.X
then echo failed - left lock files; exit 1; fi
echo OK
echo $N unlock -fpzx should work ....................................$NL
bk _touch SCCS/x.X SCCS/z.X
bk unlock -fpxz X 2>/dev/null
if [ ! -f X ]; then echo failed; exit 1; fi
if bk _test ! -f SCCS/s.X; then echo failed; exit 1; fi
if bk _test -f SCCS/z.X -o -f SCCS/x.X -o -f SCCS/p.X
then echo failed - left lock files; exit 1; fi
echo OK
bk _rm -f CMP1 CMP2 X Y SCCS/s.X SCCS/s.Y
# Test internal compare for RCS, SCCS, EXPAND1, nonewline, binary, longline
# and hash data.  Uses clean to test diffs (in some cases uses sfiles -c
fail=no
echo $N No change to a regular file .................................$NL
echo reg > reg
bk ci $Q -i reg
bk get $Q -e reg
bk clean $Q reg
if [ $? -ne 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N No change to a no newline ending file .......................$NL
echo $N nonl$NL > nonl
bk ci $Q -i nonl
bk get $Q -e nonl
bk clean $Q nonl
if [ $? -ne 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N No change to a longline file ................................$NL
str=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
str=${str}${str}${str}${str}${str}${str}${str}${str}${str}${str}${str}${str}
str=${str}${str}${str}${str}${str}${str}${str}${str}${str}${str}${str}${str}
echo $str > long
bk ci $Q -i long
bk get $Q -e long
bk clean $Q long
if [ $? -ne 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N No change to a hash file ....................................$NL
echo hash first > hash
bk ci $Q -i -h hash
bk get $Q -e hash
echo hash second > hash
bk delta $Q -yhash hash
bk get $Q -e hash
bk clean $Q hash
if [ $? -ne 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N No change to SCCS expand file .. check sfiles -c ............$NL
echo %""K% > sccsexp
bk ci $Q -i sccsexp
bk get $Q sccsexp
mv sccsexp sccsexp.expn
bk get $Q -e sccsexp
rm -f sccsexp
mv sccsexp.expn sccsexp
chmod +w sccsexp
result=`bk sfiles -c sccsexp | wc -l`
if [ $result -ne 1 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N No change to SCCS expand file .. check clean ................$NL
bk clean sccsexp 2>ERR && exit 1
echo OK
echo $N No change to RCS expand file ....check sfiles -c ............$NL
echo '$Revision$' > rcsexp
bk ci $Q -i rcsexp
bk admin -fRCS rcsexp
bk get $Q rcsexp
mv rcsexp rcsexp.expn
bk get $Q -e rcsexp
rm -f rcsexp
mv rcsexp.expn rcsexp
chmod +w rcsexp
result=`bk sfiles -c rcsexp | wc -l`
if [ $result -ne 1 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N No change to RCS expand file ....check clean ................$NL
bk unedit rcsexp
bk edit $Q rcsexp
bk clean $Q rcsexp
if [ $? -ne 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N No change to expand first keyword only .. check sfiles -c ...$NL
echo %""@% > exp1 
echo %""K% >> exp1 
bk ci $Q -i exp1
bk get $Q exp1
mv exp1 exp1.expn
bk get $Q -e exp1
rm -f exp1
mv exp1.expn exp1
chmod +w exp1
result=`bk sfiles -c exp1 | wc -l`
if [ $result -ne 1 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N No change to expand first keyword only .. check clean .......$NL
bk clean $Q exp1 && exit 1
echo OK
echo $N Removing the newline from a file which used to have one .....$NL
echo hadnl > hadnl
bk ci $Q -i hadnl
bk get $Q -e hadnl
echo $NX hadnl$NXL > hadnl
bk clean $Q hadnl
if [ $? -eq 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N Adding a newline to a file which did not have one ...........$NL
echo $N nothadnl$NL > nothadnl
bk ci $Q -i nothadnl
bk get $Q -e nothadnl
echo nothadnl > nothadnl
bk clean $Q nothadnl
if [ $? -eq 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N No change to a file which initially had no newline ..........$NL
echo $N initnonl$NL > initnonl
bk ci $Q -i initnonl
bk get $Q -e initnonl
echo initnonl > initnonl
bk delta $Q -yinitnonl initnonl
bk get $Q -e initnonl
bk clean $Q initnonl
if [ $? -ne 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N Initially had no newline, then deleted last line ............$NL
echo first > initdel
echo $N initdel$NL >> initdel
bk ci $Q -i initdel
bk get $Q -e initdel
echo first > initdel
bk delta $Q -yinitdel initdel
bk get $Q -e initdel
bk clean $Q initdel
if [ $? -ne 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N Hash change new key in gfile ................................$NL
echo newkey first > newkey
bk ci $Q -i -h newkey
bk get $Q -e newkey
echo morenewkey second > newkey
echo newkey first >> newkey
bk clean $Q newkey
if [ $? -eq 0 ] ; then echo failed; fail=yes; else echo OK; fi
#NOTE: deleted keys not supported at this time
#echo $N Hash change del key in gfile ................................$NL
#echo delkey first > delkey
#echo moredelkey second >> delkey
#ci $Q -i -h delkey
#get $Q -e delkey
#echo moredelkey second > delkey
#clean $Q delkey
#if [ $? -eq 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N Hash change val in gfile ....................................$NL
echo newval first > newval
bk ci $Q -i -h newval
bk get $Q -e newval
echo newval last > newval
bk clean $Q newval
if [ $? -eq 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N Hash diff is order independent ..............................$NL
echo orderind first > orderind
echo morekey next >> orderind
bk ci $Q -i -h orderind
bk get $Q -e orderind
echo morekey next > orderind
echo orderind first >> orderind
bk clean $Q orderind
if [ $? -ne 0 ] ; then echo failed; fail=yes; else echo OK; fi
if [ $fail = yes ] ; then exit 1; fi

echo $N Check cleaning of a chmod +w sccs keywords file .............$NL
bk unedit sccsexp || exit 1
bk get $Q sccsexp || exit 1
chmod +w sccsexp
bk clean sccsexp || {
	echo failed to clean sccsexp
	exit 1
}
test -f sccsexp && {
	echo failed to clean sccsexp
	exit 1
}
echo OK

echo $N Check cleaning of a chmod +w sccs keywords file with changes.$NL
bk clean sccsexp || exit 1
bk get $Q sccsexp
chmod +w sccsexp
echo foo >> sccsexp
bk clean sccsexp 2>/dev/null && {
	echo should not have cleaned sccsexp
	exit 1
}
test -f sccsexp || {
	echo should not have cleaned sccsexp
	exit 1
}
echo OK

echo $N Check cleaning of a chmod +w rcs keywords file ..............$NL
bk clean rcsexp || exit 1
bk get $Q rcsexp
chmod +w rcsexp
bk clean rcsexp || {
	echo failed to clean rcsexp
	exit 1
}
test -f rcsexp && {
	echo failed to clean rcsexp
	exit 1
}
echo OK

echo $N Check cleaning of a chmod +w rcs keywords file with changes .$NL
bk clean rcsexp || exit 1
bk get $Q rcsexp
chmod +w rcsexp
echo foo >> rcsexp
bk clean rcsexp 2>/dev/null && {
	echo should not have cleaned rcsexp
	exit 1
}
test -f rcsexp || {
	echo should not have cleaned rcsexp
	exit 1
}
echo OK

test "$PLATFORM" != "WIN32" && {
echo $N Check cleaning of a changed symlink .........................$NL
ln -s some_dir symlink
bk new $Q symlink
ln -s some__other_dir symlink
bk clean -v symlink 2>/dev/null && {
	echo should not have cleaned symlink
	exit 1
}
test -h symlink || {
	echo should not have removed symlink
	exit 1
}
echo OK
}

exit 0
