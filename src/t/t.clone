# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2002 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Tests for  clone.
echo $N Create initial repository ...................................$NL
commercial project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if bk _test ! -f SCCS/s.ChangeSet; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
mkdir src
cd src
echo foo > 'F!O#O$ B%A^R&RR(R)RR'
echo bar > bar.c
echo h > h.h
bk ci $Q -i 'F!O#O$ B%A^R&RR(R)RR' bar.c h.h
if bk _test ! -f SCCS/s.'F!O#O$ B%A^R&RR(R)RR'; then echo failed to create history; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 15 ]; then echo wrong pending result $P; bk pending; exit 1; fi
echo OK

echo $N Clone with all pending deltas................................$NL
cd "$HERE"
bk clone $Q project copy || exit 1
# the entire src directory should be gone
[ -d copy/src ] && exit 1
echo OK

echo $N Test clone to illegal directory .............................$NL
touch "$HERE/file"
bk clone $Q project "$HERE/file/XXX.cannotwrite/foo" 2> OUT && {
	echo clone should have failed
	cat OUT
	exit 1
}
test -d RESYNC && {
	echo should not have created RESYNC
	cat OUT
	exit 1
}
rm -f "$HERE/file"
echo OK

echo $N Test clone to directory with spaces in its name..............$NL
unset TMPDIR
mkdir "Silly directory with spaces"
bk clone $Q project "Silly directory with spaces/project" 2> OUT || {
	echo clone should have worked
	cat OUT
	exit 1
}
echo OK

echo $N Test clone from directory with spaces........................$NL
cd "Silly directory with spaces"
bk clone $Q project project2 2> OUT || {
	echo clone should have worked
	cat OUT
	exit 1
}
cat OUT
echo OK

test "$PLATFORM" = "WIN32" || {

echo $N Test clone from source which is a symlink ...................$NL
ln -s project symlink
bk bkd -q -aPORT -ikill || exit 1
P=`cat PORT`
mkdir dest
cd dest
bk clone $Q bk://localhost:$P/symlink || {
	echo clone should have worked
	bk _kill http://localhost:$P
	exit 1
}
test -d project && {
	echo failed, I wanted symlink not project
	exit 1
}
test -d symlink || {
	echo failed, I dunno what I got but it is not symlink
	ls
	exit 1
}
echo OK

echo $N Test clone from symlink source w/BK_CLONE_FOLLOW_LINK .......$NL
rm -fr symlink
BK_CLONE_FOLLOW_LINK=1 bk clone $Q bk://localhost:$P/symlink || {
	echo clone should have worked
	bk _kill http://localhost:$P
	exit 1
}
bk _kill http://localhost:$P
test -d project || {
	echo failed, I wanted symlink not project
	exit 1
}
test -d symlink && {
	echo failed, I dunno what I got but it is not symlink
	ls
	exit 1
}
echo OK

# End of "not windows" tests
}

echo $N Test null clonemod ..........................................$NL
cd "$HERE"/project
bk commit $Q -ystuff
cd ..
bk lclone $Q project cmbase
bk clonemod $Q "$HERE/project" cmbase nullclonemod || exit 1
cd nullclonemod
bk parent -l > GOT
bk parent $Q ../project
bk parent -l > WANT
cmpfiles WANT GOT
bk changes -qLR > CHANGES
test -s CHANGES && exit 1
cd ..
echo OK

echo $N Test clonemod with remote cset ..............................$NL
cd project
bk edit $Q src/bar.c
bk delta $Q -fybar src/bar.c
bk commit $Q -ybar
cd ..
bk clonemod $Q "$HERE/project" cmbase remotecset || exit 1
cd remotecset
bk parent -l > GOT
bk parent $Q ../project
bk parent -l > WANT
cmpfiles WANT GOT
bk changes -qLR > CHANGES
test -s CHANGES && exit 1
cd ..
echo OK

echo $N Test clonemod with remote and local cset ....................$NL
cd cmbase
bk edit $Q src/bar.c
bk delta $Q -fybar src/bar.c
bk commit $Q -ybar
cd ..
bk clonemod $Q "$HERE/project" cmbase localcset || exit 1
cd localcset
bk parent -l > GOT
bk parent $Q ../project
bk parent -l > WANT
cmpfiles WANT GOT
bk changes -qLR > CHANGES
test -s CHANGES && exit 1
cd ..
echo OK

echo $N Test clonemod with multinode gca ............................$NL
cd nullclonemod
bk edit $Q src/bar.c
bk delta $Q -fybar src/bar.c
bk commit $Q -ybar
cd ../project
bk pull $Q ../cmbase
bk pull $Q ../nullclonemod
cd ../cmbase
bk pull $Q ../nullclonemod
cd ..
bk clonemod $Q "$HERE/project" cmbase multinode || exit 1
cd multinode
bk parent -l > GOT
bk parent $Q ../project
bk parent -l > WANT
cmpfiles WANT GOT
bk changes -qLR > CHANGES
test -s CHANGES && exit 1
cd ..
echo OK

echo $N Test clonemod with adding a local tag .......................$NL
bk clone $Q project tagbase
cd tagbase
# two local tags to show need for -f added to changes
bk tag $Q TAGLOCAL1
bk tag $Q TAGLOCAL2
bk edit $Q src/bar.c
bk delta $Q -fybar src/bar.c
bk commit $Q -ybar
cd ../project
bk edit $Q src/h.h
bk delta $Q -fybar src/h.h
bk commit $Q -yh.h
bk tag $Q TAGPROJECT
cd ../tagbase
# create a tag on a cset which will be undone, leaving 2 tips in tag graph
# such that we want to keep the newer tip
bk tag $Q TAGLOCAL3
bk pull $Q ../project
cd ..
bk clonemod $Q "$HERE/project" tagbase localtag || exit 1
cd localtag
bk parent -l > GOT
bk parent $Q ../project
bk parent -l > WANT
cmpfiles WANT GOT
bk changes -qLR > CHANGES
test -s CHANGES && exit 1
cd ..
echo OK

echo $N Test clone with 1 arg and trailing slash ....................$NL
mkdir foo
cd foo
bk clone $Q "$HERE"/project/ || exit 1
echo OK

echo $N Test clone into an existing directory........................$NL
cd "$HERE"
mkdir existing || exit 1
cd existing
bk clone "$HERE/project" . >"$HERE"/OUT 2>&1 || {
	echo failed
	cat "$HERE"/OUT
	exit 1
}
echo OK

echo $N Test clone to . inside a project.............................$NL
cd "$HERE"
rm -rf existing
commercial aproject
mkdir existing
cd existing
bk clone "$HERE/project" . >"$HERE"/OUT 2>&1 || {
	echo failed
	cat "$HERE"/OUT
	exit 1
}
echo OK

echo $N Test clone will emit cannot resolve message even with -q ....$NL
cd "$HERE"
rm -rf foo
bk clone -q bk://doesntexist/foo 2> ERR && {
	echo should have failed
	exit 1
}
grep -q 'Cannot resolve' ERR || {
	echo failed
	cat ERR
	exit 1
}
echo OK

echo $N Test clone with 1 arg and trailing slash ....................$NL
mkdir foo
cd foo
bk clone $Q "$HERE"/project/ || fail
echo OK

echo $N Test clone -r in partial_check / checkout:edit mode .........$NL
cd project
bk -r check -ac || fail
cd ..
BK_CONFIG='checkout:edit!;partial_check:yes!' \
	bk clone -r1.5 $Q project checkout || fail
cd checkout
test -w src/bar.c || fail
test -w src/h.h || fail
echo OK

echo $N Show that a partial_check clone transfers id_cache ..........$NL
cd "$HERE"
test -f "project/BitKeeper/log/x.id_cache" || fail no id_cache
BK_CONFIG='partial_check:yes!' bk clone $Q --sccs-compat project noremap || fail

# not bk _test
test -f "noremap/BitKeeper/etc/SCCS/x.id_cache" || fail no id_cache

BK_CONFIG='partial_check:yes!' \
	bk clone $Q --no-sccs-compat noremap remap || fail
# not bk _test
test -f "remap/BitKeeper/log/x.id_cache" || fail no id_cache
echo OK
