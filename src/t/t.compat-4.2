# There are two main things being tested: BAM and Fast-Pull
# BAM was introduced in 4.1, but we are using a BAM baseline as 4.2
#
# 4.3 introduced Fast Pull which includes a whole sfile under some
# circumstances.

OLDVER=4.2
OLDBK=/build/bitkeeper-$OLDVER

echo $N Check bitkeeper 4.2 installation ............................$NL
if [ -n "$BK_DEV_SKIPTEST" ]; then echo skipped; exit 0; fi
# Skip this test for Windows VISTA
OSTYPE=`uname -s`
case $OSTYPE in
	MINGW32_NT-6.*) echo skipped; exit 0;;
esac
echo license: $BKL_PRO > c
echo licsign1: $BKL_P1 >> c
echo licsign2: $BKL_P2 >> c
echo licsign3: $BKL_P3 >> c
mv c "`bk dotbk`"/config
test -d $OLDBK || {
    # Skip this test if we don't have at least 5gigs free
    df -k /build 2>/dev/null |
        perl -e '$_ = <>; $_ = <>; exit 0 if /^\S+\s+\d+\s+\d+\s+(\d+)\s+\d+%/ && $1 > 5e6; exit 1' || {
	echo skipped
	exit 0
    }
    bk upgrade $Q -f -n $BK_TCOMPAT_ARCH \
	    http://data.bitmover.com/upgrades.$OLDVER >out 2>ERR || {
	    grep -q "No upgrade for the arch.*found" ERR && {
		echo skipped
		exit 0
	    }
	    echo image fetch failed
	    exit 1
    }
    # NOTE bk-3.2.x didn't set exit status...
    echo y | BK_NOLINKS=1 ./bk-$OLDVER-* $OLDBK >out 2>err || exit 1
    rm $OLDBK/config

    # generate a crypto key for tests
    $OLDBK/bk crypto -i 1024 $OLDBK/my.sec $OLDBK/my.pub || exit 1
}
VER=`$OLDBK/bk version -s`
test X$VER = X$OLDVER || {
	echo bk not installed correctly
	exit 1
}
echo OK

echo -------------- gone file automerge tests
echo $N Test auto-merge on gone files works with new del format .....$NL
commercial project
bk clone $Q --sccs-compat . ../copy
bk edit $Q BitKeeper/etc/gone
echo "a@b.c|d|20001010101010|63920|1fea66be52324149" >> BitKeeper/etc/gone
bk delta $Q -yfakegone BitKeeper/etc/gone
bk commit $Q -yfakegone
cd ../copy
GONENAME="`bk log -r1.0 -nd:RM_NAME: BitKeeper/etc/gone`"
$OLDBK/bk rm -f BitKeeper/etc/gone
bk commit $Q -yfakenewgone
echo "a@b.c|d|20000101010101|63320|1fea36b352324149" > BitKeeper/etc/gone
bk new $Q BitKeeper/etc/gone
bk commit $Q -yfakenewgone
cd ../project
bk pull $Q ../copy
test "`bk cat BitKeeper/etc/gone | wc -l`" -eq 3 || fail
echo OK

echo $N Test auto-merge on gone files uses existing deleted name ....$NL
cd ../copy
$OLDBK/bk rm -f BitKeeper/etc/gone
bk sfiles | grep '~.$' > ERR && fail -f ERR
bk commit $Q -ygone
cd ../project
bk rm -f BitKeeper/etc/gone
bk sfiles | grep '~.$' > ERR && fail -f ERR
bk commit $Q -ygone
bk pull $Q ../copy
bk sfiles | grep '~.$' > ERR && fail -f ERR
echo OK

echo $N Test delete of delete either renaming or doing nop ..........$NL
cd ../copy
touch foo
bk new $Q foo
RMNAME="`bk log -r1.0 -nd:RM_NAME: foo`"
bk rm foo
OLDGONENAME=`bk sfiles -g BitKeeper/deleted | grep gone~`
NRMNAME=`bk prs -r1.0 -hnd:RM_NAME: $OLDGONENAME`
bk sfiles -g BitKeeper/deleted | bk _sort > GOT
cat <<EOF | bk _sort > WANT
BitKeeper/deleted/.del-gone
$OLDGONENAME
$RMNAME
EOF
cmpfiles WANT GOT
# layout in new deleted anything that is not already there
bk -rBitKeeper/deleted rm -f
# check it out
bk sfiles -g BitKeeper/deleted | bk _sort > GOT
cat <<EOF | bk _sort > WANT
$RMNAME
$NRMNAME
$GONENAME
EOF
cmpfiles WANT GOT
cd ..
echo OK

echo -------------- fast pull tests
echo $N Set up a patch new, BAM and many deltas .....................$NL
rm -fr project copy
# don't do "FOO=1 shell-function" but break out env setting and clearing
# use uncached form of commercial since env is different
_BK_BAM_V2=1
export _BK_BAM_V2
_commercial_config > c
bk setup -a -f --sccs-compat -cc project.noremap || fail
cd project.noremap
echo BAMBAM > BAM
bk new $Q -b BAM || exit 1
bk commit $Q -ybamdata
test -d SCCS || exit 1
test -f BitKeeper/BAM/index.db || exit 1
cd ..
bk clone $Q project.noremap copy.noremap || exit 1
unset _BK_BAM_V2
bk clone --hide-sccs-dirs $Q project.noremap project
bk clone $Q project copy
cd copy.noremap
bk parent $Q ../project
cd ../project
# verify new style BAM and BLOB
test -d SCCS && exit 1
test -d BitKeeper/BAM -a ! -f BitKeeper/BAM/index.db || exit 1
touch send-as-sfile send-as-deltas
bk new $Q send-as-sfile send-as-deltas || exit 1
bk commit $Q -SBASE -yfooze || exit 1
bk push $Q ../copy
bk push $Q ../copy.noremap
touch newfile
bk new $Q newfile || exit 1
bk edit $Q send-as-sfile send-as-deltas || exit 1
# 9 is the internal baseline for largest that passes as a patch
for i in 1 2 3 4 5 6 7 8 9; do
	bk delta $Q -l -f -ymkdeltas send-as-deltas send-as-sfile || exit 1
done
# adding a 10th to send-as-sfile means it will move as an sfile
bk delta $Q -l -f -ysend-as-sfile send-as-sfile || exit 1
bk unedit $Q send-as-sfile send-as-deltas || exit 1
bk commit $Q -y'deltas to existing files' || exit 1
bk push $Q ../project.noremap || exit 1
#
bk makepatch $Q -B -r+ > ../PATCH || exit 1
bk makepatch $Q -B -C -r+ > ../PATCH-COMPAT || exit 1
bk send $Q -r+ - > ../SEND || exit 1
cd "$HERE"
mv project project.remap
mv project.noremap project
cd project
$OLDBK/bk makepatch $Q -B -r+ > ../OLDPATCH || exit 1
$OLDBK/bk send $Q -r+ - > ../OLDSEND || exit 1
cd ..
cmpfiles SEND OLDSEND
cmpfiles PATCH-COMPAT OLDPATCH
cmp -s PATCH OLDPATCH && exit 1
tar cf copy.tar copy
tar cf copy.noremap.tar copy.noremap
cd "$HERE"
mv project project.noremap
mv project.remap project
echo OK

echo $N New patch, old bk, takepatch works, resolve fails ...........$NL
cd copy.noremap || exit 1
$OLDBK/bk takepatch < ../PATCH || exit 1
$OLDBK/bk resolve 2> ERR && exit 1
grep -q "Missing file" ERR || exit 1
rm -fr RESYNC PENDING
echo "failed (bug -- should increase PATCH_VER?)"

echo $N Start new and old bkds ......................................$NL
cd "$HERE"
OLDP=`port 54500`
# old bkd will have "No root for triggers!" ttyprintf
BK_TTYPRINTF= $OLDBK/bk bkd -d -p$OLDP -ikill 2> OLDERR || exit 1
bk bkd -d -aPORT -ikill 2> NEWERR || exit 1
NEWP=`cat PORT`
trap "bk _kill bk://localhost:$OLDP; bk _kill bk://localhost:$NEWP" 0
echo OK

echo $N Push old server new client ..................................$NL
cd project || exit 1
bk push $Q bk://localhost:$OLDP/copy.noremap || exit 1
echo OK

echo $N Push new server old client ..................................$NL
cd ..
rm -fr copy
tar xf copy.tar
cd project.noremap || exit 1
$OLDBK/bk push $Q bk://localhost:$NEWP/copy || exit 1
echo OK

echo $N Pull old server new client ..................................$NL
cd ..
rm -fr copy
tar xf copy.tar
cd copy || exit 1
bk pull $Q bk://localhost:$OLDP/project.noremap || exit 1
echo OK

echo $N Pull new server old client ..................................$NL
cd ..
rm -fr copy.noremap
tar xf copy.noremap.tar
cd copy.noremap || exit 1
$OLDBK/bk pull $Q bk://localhost:$NEWP/project || exit 1
echo OK

echo $N Pull old server new client with local work present ..........$NL
cd ..
rm -fr copy
tar xf copy.tar
cd copy || exit 1
touch localfile
bk new $Q localfile || exit 1
bk commit $Q -ylocalcset || exit 1
bk pull $Q bk://localhost:$OLDP/project.noremap || exit 1
echo OK

echo $N Pull new server old client with local work present ..........$NL
cd ..
rm -fr copy.noremap
tar xf copy.noremap.tar
cd copy.noremap || exit 1
touch localfile
bk new $Q localfile || exit 1
bk commit $Q -ylocalcset || exit 1
$OLDBK/bk pull $Q bk://localhost:$NEWP/project || exit 1
echo OK

echo $N Nested detached repo running behind old bkd .................$NL
cd "$HERE"
nested nest
bk detach $Q --sccs-compat gcc ../newgcc || fail
cd ../newgcc
bk clone $Q . bk://localhost:$OLDP/oldgcc || fail
bk clone $Q bk://localhost:$OLDP/oldgcc ../cloned-gcc || fail
bk parent $Q bk://localhost:$OLDP/oldgcc || fail
bk pull $Q || exit 2
bk push $Q || exit 3
# XXX Pause and agree -- okay to have changes fail here?
# It's a detached repo running behind an old BKD and the new probe sends
# the origkey as the rootkey and the old BKD doesn't know to look for it.
# The fix in this case is to upgrade the bkd to something new.
bk changes $Q -L 2> ERR && exit 4
grep -q "synchronize with an unrelated package" ERR || exit 5
bk changes $Q -R 2> ERR && exit 6
grep -q "synchronize with an unrelated package" ERR || exit 7
echo OK

echo $N Nested detached repo running behind new bkd with old client .$NL
cd ../oldgcc
$OLDBK/bk clone $Q . bk://localhost:$NEWP/newgcc2
$OLDBK/bk clone $Q bk://localhost:$NEWP/oldgcc ../cloned-gcc2 || exit 1
$OLDBK/bk parent $Q bk://localhost:$NEWP/newgcc2
$OLDBK/bk pull $Q || exit 2
$OLDBK/bk push $Q || exit 3
# This workes because when the bkd is new, listkeys takes either
# an origkey or rootkey, so it works.
$OLDBK/bk changes $Q -L || exit 4
$OLDBK/bk changes $Q -R || exit 5
echo OK

echo $N Old-bk clone of component behind nested-aware bkd fails .....$NL
cd "$HERE"
bk clone $Q bk://localhost:$OLDP/nest/gcc 2> ERR && exit 1
grep -q "good error msg" ERR || echo "failed (bug -- need good err msg)"

echo $N Check lease proxy compat ....................................$NL
cd "$HERE"
# Do some work to isolate license key
cp -R .bk .mybk
mv .mybk/config dotbkconfig
grep -v '^lic' dotbkconfig > .mybk/config
BK_DOTBK="$HERE/.mybk"
export BK_DOTBK
rm -fr copy
tar xf copy.tar
cd copy || exit 1
bk edit $Q BitKeeper/etc/config
grep -v '^lic' BitKeeper/etc/config > ../repoconfig
cp ../repoconfig BitKeeper/etc/config
bk lease renew 2> ERR && echo lease worked?
grep -q 'You do not have a license for BitKeeper' ERR || exit 1
cd ..
cp -R copy licserve
cd licserve
rm BitKeeper/log/repo_id
bk id -r > newid
cd ../copy
echo "licenseurl: bk://localhost:$OLDP" >> BitKeeper/etc/config
bk lease renew || exit 1
$OLDBK/bk lease renew || exit 1
cp ../repoconfig BitKeeper/etc/config
echo "licenseurl: bk://localhost:$NEWP" >> BitKeeper/etc/config
bk lease renew || exit 1
$OLDBK/bk lease renew || exit 1
cp ../repoconfig BitKeeper/etc/config
echo "licenseurl: bk://localhost:$OLDP/licserve" >> BitKeeper/etc/config
bk lease renew || exit 1
$OLDBK/bk lease renew || exit 1
cp ../repoconfig BitKeeper/etc/config
echo "licenseurl: bk://localhost:$NEWP/licserve" >> BitKeeper/etc/config
bk lease renew || exit 1
$OLDBK/bk lease renew || exit 1
echo OK

echo $N Check lease proxy trigger compat ............................$NL
cd "$HERE"
mkdir -p BitKeeper/triggers || exit 1
cd BitKeeper/triggers || exit 1
cat <<'EOF' > pre-lease-proxy.global
#!/bin/sh
echo "My message to you is that the $BK_EVENT failed"
exit 1
EOF
chmod +x pre-lease-proxy.global
cd ../..
echo "triggers: $HERE" >> .bk/config
cd copy
cp ../repoconfig BitKeeper/etc/config
echo "licenseurl: bk://localhost:$OLDP/licserve" >> BitKeeper/etc/config
bk lease renew 2> ERR && exit 1
grep -q "My message" ERR && exit 1
$OLDBK/bk lease renew 2> ERR && exit 1
grep -q "My message" ERR && exit 1
cp ../repoconfig BitKeeper/etc/config
echo "licenseurl: bk://localhost:$NEWP/licserve" >> BitKeeper/etc/config
bk lease renew 2> ERR && exit 1
grep -q "My message" ERR || exit 1
$OLDBK/bk lease renew 2> ERR && exit 1
grep -q "My message" ERR && exit 1
echo OK

echo $N Show global lease proxy triggers do not fire if not in repo .$NL
cp ../repoconfig BitKeeper/etc/config
echo "licenseurl: bk://localhost:$OLDP" >> BitKeeper/etc/config
bk lease renew || exit 1
$OLDBK/bk lease renew || exit 1
cp ../repoconfig BitKeeper/etc/config
echo "licenseurl: bk://localhost:$NEWP" >> BitKeeper/etc/config
bk lease renew || exit 1
$OLDBK/bk lease renew || exit 1
echo OK

echo $N Check bkd error logs ........................................$NL
cd "$HERE"
test -s OLDERR -o -s NEWERR && exit 1
echo OK

echo -------------- sortkey repo interacting with old bk
echo $N Make a repo with illegal key order and test .................$NL
# From t.sortkeys, modified to be a csetprune instead of partition
BK_RANDOM=1000197497459702
BK_DATE_TIME_ZONE="98/09/22 16:23:31+00:00"
_BK_NO_UNIQ=1
export BK_DATE_TIME_ZONE _BK_NO_UNIQ BK_RANDOM
# do not use cache, as we want predictable repo
fresh_commercial base
# two files, one 'del' will get move to a subdir, then pruned.
echo line > keep
touch del
bk new $Q keep del
bk commit $Q -ybase
bk clone $Q --sccs-compat . ../diamond
# make a diamon cset graph - here's the trunk - edit both
bk edit $Q keep del
echo foo > del
cat > keep <<EOF
1
line
EOF
# this is branch on del, because of path sorting
bk delta $Q -ytrunk keep del
bk commit $Q -ytrunk
# ... here's the branch - move del to component anno (anno sorts before del)
cd ../diamond
bk edit $Q keep
echo data >> keep
bk delta $Q -ybranch keep
bk commit $Q -ybranch
# make the merge
bk pull $Q
$OLDBK/bk clone $Q . ../diamond-old
bk prs -r+ -hnd:ROOTKEY: del > ../PRUNELIST
bk csetprune $Q -S -k1234567890abcdef < ../PRUNELIST
cd ../diamond-old
$OLDBK/bk csetprune $Q -S -k1234567890abcdef 2> NOISE < ../PRUNELIST 
bk check ChangeSet 2> GOT && fail
cat > WANT <<EOF
SCCS/s.ChangeSet: 1.3 is not earlier than 1.2.1.1
SCCS/s.ChangeSet: 1.3 is not earlier than 1.2.1.1
EOF
cmpfiles WANT GOT
echo OK

echo $N Show that an writing erases meta data .......................$NL
cd ../diamond
bk check ChangeSet || fail

# show old bk can't read repo
$OLDBK/bk changes 2>ERR && fail -f ERR
grep -q bk-filever-5 ERR || fail
echo OK

echo $N Show a pull of bad data is caught in takepatch ..............$NL
cd ..
bk clone $Q -r1.2 diamond-old diamond-test || fail
cd diamond-test
bk pull -q bk://localhost:$OLDP/diamond-old 2> ERR && fail
grep -q "patch not in old to new order" ERR || fail -f ERR
echo OK
