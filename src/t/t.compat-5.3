# 5.0 introduced Nested.  At first, there was nothing to be backward
# compatible with, but now with a few rounds of nested out in the field,
# stick in bk-5.3 as a baseline to compare against.

OLDVER=5.3
OLDBK=/build/bitkeeper-$OLDVER

# use new parallel clone in tests
_BK_FORCE_NETFS=YES
export _BK_FORCE_NETFS

# bk-5.3 won't understand binary sfiles
BK_CONFIG='binfile:no!'
export BK_CONFIG

echo $N Check bitkeeper 5.3 installation ............................$NL
if [ -n "$BK_DEV_SKIPTEST" ]; then echo skipped; exit 0; fi
# Skip this test for Windows VISTA
OSTYPE=`uname -s`
case $OSTYPE in
	MINGW32_NT-6.*) echo skipped; exit 0;;
esac
echo license: $BKL_PRO > c
echo licsign1: $BKL_P1 >> c
echo licsign2: $BKL_P2 >> c
echo licsign3: $BKL_P3 >> c
mv c "`bk dotbk`"/config
test -d $OLDBK || {
    # Skip this test if we don't have at least 5gigs free
    df -Pk /build 2>/dev/null |
        perl -e '$_ = <>; $_ = <>; exit 0 if /^\S+\s+\d+\s+\d+\s+(\d+)\s+\d+%/ && $1 > 5e6; exit 1' || {
	echo skipped
	exit 0
    }
    bk upgrade $Q -f -n $BK_TCOMPAT_ARCH \
	    http://data.bitmover.com/upgrades.$OLDVER >out 2>ERR || {
	    grep -q "No upgrade for the arch.*found" ERR && {
		echo skipped
		exit 0
	    }
	    echo image fetch failed
	    exit 1
    }
    # NOTE bk-3.2.x didn't set exit status...
    echo y | BK_NOLINKS=1 ./bk-$OLDVER-* $OLDBK >out 2>err || fail
    rm $OLDBK/config
}

# generate a crypto key for tests
test -f "$OLDBK/my.pub" || {
    $OLDBK/bk crypto -i 1024 $OLDBK/my.sec $OLDBK/my.pub || fail
}
VER=`$OLDBK/bk version -s`
test X$VER = X$OLDVER || {
	echo bk not installed correctly
	exit 1
}
echo OK

echo -------------- crypto tests
echo $N New and old version should generate the same signature ......$NL
$OLDBK/bk crypto -s $OLDBK/my.sec < "$BIN2" > sig1 || exit 1
bk crypto -s $OLDBK/my.sec < "$BIN2" > sig2 || exit 1
echo OK

echo $N New and old versions should validate signature ..............$NL
$OLDBK/bk crypto -v $OLDBK/my.pub sig1 < "$BIN2" || exit 1
bk crypto -v $OLDBK/my.pub sig1 < "$BIN2" || exit 1
$OLDBK/bk crypto -v $OLDBK/my.pub sig2 < $BIN2 || exit 1
bk crypto -v $OLDBK/my.pub sig2 < "$BIN2" || exit 1
echo OK

echo $N Old version encrypts and new version decrypts ...............$NL
$OLDBK/bk crypto -e $OLDBK/my.pub < "$BIN2" > enc || exit 1
bk crypto -d $OLDBK/my.sec < enc > out || exit 1
cmp -s "$BIN2" out || exit 1
rm -f enc out
echo OK

echo $N New version encrypts and old version decrypts ...............$NL
bk crypto -e $OLDBK/my.pub < "$BIN2" > enc || exit 1
$OLDBK/bk crypto -d $OLDBK/my.sec < enc > out || exit 1
cmp -s "$BIN2" out || exit 1
rm -f enc out
echo OK

KEY=64338d0365e3c7da
echo $N New and old versions should symetric encrypt to same data ...$NL
$OLDBK/bk crypto -E $KEY < "$BIN2" > enc1 || exit 1
bk crypto -E $KEY < "$BIN2" > enc2 || exit 1
cmp -s enc1 enc2 || exit 1
rm -f enc2
echo OK

echo $N Both versions should be able to decrypt data ................$NL
$OLDBK/bk crypto -D $KEY < enc1 > out || exit 1
cmp -s "$BIN2" out || exit 1
bk crypto -D $KEY < enc1 > out || exit 1
cmp -s "$BIN2" out || exit 1
rm -f enc1 out
echo OK

echo $N Check hashing with new and old versions .....................$NL
$OLDBK/bk crypto -h - < "$BIN2" > hash1
bk crypto -h - < "$BIN2" > hash2 || exit 1
cmpfiles hash1 hash2
echo OK

echo $N Check hmacs with new and old versions .......................$NL
$OLDBK/bk crypto -h - key < "$BIN2" > hash1
bk crypto -h - key < "$BIN2" > hash2 || exit 1
cmpfiles hash1 hash2
echo OK

echo $N Start new and old bkds ......................................$NL
cd "$HERE"
OLDP=`port 54500`
# old bkd will have "No root for triggers!" ttyprintf
$OLDBK/bk bkd -d -aPORT -ikill 2> OLDERR || fail -f OLDERR
OLDP=`cat PORT`
bk bkd -d -aPORT -ikill 2> NEWERR || fail -f NEWERR
NEWP=`cat PORT`
trap "bk _kill bk://localhost:$OLDP; bk _kill bk://localhost:$NEWP" 0
echo OK

echo -------------- clone compat tests
# use new parallel clone in tests
_BK_FORCE_NETFS=YES
export _BK_FORCE_NETFS

echo $N Clone from old bkd and make sure we do checkouts ............$NL
cd "$HERE"
fresh_commercial project
bk clone $Q --sccs-compat . ../sccsdirs
cd ../sccsdirs
mkdir src
cd src
echo foo > foo
bk new $Q foo
cd ..
bk commit -ywhatever $Q
cd ..
# Important for the test: SCCS compat, partial check and checkout get|edit
bk --config='partial_check:yes' clone $Q --checkout=get \
    bk://localhost:$OLDP/sccsdirs file-after || fail
cd file-after
bk -U^G > CO
test -s CO && fail -f CO files not checked out
echo OK

echo $N Clone again, but such that config is last in the list .......$NL
cd "$HERE"/sccsdirs
bk mv src/foo foo
bk commit -ywhatever $Q
cd ..
# Important for the test: SCCS compat, partial check and checkout get|edit
bk --config='partial_check:yes' clone $Q --checkout=get \
    bk://localhost:$OLDP/sccsdirs config-last || fail
cd config-last
bk -U^G > CO
test -s CO && fail -f CO files not checked out
echo OK

echo $N Try parallel clone to bkd, should fail ......................$NL
cd "$HERE"
bk clone $Q -j5 config-last bk://localhost:$OLDP/clone-j > OUT 2>&1
test $? = 0 && fail
grep -q "does not understand -j" OUT || fail
echo OK

echo $N Try a pull urllist to see if the hacks work .................$NL
# old bkds fail bkd_nested call, so hackery in place to work anyway
cd "$HERE"
fresh_nested nest
bk clone $Q . ../nest-dest
touch gcc/foo
bk new $Q gcc/foo
bk commit $Q -f
bk clone $Q -s. . ../nest-src
cd ../nest-src
rm BitKeeper/log/urllist
cd ../nest-dest
perl -pe 's|.*/nest$|bk://localhost:'$OLDP'/nest|' BitKeeper/log/urllist > x
cp x BitKeeper/log/urllist
bk pull ../nest-src >X 2>&1 || fail -f GOT
grep searching X > GOT
# The non -q shows takepatch reading the file, and then failing with
# this same nested only in product.  That means to upgraded the bkd.
cat <<EOF > WANT
pull: searching bk://localhost:$OLDP/nest...ok (gate)
EOF
cmpfiles WANT GOT
# again, http style
bk unpull $Q -sf
perl -pe 's|^bk://|http://|' BitKeeper/log/urllist > x
cp x BitKeeper/log/urllist
bk pull ../nest-src >X 2>&1 || fail -f GOT
grep searching X > GOT
cat <<EOF > WANT
pull: searching http://localhost:$OLDP/nest...ok (gate)
EOF
cmpfiles WANT GOT
echo OK

echo -------------- misc tests
echo $N Verify old bk can read new hash encoding ....................$NL
cat <<EOF > hash
@a|b|c
value
EOF
bk _hashfile_test w hash > hash.new || fail
$OLDBK/bk _hashfile_test w hash > hash.old || fail
bk _hashfile_test w hash.old > hash.old.new || fail
$OLDBK/bk _hashfile_test w hash.new > hash.new.old || fail

grep -q '@a|b|c' hash.new || fail
grep -q '@a%7cb%7cc' hash.old || fail

cmpfiles hash.old hash.new.old
cmpfiles hash.new hash.old.new
echo OK

echo $N Verify new bk can read old md5keys ..........................$NL
Kold=`$OLDBK/bk prs -hnd:MD5KEY: -r+ ChangeSet`
Knew=`bk prs -hnd:MD5KEY: -r+ ChangeSet`
Kcompat=`bk prs -hnd:MD5KEY_COMPAT: -r+ ChangeSet`

test $Kold = $Kcompat || fail
test $Kold \!= $Knew || fail

Knew2=`bk prs -hnd:MD5KEY: -r$Kold ChangeSet`

test $Knew = $Knew2 || fail
echo OK
