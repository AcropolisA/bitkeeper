# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Copyright (c) 2000 Larry McVoy
# %K%

BK_USER=user
BK_HOST=host.bk
ME=$BK_USER@$BK_HOST
export ME BK_USER BK_HOST
NUM=0
FILE=test$NUM
HERE=`bk pwd`

echo $N Create repository ...........................................$NL
echo "logging: logging@openlogging.org" > $HERE/c
echo "description: BitKeeper Test repository" >> $HERE/c
echo "email:		nobody@nowhere.bk" >> $HERE/c
echo "eoln: unix" >> $HERE/c
BK_LOGGING_OK=YES bk setup -f -c$HERE/c project
touch project/BitKeeper/etc/SCCS/x.marked
echo OK
echo $N Add content to ignore, gone, logging_ok .....................$NL
cd project
bk ignore '*.o'
bk gone $Q 'A@b.com|I/am/bogus|19990101000000|12345|random'
bk _loggingaccepted
bk commit $Q -ymeta-content
test `bk sfiles -p | wc -l` -eq 0 || {
	echo failed to commit all files
	bk sfiles -p
	exit 1
}
test -f BitKeeper/etc/SCCS/s.ignore || { echo No ignore; exit 1; }
test -f BitKeeper/etc/SCCS/s.logging_ok || { echo No logging_ok; exit 1; }
echo OK
echo $N Clone, add user content, resync, check copies ...............$NL
cd $HERE
bk clone $Q project copy
cd copy
ls > LS
bk new $Q LS
bk commit $Q -yuser-content
cd ../project
bk resync -t $Q ../copy
cd RESYNC || exit 1
# The invariant is that you always get config but none of the others for updates
test -f BitKeeper/etc/SCCS/s.ignore && { echo Copied ignore; exit 1; }
test -f BitKeeper/etc/SCCS/s.logging_ok && { echo Copied logging_ok; exit 1; }
test -f BitKeeper/etc/config || { echo No config; exit 1; }
cd ..
bk abort -f
echo OK

echo $N Create cset only conflict, check copies .....................$NL
date > date
bk new $Q date
bk commit $Q -ydate
bk resync -t $Q ../copy
cores
cd RESYNC || exit 1
# The invariant is that you always get config and all others for conflicts
test -f BitKeeper/etc/SCCS/s.ignore || { echo No ignore; exit 1; }
test -f BitKeeper/etc/SCCS/s.logging_ok || { echo No logging_ok; exit 1; }
test -f BitKeeper/etc/config || { echo No config; exit 1; }
cd ..
bk abort -f
echo OK

# add an entry to each of logging_ok, ignore, config,
# and gone, resync and make sure that we get the remote's version, not the
# parent's version.
for file in config ignore gone logging_ok
do
    case $file in
	logging_ok)	FILE=logging_ok;;
	ignore)		FILE="  $file  ";;
	config)		FILE="  $file  ";;
	gone)		FILE="   $file   ";;
    esac
    echo $N "Change $FILE file, resync, make sure no gfile ..........$NL"
    cd $HERE
    rm -rf copy
    bk clone $Q project copy
    cd copy
    touch BitKeeper/etc/SCCS/x.marked
    bk edit $Q BitKeeper/etc/$file
    echo "# XYXYXYXYXYXYXYXYXYXYXYXYXYXY" >> BitKeeper/etc/$file
    bk delta $Q -y'fake update' BitKeeper/etc/$file
    bk commit $Q -y'config test'
    cd $HERE/project
    bk resync -t $Q ../copy
    test -f RESYNC/BitKeeper/etc/$file && {
	    # Could be OK, maybe BK checked it out
	    bk get -qkp ../copy/BitKeeper/etc/$file > C
	    cmp -s C RESYNC/BitKeeper/etc/$file || {
		    echo should not have used parent $file file
		    exit 1
	    }
    }
    test -f RESYNC/BitKeeper/etc/SCCS/s.$file || {
	    echo failed to update $file file
	    exit 1
    }
    bk abort -f
    echo OK
done

echo $N Create repository, clone, make csets as same users ..........$NL
cd $HERE
rm -rf project copy
BK_LOGGING_OK=YES bk setup -f -c$HERE/c project
touch project/BitKeeper/etc/SCCS/x.marked
bk clone $Q project copy
cd project
bk gone $Q fff
bk commit $Q -ywhatever2 || exit 1
OLD=`bk -R prs -hr1.0 '-d:KEY:\n' BitKeeper/etc/gone`
cd ../copy
bk gone $Q copydd
bk commit $Q -ywhatever2 || exit 1
NEW=`bk -R prs -hr1.0 '-d:KEY:\n' BitKeeper/etc/gone`
if [ "$NEW" = "$OLD" ]
then	echo failed to make different keys
	echo "NEW: $NEW"
	echo "OLD: $OLD"
	exit 1
fi
echo OK
# Note that we are in the repository with the newer key in the slot.
echo $N Pull them, should not ask, should union, oldest in slot .....$NL
bk pull -t ../project > OUT 2>&1
test -d RESYNC && {
	echo failed to use existing gone, left RESYNC
	cat OUT
	exit 1
}
KEY=`bk -R prs -hr1.0 '-d:KEY:\n' BitKeeper/etc/gone`
if [ "$NEW" = "$KEY" ]
then	echo failed to use older key
	exit 1
fi
echo OK

# the case where it is different users but the same timestamp.
# converge.c handles this, we need to test it with a test
# case which dummies up two inodes with different users but the same
# timestamp.

echo $N Create repository, clone, csets as diff users, same time_t ..$NL
cd $HERE
rm -rf project copy
BK_LOGGING_OK=YES bk setup -f -c$HERE/c project
touch project/BitKeeper/etc/SCCS/x.marked
bk clone $Q project copy
cd project
BK_USER=AAA
bk gone $Q project33
echo y | bk commit $Q -ywhatever2 >/dev/null 2>&1
DATE=`bk -R prs -hr1.0 '-dD :I: :D: :T:\n' BitKeeper/etc/gone`
UTC=`bk -R prs -hr1.0 '-d:UTC:\n' BitKeeper/etc/gone`
cd ../copy
BK_USER=BBB
bk gone $Q copy55
echo y | bk commit $Q -ywhatever2 >/dev/null 2>&1
JUNK=`bk -R prs -hr1.0 '-dD :I: :D: :T:\n' BitKeeper/etc/gone`
J_UTC=`bk -R prs -hr1.0 '-d:UTC:\n' BitKeeper/etc/gone`
mv BitKeeper/etc/SCCS/s.gone OLD
perl -pe "s|$JUNK BBB |$DATE BBB |" < OLD > BitKeeper/etc/SCCS/s.gone
bk admin -z BitKeeper/etc/gone
mv SCCS/s.ChangeSet OLD2
sed "s?BitKeeper/etc/gone|$J_UTC?BitKeeper/etc/gone|$UTC?" \
								< OLD2 >  X
bk undos X > SCCS/s.ChangeSet
bk admin -z ChangeSet
bk checksum -f ChangeSet 2> /dev/null
bk -r check -a || exit 1
NEW=`bk -R prs -hr1.0 '-dD :I: :D: :T:\n' BitKeeper/etc/gone`
if [ "$NEW" != "$DATE" ]
then	echo failed to fix the dates
	echo "NEW: $NEW"
	echo "OLD: $DATE"
	exit 1
fi
echo OK

echo $N Pull them, should not ask, should union, oldest in slot .....$NL
cd $HERE
tar cf SAVE project copy
cd copy
bk pull $Q -t ../project || exit 1
test -d RESYNC && {
	echo failed to use existing gone, left RESYNC
	exit 1
}
KEY=`bk -R prs -hr1.0 '-d:USER:\n' BitKeeper/etc/gone`
if [ "$KEY" != AAA ]
then	echo failed to use older key
	exit 1
fi
KEY=`bk -R prs -hr1.0 '-d:USER:\n' BitKeeper/deleted/SCCS/s.*`
if [ "$KEY" != BBB ]
then	echo failed to delete younger key
	exit 1
fi
echo OK

echo $N Pull opposite direction, want same result ...................$NL
cd $HERE
rm -rf project copy
tar xf SAVE 
cd project
echo n | bk pull $Q -t ../copy >/dev/null 2>&1
test -d RESYNC && {
	echo failed to use existing gone, left RESYNC
	exit 1
}
test -f BitKeeper/etc/SCCS/s.gone || {
	echo failed to restore gone
	exit 1
}
KEY=`bk -R prs -hr1.0 '-d:USER:\n' BitKeeper/etc/gone`
if [ "$KEY" != AAA ]
then	echo failed to use older key, got $KEY
	bk -R prs -r1.0.. -nd:USER: BitKeeper/etc/gone
	exit 1
fi
KEY=`bk -R prs -hr1.0 '-d:USER:\n' BitKeeper/deleted/SCCS/s.*`
if [ "$KEY" != BBB ]
then	echo failed to delete younger key
	exit 1
fi
echo OK

echo $N Create repository ...........................................$NL
cd $HERE
rm -rf project copy
BK_LOGGING_OK=YES bk setup -f -c$HERE/c project
touch project/BitKeeper/etc/SCCS/x.marked
echo OK

echo $N Force cset derived root key, clone ..........................$NL
BK_USER=user
BK_HOST=host.bk
cd project
cd BitKeeper/etc
perl -ne 's,cPChangeSet,cPBitKeeper/etc/gone,; print unless /^.cC$/ || /^.cS/ || /^.cX/ || /^.f x 0x/;' < ../../SCCS/s.ChangeSet > X
mv X SCCS/s.gone
bk admin -z gone
bk stripdel $Q -r1.1.. gone
bk gone $Q project44
echo y | bk commit $Q -ywhatever >/dev/null 2>&1
KEY=`bk -R prs -hr1.0 '-d:KEY:\n' BitKeeper/etc/gone`
cd $HERE
bk clone $Q project copy
echo OK

echo $N Create changesets as two different users ....................$NL
cd project
BK_USER=joe
BK_HOST=blow.dork
export BK_USER BK_HOST
bk gone $Q project34
echo y | bk commit $Q -ywhatever2 >/dev/null 2>&1
KEY2=`bk -R prs -hr1.0 '-d:KEY:\n' BitKeeper/etc/gone`
if [ "$KEY" != "$KEY2" ]
then	echo failed to leave original gone file
	exit 1
fi

cd $HERE/copy
BK_USER=jane
BK_HOST=kick.dork
export BK_USER BK_HOST
bk gone $Q copy34
echo y | bk commit $Q -ywhatever2 >/dev/null 2>&1
KEY2=`bk -R prs -hr1.0 '-d:KEY:\n' BitKeeper/etc/gone`
if [ "$KEY" != "$KEY2" ]
then	echo failed to leave original gone file
	exit 1
fi
echo OK

echo $N Pull, make sure it deletes the OK file and creates new one ..$NL
bk pull -t $Q ../project
KEY2=`bk -R prs -hr1.0 '-d:KEY:\n' BitKeeper/etc/gone`
if [ "$KEY" = "$KEY2" ]
then	echo failed to delete original gone file
	exit 1
fi
sort <<EOF > X
copy34
project34
project44
EOF
bk undos X > DATA
bk get $Q BitKeeper/etc/gone
cmp -s BitKeeper/etc/gone DATA || {
	echo failed to union data
	echo GOT vs WANTED
	sdiff -w80 BitKeeper/etc/gone DATA
	exit 1
}
echo OK

# Create a logging repository, clone, commit in both, 
# in clone unlink logging OK, add to gone file
# but do not commit it, and pull into parent.
# The try it with a push.
echo $N Create repo, clone, commit in both and save .................$NL
cd $HERE
rm -rf project copy
BK_LOGGING_OK=YES bk setup -f -c$HERE/c project
touch project/BitKeeper/etc/SCCS/x.marked
bk clone $Q project copy
cd project
bk gone $Q project34
BK_USER=jane
BK_HOST=kick.dork
echo y | bk commit -yjane $Q > /dev/null 2>&1
test -f BitKeeper/etc/SCCS/s.gone || exit 1
test `bk sfiles -p | wc -l` -eq 0 || {
	echo failed to commit all files
	bk sfiles -p
	exit 1
}
cd $HERE/copy
BK_USER=joe
BK_HOST=blow.dork
bk gone $Q copy34
echo y | bk commit -yjoe $Q > /dev/null 2>&1
test -f BitKeeper/etc/SCCS/s.gone || exit 1
test `bk sfiles -p | wc -l` -eq 0 || {
	echo failed to commit all files
	bk sfiles -p
	exit 1
}
cd $HERE
tar cf TAR project copy
echo OK

# Should not create two copies of the old logging OK, it should move the
# old one back and delete the new one.
echo $N In clone, rm logging_ok, commit a new one, pull .............$NL
cd $HERE
rm -rf project copy
tar xf TAR
cd $HERE/project
CNT=`bk -r prs -hr1.0 -d'$if(:DPN:=BitKeeper/etc/gone){F\n}' | wc -l`
if [ $CNT != 1 ]
then	echo wrong number of gone files in PROJECT
	exit 1
fi
cd $HERE/copy
OLD=`bk -R prs -hr1.0 '-d:KEY:\n' BitKeeper/etc/gone`
CNT=`bk -r prs -hr1.0 -d'$if(:DPN:=BitKeeper/etc/gone){F\n}' | wc -l`
if [ $CNT != 1 ]
then	echo wrong number of gone files in COPY
	exit 1
fi
bk rm -f BitKeeper/etc/gone
bk gone $Q copy44
echo y | bk commit $Q -yrm-gone > /dev/null 2>&1
NEW=`bk -R prs -hr1.0 '-d:KEY:\n' BitKeeper/etc/gone`
if [ "$NEW" = "$OLD" ]
then	echo failed to move gone into deleted slot and create new one
	exit 1
fi
BK_USER=jerk
BK_HOST=blow.dork
echo y | bk pull -t $Q ../project >/dev/null 2>&1
test -d RESYNC && {
	echo failed, left RESYNC
	exit 1
}
# Should be 3, the original 2 and the new one after the rm.
CNT=`bk -r prs -hr1.0 -d'$if(:DPN:=BitKeeper/etc/gone){F\n}' | wc -l`
if [ $CNT != 3 ]
then	echo wrong number of gone files after pull
	bk -r prs -hr1.0 -d'$if(:DPN:=BitKeeper/etc/gone){:ROOTKEY:\n}'
	exit 1
fi
OK=`bk prs -hr1.0 '-d:TIME_T:\n' BitKeeper/etc/gone`
bk sfiles BitKeeper/deleted |
bk prs -hr1.0 -d'$if(:DPN:=BitKeeper/etc/gone){:TIME_T: :GFILE:\n}' - |
while read tt file
do	if [ $tt -lt $OK ]
	then	echo "$file is older than BitKeeper/etc/gone"
		exit 1
	fi
	#if [ $tt -eq $OK ]
	#then	echo "$file is same age as BitKeeper/etc/gone"
	#fi
	#if [ $tt -gt $OK ]
	#then	echo "$file is younger than BitKeeper/etc/gone"
	#fi
done
cat <<EOF > DATA
copy34
copy44
project34
EOF
bk get -kp $Q BitKeeper/etc/gone | bk _sort > GOT
cmp -s GOT DATA || {
	echo failed to union data
	echo GOT vs WANTED
	sdiff -w80 GOT DATA
	exit 1
}
echo OK
