# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Copyright (c) 2001 Larry McVoy & Rick Smith
# %K%

# Test out the cset split thing
# set up a KEYS file to strip all changing to files 'a' and 'c'
# leave files 'b' and 'd' alone

echo $N Setting up cset split testing respositories .................$NL
rm -rf simple
TZ=UTC+0 commercial simple
touch a b c d
bk new $Q a b c d
TZ=EST bk commit $Q -SBASETAG -y1.2 || exit 1
bk prs -h -r+ -d':ROOTKEY:\n' a c > ../KEYS
echo OK

# have tip change 'a' and have it removed
echo $N Simple remove ...............................................$NL
cd "$HERE"
rm -rf line
bk clone $Q simple line
cd line
bk edit $Q a
bk delta $Q -fy1.2 a
bk commit $Q -y1.3 || exit 1
OLD=`bk id`
bk csetprune < ../KEYS 2> ERROR
if [ $? -ne 0 ]; then echo Failed; cat ERROR; exit 1; fi
tip=`bk prs -h -r+ -d':I:\n' ChangeSet`
if [ "$tip" != 1.2 ]; then echo Failed; exit 1; fi
echo OK

echo $N Check that the rootlog was preserved ........................$NL
bk prs -hr+ -d:ROOTLOG: ChangeSet > GOT
# just copy timestamp of new item
head -1 GOT > WANT
echo csetprune command >> WANT
bk id >> WANT
# recreate timestamp of original entry from cset@1.0
bk prs -hr1.0 -nd':USER:@:HOST: :Dy:/:Dm:/:Dd: :T::TZ:' ChangeSet |
   sed 's/ 20/ /' >> WANT
echo original >> WANT
echo $OLD >> WANT
cmpfiles GOT WANT
echo OK

# Test inherit of a time zone (this is single user, so no user or host)
# Remove item contain TZ info, and it should get propogated.
echo $N Timezone inherit test .......................................$NL
cd "$HERE"
rm -rf host_inh
bk clone $Q simple host_inh
cd host_inh
bk edit $Q a
bk delta $Q -fy1.2 a
TZ=UTC+0 bk commit $Q -y1.3
bk edit $Q b
bk delta $Q -fy1.2 b
TZ=UTC+0 bk commit $Q -y1.4
bk csetprune < ../KEYS 2> ERROR
if [ $? -ne 0 ]; then echo Failed; cat ERROR; exit 1; fi
zone=`bk prs -h -r+ -d':TZ:\n' ChangeSet`
if [ "$zone" != "+00:00" ]; then echo Failed; echo Zone:$zone; exit 1; fi
echo OK

# Tags don't go away, they just move to valid ancestor
echo $N Test tag graph ..............................................$NL
cd "$HERE"
rm -rf tag
bk clone $Q simple tag
cd tag
bk edit $Q a
bk delta $Q -fy1.2 a
bk commit $Q -STAG1_3 -y1.3
bk edit $Q a
bk delta $Q -fy1.3 a
bk commit $Q -y1.4
bk tag $Q TAG1_4
bk edit $Q b
bk delta $Q -fy1.2 b
bk commit $Q -STAG1_5 -y1.5
bk tag $Q TAG1_6
bk csetprune < ../KEYS 2> ERROR
if [ $? -ne 0 ]; then echo Failed; cat ERROR; exit 1; fi
tip=`bk prs -h -rTAG1_3 -d':I:\n' ChangeSet`
if [ "$tip" != 1.2 ]; then echo Failed; exit 1; fi
tip=`bk prs -h -rTAG1_4 -d':I:\n' ChangeSet`
if [ "$tip" != 1.2 ]; then echo Failed; exit 1; fi
tip=`bk prs -h -rTAG1_5 -d':I:\n' ChangeSet`
if [ "$tip" != 1.3 ]; then echo Failed; exit 1; fi
tip=`bk prs -h -rTAG1_6 -d':I:\n' ChangeSet`
if [ "$tip" != 1.3 ]; then echo Failed; exit 1; fi
echo OK

# Used to be a bug where same name in R and D caused an assert
echo $N Test duplicates collapsing on to already tagged delta .......$NL
cd "$HERE"
rm -rf tagdup
bk clone $Q simple tagdup
cd tagdup
bk edit $Q b
bk delta $Q -fy1.2 b
bk commit $Q -STAGDUP -y1.3
bk edit $Q a
bk delta $Q -fy1.2 a
bk commit $Q -y1.4
bk tag $Q TAGDUP
bk csetprune < ../KEYS 2> ERROR
if [ $? -ne 0 ]; then echo Failed; cat ERROR; exit 1; fi
echo OK

echo $N Tag graph rewiring test: fork, merge, collapse, leaf ........$NL
cd "$HERE"
rm -rf tag_a, tag_b, tag_c
bk clone $Q simple tag_a
bk clone $Q simple tag_b
cd "$HERE/tag_b"
bk tag $Q -r1.1 OLDEST-OLD
bk edit $Q b
bk delta $Q -fy1.2 b
bk commit $Q -STAG_B1 -y"Tagged node on trunk"
cd "$HERE/tag_a"
bk edit $Q b
bk delta $Q -fy1.2 b
bk commit $Q -STAG_A1 -y"Tagged node before fork on branch"
bk edit $Q b
bk delta $Q -fy1.2 b
bk commit $Q -y"nothing node"
cd "$HERE"
bk clone $Q tag_a tag_c
cd "$HERE/tag_a"
bk edit $Q b
bk delta $Q -fy1.2 b
bk commit $Q -y"node on trunk of branch with no label"
cd "$HERE/tag_c"
bk edit $Q b
bk delta $Q -fy1.2 b
bk commit $Q -STAG_C1 -y"Tagged node on branch of branch"
cd "$HERE/tag_b"
bk edit $Q b
bk delta $Q -fy1.2 b
bk commit $Q -STAG_B2 -y"Tagged node on trunk"
cd "$HERE/tag_c"
bk edit $Q b
bk delta $Q -fy1.2 b
bk commit $Q -STAG_C2 -y"Tagged node on branch of branch (again)"
bk pull $Q -t "$HERE/tag_a"
bk edit $Q b
bk delta $Q -fy1.2 b
bk commit $Q -STAG_C3 -y"Tagged node on branch after merge"
bk pull $Q -t "$HERE/tag_b"
bk edit $Q a
bk delta $Q -fy1.2 a
bk commit $Q -y"tip to be deleted"
bk tag $Q -r1.1 OLDEST-NEW
bk csetprune < ../KEYS 2> ERROR
if [ $? -ne 0 ]; then echo Failed; cat ERROR; exit 1; fi
tip=`bk prs -h -rOLDEST-OLD -d':I:\n' ChangeSet`
if [ "$tip" != 1.1 ]; then echo Failed; exit 1; fi
tip=`bk prs -h -rOLDEST-NEW -d':I:\n' ChangeSet`
if [ "$tip" != 1.1 ]; then echo Failed; exit 1; fi
cd "$HERE"
bk clone $Q -rTAG_B2 tag_c tag_clone 2> ERROR
if [ $? -ne 0 ]; then echo Failed; cat ERROR; exit 1; fi
echo OK

# have tip change 'b' and remove 'a' and check for tip reparented
echo $N Reparent tip ................................................$NL
cd "$HERE"
rm -rf remove
bk clone $Q simple remove
cd remove
bk edit $Q a
bk delta $Q -fy1.2 a
bk commit $Q -y1.3
bk edit $Q b
bk delta $Q -fy1.2 b
bk commit $Q -y1.4
key=`bk prs -h -r+ -d':KEY:\n' ChangeSet | sed 's/\(.*\)|.*/\1/'`
bk csetprune < ../KEYS 2> ERROR
if [ $? -ne 0 ]; then echo Failed; cat ERROR; exit 1; fi
par=`bk prs -h -r+ -d':PARENT:\n' ChangeSet`
newkey=`bk prs -h -r+ -d':KEY:\n' ChangeSet | sed 's/\(.*\)|.*/\1/'`
if [ "$key" != "$newkey" ]; then echo Failed:key; echo $key $newkey; exit 1; fi
if [ "$par" != 1.2 ]; then echo Failed:par; echo $par; exit 1; fi
echo OK

# diamond tests: make a change on the branch and trunk and bring them
# together and do a strip.
# The 4 tests are:
#   strip both branch and trunk; strip branch; strip trunk; strip none

echo $N Merge: no change left on parent and branch ..................$NL
cd "$HERE"
rm -rf merge copy
bk clone $Q simple merge
bk clone $Q merge copy

cd merge
bk edit $Q a
bk delta $Q -fy1.2 a
bk commit $Q -y1.3

cd ../copy
bk edit $Q c
bk delta $Q -fy1.2 c
bk commit $Q -y1.3

bk pull $Q
tip=`bk prs -h -r+ -d':I:\n' ChangeSet`
bk csetprune < ../KEYS 2> ERROR
if [ $? -ne 0 ]; then echo Failed; cat ERROR; exit 1; fi
new=`bk prs -h -r+ -d':I:\n' ChangeSet`
if [ "$tip" != "1.4" ]; then echo Failed:old; echo $tip; exit 1; fi
if [ "$new" != 1.2 ]; then echo Failed:new; echo $new; exit 1; fi
echo OK

echo $N Merge: no change left on parent, change on branch ...........$NL
cd "$HERE"
rm -rf merge_m copy_m
bk clone $Q simple merge_m
bk clone $Q merge_m copy_m

cd merge_m
bk edit $Q a
bk delta $Q -fy1.2 a
bk commit $Q -y1.3

cd ../copy_m
bk edit $Q b
bk delta $Q -fy1.2 b
bk commit $Q -y1.3
key=`bk prs -h -r+ -d':KEY:\n' ChangeSet | sed 's/\(.*\)|.*/\1/'`

bk pull $Q
bk csetprune < ../KEYS 2> ERROR
if [ $? -ne 0 ]; then echo Failed; cat ERROR; exit 1; fi
newkey=`bk prs -h -r+ -d':KEY:\n' ChangeSet | sed 's/\(.*\)|.*/\1/'`
if [ "$key" != "$newkey" ]; then echo Failed; echo $key $newkey; exit 1; fi
echo OK

echo $N Merge: no change left on branch, change on parent ...........$NL
cd "$HERE"
rm -rf merge_p copy_p
bk clone $Q simple merge_p
bk clone $Q merge_p copy_p

cd merge_p
bk edit $Q b
bk delta $Q -fy1.2 b
bk commit $Q -y1.3
key=`bk prs -h -r+ -d':KEY:\n' ChangeSet | sed 's/\(.*\)|.*/\1/'`

cd ../copy_p
bk edit $Q a
bk delta $Q -fy1.2 a
bk commit $Q -y1.3

bk pull $Q
bk csetprune < ../KEYS 2> ERROR
if [ $? -ne 0 ]; then echo Failed; cat ERROR; exit 1; fi
newkey=`bk prs -h -r+ -d':KEY:\n' ChangeSet | sed 's/\(.*\)|.*/\1/'`
if [ "$key" != "$newkey" ]; then echo Failed; echo $key $newkey; exit 1; fi
echo OK

echo $N Merge: change on branch and parent ..........................$NL
cd "$HERE"
rm -rf merge_pb copy_pb
bk clone $Q simple merge_pb
bk clone $Q merge_pb copy_pb

cd merge_pb
bk edit $Q b
bk delta $Q -fy1.2 b
bk commit $Q -y1.3

cd ../copy_pb
bk edit $Q d
bk delta $Q -fy1.2 d
bk commit $Q -y1.3

bk pull $Q
key=`bk prs -h -r+ -d':KEY:\n' ChangeSet | sed 's/\(.*\)|.*/\1/'`
bk csetprune < ../KEYS 2> ERROR
if [ $? -ne 0 ]; then echo Failed; cat ERROR; exit 1; fi
newkey=`bk prs -h -r+ -d':KEY:\n' ChangeSet | sed 's/\(.*\)|.*/\1/'`
if [ "$key" != "$newkey" ]; then echo Failed; echo $key $newkey; exit 1; fi
echo OK

# Test a merge containing a merge for the recalculation of -i
# This is done by setting up a merge where the branch delta is a merge
# If the branch merge gets collapsed because of no change on the trunk side
# And that is merged with the real trunk which does have a change, then
# the include needs to be recalculated because the original branch on a
# branch delta was included into the tip by a recursive include.
echo $N Merge: merge on a merge: includes recalculated ..............$NL
cd "$HERE"
rm -rf merge_mm copy_mm copy2_mm
bk clone $Q simple merge_mm
bk clone $Q merge_mm copy_mm
bk clone $Q copy_mm copy2_mm

cd copy2_mm
bk edit $Q b
bk delta $Q -fy1.2 b
bk commit $Q -y1.3

cd ../copy_mm
bk edit $Q a
bk delta $Q -fy1.2 a
bk commit $Q -y1.3

cd ../merge_mm
bk edit $Q d
bk delta $Q -fy1.2 d
bk commit $Q -y1.3

cd ../copy_mm
bk pull $Q

cd ../copy2_mm
bk pull $Q
bk csetprune < ../KEYS 2> ERROR
if [ $? -ne 0 ]; then echo Failed; cat ERROR; exit 1; fi
inc=`bk prs -h -r+ '-d:DI:\n' ChangeSet`
if [ "$inc" != "+5" ]; then echo Failed; echo $inc; exit 1; fi
echo OK

# Test a code corner case where the delta being searched for is a merge tip
echo $N Merge: test a corner case: search delta is merge tip.........$NL
cd "$HERE"
rm -rf corner copy_corner
bk clone $Q simple corner
bk clone $Q corner copy_corner

cd copy_corner
bk edit $Q b
bk delta $Q -fy1.2 b
bk commit $Q -y1.3

cd ../corner
bk edit $Q d
bk delta $Q -fy1.2 d
bk commit $Q -y1.3

cd ../copy_corner
bk pull $Q
key=`bk prs -h -r+ -d':KEY:\n' ChangeSet | sed 's/\(.*\)|.*/\1/'`

cd ../corner
bk edit $Q a
bk delta $Q -fy1.2 a
bk commit $Q -y1.4

cd ../copy_corner
bk pull $Q
bk csetprune < ../KEYS 2> ERROR
if [ $? -ne 0 ]; then echo Failed; cat ERROR; exit 1; fi
newkey=`bk prs -h -r+ -d':KEY:\n' ChangeSet | sed 's/\(.*\)|.*/\1/'`
if [ "$key" != "$newkey" ]; then echo Failed; echo $key $newkey; exit 1; fi
echo OK

# Test a renumber condition: leave tip on branch
echo $N Renumber: test when prune leaves a tip on branch ............$NL
cd "$HERE"
rm -rf renum copy_renum
bk clone $Q simple renum
bk clone $Q renum copy_renum

cd copy_renum
bk edit $Q a
bk delta $Q -fy1.2 a
bk commit $Q -y1.3

cd ../renum
bk edit $Q b
bk delta $Q -fy1.2 b
bk commit $Q -y1.3

cd ../copy_renum
bk edit $Q d
bk delta $Q -fy1.2 d
bk commit $Q -y1.4
bk pull $Q
bk csetprune < ../KEYS 2> ERROR
if [ $? -ne 0 ]; then echo Failed; cat ERROR; exit 1; fi
rev=`bk prs -h -r+ -d':I:\n' ChangeSet`
if [ "$rev" != "1.4" ]; then echo Failed; echo Rev:$rev; exit 1; fi
echo OK

echo $N Remove all files - which should leave BK files alone ........$NL
cd "$HERE"
rm -rf pruneall
bk clone $Q simple pruneall
cd pruneall
bk -r prs -hr+ -nd:ROOTKEY: > ../ALLKEYS
bk csetprune < ../ALLKEYS 2> ERROR
if [ $? -ne 0 ]; then echo Failed; cat ERROR; exit 1; fi
echo OK

# Try leaving tag graph structure alone
echo $N Keep tag graph structure ....................................$NL
cd "$HERE"
rm -rf kg1
bk clone $Q simple kg1
cd kg1
bk edit $Q a
bk delta $Q -fy1.2 a
bk commit $Q -SKG1A -y1.3
bk edit $Q a
bk delta $Q -fy1.3 a
bk commit $Q -SKG1B -y1.4
bk cset $Q -x1.4
bk tag $Q KG1C
bk csetprune -S < ../KEYS 2> ERROR
if [ $? -ne 0 ]; then echo Failed; cat ERROR; exit 1; fi
tip=`bk prs -rKG1A -hnd':I:' ChangeSet`
if [ "$tip" != 1.2 ]; then echo Failed; exit 1; fi
tip=`bk prs -rKG1B -hnd':I:' ChangeSet`
if [ "$tip" != 1.2 ]; then echo Failed; exit 1; fi
tip=`bk prs -rKG1C -hnd':I:' ChangeSet`
if [ "$tip" != 1.2 ]; then echo Failed; exit 1; fi
echo OK

# Test specifying the package root
echo $N Specify random bits to use in new package root key ..........$NL
cd "$HERE"
rm -rf ranbit
bk clone $Q simple ranbit
cd ranbit
bk edit $Q a
bk delta $Q -fy1.2 a
bk commit $Q -SKG2A -y1.3
# Test for invalid keys not working ..
bk csetprune -k 12345 < ../KEYS 2> ERROR && {
	echo Failed
	echo Key must be 16 chars: worked with 12345
	exit 1
}
bk csetprune -k 1234567890abcdeg < ../KEYS 2> ERROR && {
	echo Failed
	echo Must be hex characters: worked with 'g'
	exit 1
}
bk csetprune -k 1234567890abcdeF < ../KEYS 2> ERROR && {
	echo Failed
	echo Hex characters must be lower case: worked with 'F'
	exit 1
}
RDOM="1234567890abcdef"
bk csetprune -k "$RDOM" < ../KEYS 2> ERROR
if [ $? -ne 0 ]; then echo Failed; cat ERROR; exit 1; fi
rbits=`bk prs -r+ -hnd':RANDOM:' ChangeSet`
test "$rbits" = "$RDOM" || {
	echo Failed
	echo "RANDOM bits in rootkey: wanted '$RDOM', got '$rbits'"
	exit 1
}
echo OK

cores

# Done
