# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Copyright (c) 1999 Larry McVoy
# %K%

commercial project
echo $N Make sure delta -i works ....................................$NL
echo hi there > init
bk delta $S -i init
if [ ! -f SCCS/s.init ]; then echo Failed to create s.file; exit 1; fi
echo OK

echo $N Make sure delta -i works with a c.file ......................$NL
echo hi there > comments
echo BitKeeper rocks > SCCS/c.comments
bk delta $S -i comments
test "BitKeeper rocks" = "`bk prs -hr+ -nd:C: comments`" || {
	echo failed
	bk prs -r1.0.. comments
	exit 1
}
echo OK

echo $N Check delta -i works w/ existing file .......................$NL
echo hi there again > init
bk delta -i init 2> delta.out
if [ $? -eq 0 ]; then echo Failed; exit 1; fi
grep -q "s.init already exists" delta.out
if [ $? -ne 0 ]; then echo Failed; exit 1; fi
if [ -f SCCS/z.init ]; then echo Failed, fail to clean zlock; exit 1; fi
rm -f init
echo OK

echo $N Make sure delta -l works ....................................$NL
cp SCCS/s.init SCCS/s.T
X=`wc -c < SCCS/s.T`
bk get $S -e T
if writable T; then :; else echo Get failed to get file writeable; exit 1; fi
bk delta $S -ly T
if [ "`wc -c < SCCS/s.T`" = "$X" ]; then echo Failed to create delta; exit 1; fi
if [ ! -f SCCS/p.T ]; then echo Failed to leave file locked; exit 1; fi
if [ ! -f T ]; then echo Failed to get file; exit 1; fi
if writable T; then :; else echo Failed to leave file writeable; exit 1; fi
echo OK

echo $N Make sure delta -il works ...................................$NL
echo delta -il > init2
bk delta $S -il init2
if [ ! -f SCCS/s.init2 ]; then echo failed to create file; exit 1; fi
if [ ! -f SCCS/p.init2 ]; then echo failed to lock file; exit 1; fi
bk clean init2
echo OK

rm -f SCCS/p.T T
echo $N Make sure delta -I works with good file .....................$NL
cat > INITX <<EOF
D 1.1 97/05/28 23:49:57 joe_user@joes_hostname 0 0 0/0/0
c This is revision 1.1
P this/is/the/pathname
------------------------------------------------
EOF
ls > init_test
bk delta $Q -i -IINITX init_test
if [ $? != 0 ]; then echo Failed - delta returned an error; exit 1; fi
grep -q '^.c This is revision 1.1$' SCCS/s.init_test
if [ $? -ne 0 ]; then echo Failed to add comment; exit 1; fi
grep -q '^.cPthis/is/the/pathname$' SCCS/s.init_test
if [ $? -ne 0 ]; then echo Failed to add path; exit 1; fi
echo OK

echo $N Make sure delta -I fails with bad file ......................$NL
ls > INITX
bk co -l $Q init_test
ls >> init_test
bk delta $Q -IINITX init_test 2>OUT && {
	echo Failed - delta did not error
	echo =============== INIT file ===================
	cat INITX
	echo =============== Output ===================
	cat OUT
	exit 1
}
echo OK

echo $N Make sure delta -I works w/ blank comments ..................$NL
cat > INITX <<EOF
D 1.2 97/05/28 23:49:57 joe_user@joes_hostname 0 0 0/0/0
c This is revision 1.2
c
c This is the line after the blank line.
------------------------------------------------
EOF
bk delta $Q -IINITX init_test
if [ $? != 0 ]; then echo Failed - delta returned an error; exit 1; fi
grep -q '^.c This is revision 1.2$' SCCS/s.init_test
if [ $? -ne 0 ]; then echo Failed to add comment; exit 1; fi
grep -q '^.c $' SCCS/s.init_test
if [ $? -ne 0 ]; then echo Failed to add blank comment line.; exit 1; fi
grep -q '^.c This is the line after the blank line.$' SCCS/s.init_test
if [ $? -ne 0 ]; then echo Failed to add last line in comment; exit 1; fi
echo OK

#echo $N Make sure delta -n works ....................................$NL
#bk get $S -e T
#bk delta $S -ny T
#if [ ! -f T ]; then echo Failed to save file; exit 1; fi
#if writable T; then :; else echo Failed to save file writeable; exit 1; fi
#echo OK
echo $N Make sure delta prompts for comments ........................$NL
rm -f T
bk get $S -e T
echo "I am the comment" | bk delta $S T 2> ${DEV_NULL}
grep -q '^.c I am the comment$' SCCS/s.T
if [ $? -ne 0 ]; then echo Failed to add comment; exit 1; fi
echo OK

echo $N Make sure delta prompts once with -Y ........................$NL
bk get $S -e T
bk get $S -e init
(echo "first comment"; echo ".";
echo "second comment"; echo ".") | bk delta $S -Y 2>${DEV_NULL}
grep -q '^.c first comment$' SCCS/s.T
if [ $? -ne 0 ]; then echo Failed to add first comment to T; exit 1; fi
grep -q '^.c first comment$' SCCS/s.init
if [ $? -ne 0 ]; then echo Failed to add first comment to init; exit 1; fi
grep -q '^.c second comment$' SCCS/s.T
if [ $? -eq 0 ]; then echo Added unwanted second comment to T; exit 1; fi
grep -q '^.c second comment$' SCCS/s.init
if [ $? -eq 0 ]; then echo Added unwanted second comment to init; exit 1; fi
echo OK

echo $N Make sure ci -u with no change works ........................$NL
bk get $S -e init2
bk ci $Q -u init2 2> ${DEV_NULL}
if [ ! -f init2 ]; then echo File not checked out.; exit 1; fi
if writable init2; then echo File not read only.; exit 1; fi
echo OK


echo $N Make sure delta -G works ....................................$NL
# Figure out which kind of touch we have
echo "G change data" > init3
touch -t 0102030489 init3 > ${DEV_NULL} 2>&1
test "`bk mtime init3`" != "1989/01/02 03:04:00" && {
	touch -t 8901020304.00 init3 > ${DEV_NULL} 2>&1
}
bk mtime init3 > CMP1
bk delta $Q -i -G init3
bk prs -Y -h -d':D: :T:\n' init3 > CMP2
cmp -s CMP1 CMP2
if [ $? -ne 0 ]; then echo Failed.; diff CMP1 CMP2; exit 1; fi
echo OK


echo $N Make sure delta -a new file work ............................$NL
mkdir A
echo "echo this is a new file" > A/data
bk sfiles -x A | bk delta $Q -a -l -y"new file" -
REV=`bk prs -r+ -hd:I: A/data`
if [ ${REV}X != "1.1"X ]; then echo failed; exit 1; fi
echo OK

echo $N Make sure delta -a unchanged file work ......................$NL
bk sfiles A | bk delta $Q -a -l -y"unchanged file" -
REV=`bk prs -r+ -hd:I: A/data`
if [ ${REV}X != "1.1"X ]; then echo failed; exit 1; fi
echo OK

echo $N Make sure delta -a changed file work ........................$NL
echo fff > A/bar
bk new $Q A/bar
bk edit $Q A/bar
echo fff >> A/bar
echo "echo this is changed file" > A/data
bk sfiles A | bk delta $Q -l -a -y"changed file
with newline" -
REV=`bk prs -r+ -hd:I: A/data`
if [ ${REV}X != "1.2"X ]; then echo failed $REV; exit 1; fi
echo OK

echo $N Make sure delta -y can have newlines ........................$NL
bk prs -r+ A/data | grep 'with newline' > /dev/null
if [ $? -ne 0 ]; then echo failed; exit 1; fi
echo OK

if [ "$PLATFORM" = "UNIX" ]
then #-----------------------------------------------------------------
echo $N Make sure delta -a symlink dir works ........................$NL
mkdir A/dir
ln -s A/dir A/symdir
bk sfiles -x A | bk delta $Q -a -l -y"new symlink dir" -
REV=`bk prs -r+ -hd:I: A/symdir`
if [ ${REV}X != "1.1"X ]; then echo failed; exit 1; fi
echo OK

fi #--------------------------------------------------------------------
echo $N Make sure delta -i does not check in ........................$NL
mkdir garbage; cd garbage; touch a b c d e s.c s.f
bk delta $Q -i
if [ -d "SCCS" ]; then	echo failed - it did check stuff in; exit 1; fi
echo OK

echo $N Make sure ci -i does not check in ...........................$NL
bk ci $Q -i
if [ -d "SCCS" ]; then	echo failed - it did check stuff in; exit 1; fi
echo OK

echo $N Make sure delta -i a b c d does check in ....................$NL
bk delta $Q -i a b c d e
if [ ! -d "SCCS" ]; then	echo failed; exit 1; fi
echo OK

if [ $PLATFORM = "WIN32" ]
then #-------------------------------------------------------------
echo $N Make sure delta uses the real name of the sfile .............$NL
cd ../A
bk clean data
bk edit $Q data
rm -f data
echo new > DATA
bk delta $Q -ychk_path ../a/DATA
bk prs -h -r+ -d':DPN:\n' DATA | grep -q "A/data\$"
if [ $? -ne 0 ]; then echo failed; exit 1; fi
bk prs -h -r+ -d':DPN:\n' DATA | grep -q "A/DATA\$"
if [ $? -eq 0 ]; then echo failed; exit 1; fi
echo OK

fi #---------------------------------------------------------------
cd ..
rm -rf A garbage
echo $N Make sure delta works with checkout:edit preference .........$NL
cd $HERE
rm -rf project
commercial project
BK_USER=one; BK_HOST=one.com.bk_regression.bk
export BK_USER BK_HOST
cd $HERE/project
echo hi > hi.c
bk ci $Q -i hi.c
if [ -f SCCS/p.hi.c ]; then echo failed; exit 1; fi
bk edit $Q BitKeeper/etc/config
cp BitKeeper/etc/config config.sav
bk co $Q -l hi.c
for i in "" "one" "one@$BK_HOST" "one@$BK_HOST:$HERE/project" \
	"@$BK_HOST" "@$BK_HOST:$HERE/project" \
	":$HERE/project" "one:$HERE/project" 
do
	cp config.sav BitKeeper/etc/config
	echo "[${i}]checkout:edit" >> BitKeeper/etc/config
	echo hello > hi.c
	bk delta $Q -yhello hi.c
	if [ $? -ne 0 ]; then echo failed; exit 1; fi
	if [ ! -f SCCS/p.hi.c ]; then echo failed; exit 1; fi
	if [ ! -f hi.c ]; then echo failed; exit 1; fi
	writable hi.c || { echo failed; exit 1; }
done
echo OK

echo $N Make sure ci -i works with checkout:edit preference .........$NL
cp config.sav BitKeeper/etc/config
echo "checkout:edit" >> BitKeeper/etc/config
echo lo > lo.c
chmod -w lo.c
bk ci $Q -i lo.c
if [ $? -ne 0 ]; then echo failed; exit 1; fi
if [ ! -f SCCS/p.lo.c ]; then echo failed; exit 1; fi
if [ ! -f lo.c ]; then echo failed; exit 1; fi
writable lo.c || { echo failed; exit 1; }
echo OK

echo $N Make sure ci -i works with checkout:get preference ..........$NL
cp config.sav BitKeeper/etc/config
echo "checkout:get" >> BitKeeper/etc/config
echo mid > mid.c
echo low > low.c
bk sfiles -x mid.c low.c | bk ci $Q -i -
if [ ! -f mid.c ]; then echo failed; exit 1; fi
if [ -f SCCS/p.mid.c ]; then echo failed; exit 1; fi
if writable mid.c; then echo failed; exit 1; fi
if [ ! -f low.c ]; then echo failed; exit 1; fi
if [ -f SCCS/p.low.c ]; then echo failed; exit 1; fi
if writable low.c; then echo failed; exit 1; fi
echo OK

echo $N Make sure ci works with checkout:get preference .............$NL
bk edit $Q low.c mid.c
echo mid2 > mid.c
echo low2 > low.c
bk sfiles -c mid.c low.c | bk ci $Q -ynew -
if [ ! -f mid.c ]; then echo failed; exit 1; fi
if [ -f SCCS/p.mid.c ]; then echo failed; exit 1; fi
if writable mid.c; then echo failed; exit 1; fi
if [ ! -f low.c ]; then echo failed; exit 1; fi
if [ -f SCCS/p.low.c ]; then echo failed; exit 1; fi
if writable low.c; then echo failed; exit 1; fi
echo OK

echo $N Make sure checkout:GET preserve modtime if no keyword .......$NL
cp config.sav BitKeeper/etc/config
echo "checkout:GET" >> BitKeeper/etc/config
bk admin -FSCCS mid.c 
bk edit $Q mid.c low.c
sleep 1
echo mid3 > mid.c
echo low3 > low.c
bk sfiles -c mid.c low.c | bk ci $Q -G -ynew3 -
if [ ! -f mid.c ]; then echo failed; exit 1; fi
if [ -f SCCS/p.mid.c ]; then echo failed; exit 1; fi
if writable mid.c; then echo failed; exit 1; fi
if [ ! -f low.c ]; then echo failed; exit 1; fi
if [ -f SCCS/p.low.c ]; then echo failed; exit 1; fi
if writable low.c; then echo failed; exit 1; fi
find . -newer mid.c | grep -q ./SCCS/s.mid.c
if [ $? -eq 0 ]; then echo failed; exit 1; fi
echo OK

echo $N Make sure "bk new -b" forces binary encoding for text file ....$NL
echo "this is text" > text
bk new $Q -b text
ENC=`bk prs -hr+ -d:ENC: text`
if [ "$ENC" != "binary" ]; then echo failed; exit 1; fi
echo OK;


echo $N Small ascii files with nulls should be caught ...............$NL
echo baseline > baseline
bk new $Q baseline
bk edit $Q baseline
echo 'There is a null right here X>' | tr X '\000' >> baseline
echo "" >> baseline
echo and another line after that >> baseline
bk delta -q -yfail baseline 2>OUT && {
	echo failed to error
	exit 1
}
grep -q 'file format is ascii, delta is binary' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK


echo $N Large ascii files with nulls should be caught ...............$NL
cat >tmp <<EOF
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
EOF
cat tmp tmp tmp tmp tmp tmp tmp tmp tmp tmp > tmp10
cat tmp10 tmp10 > big
rm -f tmp10
bk new $Q big
bk edit $Q big
echo 'There is a null right here X>' | tr X '\000' >> big
echo "" >> big
echo and another line after that >> big
bk delta -q -yfail big 2>OUT && {
	echo failed to error
	exit 1
}
grep -q 'big has nulls' OUT || grep -q 'delta is binary' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK

echo $N Make sure we disallow .bk_skip file  .........................$NL
touch .bk_skip
bk new .bk_skip 2> new.out
if [ $? -eq 0 ]; then echo failed; exit 1; fi
grep -q "not allowed" new.out
if [ $? -ne 0 ]; then echo failed 2; exit 1; fi
echo OK

echo $N Check compresssion: gzip preference .........................$NL
cd $HERE/project/BitKeeper/etc
bk edit $Q config
echo "compression: gzip" >> config
cd $HERE/project
echo hi > init2
bk new $Q init2
bk compression init2 | grep -q "gzip"
if  [ $? -ne 0 ]; then echo failed; exit 1; fi
echo OK

echo $N Check compresssion: none preference .........................$NL
cd $HERE/project/BitKeeper/etc
bk edit $Q config
sed -e's/^compression: gzip/compression: none/' < config > config.tmp
mv config.tmp config
cd $HERE/project
echo hi > init3
bk new $Q init3
bk compression init3 | grep -q "none"
if  [ $? -ne 0 ]; then echo failed; exit 1; fi
echo OK

echo $N Check that bad p.file revisions are caught and fixed ........$NL
cd $HERE/project
bk edit $Q init3
mv SCCS/p.init3 P
sed s/1.2/1.1/ < P > SCCS/p.init3
bk delta $Q -ybad init3 > OUT 2>&1 || exit 1
grep -q 'invalid nextrev 1.1 in p.file, using 1.2 instead' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
test 1.2 = `bk prs -hr+ -nd:I: init3` || {
	echo failed to override bad revision in p.file
	bk prs init3
	exit 1
}
echo OK

echo $N Check that delta picks up comments from c.files, -C case ....$NL
cd $HERE/project
bk edit $Q init3
( echo "Auto comment from c.file"
  echo "And a second line" 
 ) > SCCS/c.init3
cp SCCS/c.init3 C
bk delta -qC init3 > OUT 2>&1 < /dev/null || exit 1
test -f SCCS/p.init3 && {
	echo failed to delta
	exit 1
}
bk prs -hr+ -d'$each(:C:){(:C:)\n}' init3 > C2
cmp -s C C2 || {
	echo failed to set comment
	bk prs init3
	diff C C2
	exit 1
}
test -f SCCS/c.init3 && {
	echo failed to clean up the c.file
	exit 1
}
test -s OUT && {
	echo should not have produced output
	cat OUT
	exit 1
}
echo OK

echo $N Make sure delta prompts and allows aborts from c.files ......$NL
cd $HERE/project
bk edit $Q init3
( echo "Auto comment from c.file"
  echo "And a second line" 
 ) > SCCS/c.init3
cp SCCS/c.init3 C
echo a | bk delta $Q init3 > OUT 2>&1
test -f SCCS/c.init3 || {
	echo deleted c.file
	exit 1
}
grep -q 'And a second line' SCCS/c.init3 || {
	echo screwed up contents
	cat SCCS/c.init3
	exit 1
}
echo OK

echo $N Make sure delta prompts and works 2nd time around ...........$NL
cd $HERE/project
bk edit $Q init3
( echo "Auto comment from c.file"
  echo "And a second line" 
 ) > SCCS/c.init3
cp SCCS/c.init3 C
echo u | bk delta $Q init3 > OUT 2>&1 || exit 1
test -f SCCS/p.init3 && {
	echo failed to delta
	exit 1
}
bk prs -hr+ -d'$each(:C:){(:C:)\n}' init3 > C2
cmp -s C C2 || {
	echo failed to set comment
	bk prs init3
	diff C C2
	exit 1
}
test -f SCCS/c.init3 && {
	echo failed to clean up the c.file
	exit 1
}
echo OK

echo $N Make sure we split long comment lines with -YFILENAME .......$NL
cd $HERE/project
ls > LS
bk new $Q LS
for i in 0 1 2 3 4 5 6 7 8 9
do echo $N 1234567890$NL
done > 100
for i in 0 1 2 3 4 5 6 7 8 9
do cat 100
done > 1000
for i in 0 1 2 3 4 
do cat 1000
done > 5000
bk edit $Q LS
bk delta -Y5000 $Q LS 2>ERR
grep -q Splitting ERR || {
	echo bad diagnostics
	cat ERR
	exit 1
}
bk prs -hd'$each(:C:){(:C:)}' -r+ LS > Y
cmp -s Y 5000 || {
	echo failed
	diff Y 5000
	ls -l Y 5000
	exit 1
}
echo OK

echo $N Make sure we split a long comment line with -ylong_comment ..$NL
bk edit $Q LS
bk delta -y`cat 5000` $Q LS 2>ERR
grep -q Splitting ERR || {
	echo bad diagnostics
	cat ERR
	exit 1
}
bk prs -hd'$each(:C:){(:C:)}' -r+ LS > Y
cmp -s Y 5000 || {
	echo failed
	diff Y 5000
	ls -l Y 5000
	exit 1
}
echo OK

echo $N Make sure we split long comment lines with -ylong_comment ...$NL
bk edit $Q LS
( cat 5000
  echo ""
  cat 100
  echo ""
  cat 100
  echo ""
) > 3lines
bk delta -y"`cat 3lines`" $Q LS 2>ERR
grep -q Splitting ERR || {
	echo bad diagnostics
	cat ERR
	exit 1
}
cat 5000 100 100 > WANT
bk prs -hd'$each(:C:){(:C:)}' -r+ LS > GOT
cmp -s WANT GOT || {
	echo failed
	diff WANT GOT
	ls -l WANT GOT
	exit 1
}
echo OK

echo $N Check multiline command line comments .......................$NL
bk edit $Q LS
bk delta -y'line 1
line 2
line 3' $Q LS 2>ERR
bk undos > WANT <<EOF
line 1
line 2
line 3
EOF
bk prs -hd'$each(:C:){(:C:)\n}' -r+ LS > GOT
cmp -s WANT GOT || {
	echo failed
	diff WANT GOT
	ls -l WANT GOT
	exit 1
}
echo OK

echo $N Check 1020 char comment .....................................$NL
bk edit $Q LS
( cat 1000; echo $N 01234567890123456789$NL ) > 1020
bk delta -y`cat 1020` LS 2>ERR
grep -q Splitting ERR && {
	echo bad diagnostics
	cat ERR
	exit 1
}
bk prs -hd'$each(:C:){(:C:)}' -r+ LS > GOT
cmp -s 1020 GOT || {
	echo failed
	diff 1020 GOT
	ls -l 1020 GOT
	exit 1
}
echo OK

echo $N Check 2040 char comment .....................................$NL
bk edit $Q LS
cat 1020 1020 > 2040
bk delta -y`cat 2040` LS 2>ERR
grep -q Splitting ERR || {
	echo bad diagnostics
	cat ERR
	exit 1
}
bk prs -hd'$each(:C:){(:C:)}' -r+ LS > GOT
cmp -s 2040 GOT || {
	echo failed
	diff 2040 GOT
	ls -l 2040 GOT
	exit 1
}
echo OK
