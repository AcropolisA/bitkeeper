# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Copyright (c) 1999 Larry McVoy
# %K%

no_logging project
echo $N Make sure delta -i works ....................................$NL
echo hi there > init
bk delta $S -i init
if [ ! -f SCCS/s.init ]; then echo Failed to create s.file; exit 1; fi
echo OK
echo $N Check delta -i works w/ existing file .......................$NL
echo hi there again > init
bk delta -i init 2> delta.out
if [ $? -eq 0 ]; then echo Failed; exit 1; fi
grep -q "s.init already exists" delta.out
if [ $? -ne 0 ]; then echo Failed; exit 1; fi
if [ -f SCCS/z.init ]; then echo Failed, fail to clean zlock; exit 1; fi
rm -f init
echo OK
echo $N Make sure delta -l works ....................................$NL
cp SCCS/s.init SCCS/s.T
X=`wc SCCS/s.T`
bk get $S -e T
if writable T; then :; else echo Get failed to get file writeable; exit 1; fi
bk delta $S -ly T
if [ "`wc SCCS/s.T`" = "$X" ]; then echo Failed to create delta; exit 1; fi
if [ ! -f SCCS/p.T ]; then echo Failed to leave file locked; exit 1; fi
if [ ! -f T ]; then echo Failed to get file; exit 1; fi
if writable T; then :; else echo Failed to leave file writeable; exit 1; fi
echo OK
echo $N Make sure delta -il works ...................................$NL
echo delta -il > init2
bk delta $S -il init2
if [ ! -f SCCS/s.init2 ]; then echo failed to create file; exit 1; fi
if [ ! -f SCCS/p.init2 ]; then echo failed to lock file; exit 1; fi
bk clean init2
echo OK
rm -f SCCS/p.T T
echo $N Make sure delta -I works with good file .....................$NL
cat > INITX <<EOF
D 1.1 97/05/28 23:49:57 joe_user@joes_hostname 0 0 0/0/0
c This is revision 1.1
P this/is/the/pathname
------------------------------------------------
EOF
ls > init_test
bk delta $Q -i -IINITX init_test
if [ $? != 0 ]; then echo Failed - delta returned an error; exit 1; fi
grep -q '^.c This is revision 1.1$' SCCS/s.init_test
if [ $? -ne 0 ]; then echo Failed to add comment; exit 1; fi
grep -q '^.cPthis/is/the/pathname$' SCCS/s.init_test
if [ $? -ne 0 ]; then echo Failed to add path; exit 1; fi
echo OK
echo $N Make sure delta -I fails with bad file ......................$NL
ls > INITX
bk co -l $Q init_test
ls >> init_test
bk delta $Q -IINITX init_test 2>OUT && {
	echo Failed - delta did not error
	echo =============== INIT file ===================
	cat INITX
	echo =============== Output ===================
	cat OUT
	exit 1
}
echo OK
echo $N Make sure delta -I works w/ blank comments ..................$NL
cat > INITX <<EOF
D 1.2 97/05/28 23:49:57 joe_user@joes_hostname 0 0 0/0/0
c This is revision 1.2
c
c This is the line after the blank line.
------------------------------------------------
EOF
bk delta $Q -IINITX init_test
if [ $? != 0 ]; then echo Failed - delta returned an error; exit 1; fi
grep -q '^.c This is revision 1.2$' SCCS/s.init_test
if [ $? -ne 0 ]; then echo Failed to add comment; exit 1; fi
grep -q '^.c $' SCCS/s.init_test
if [ $? -ne 0 ]; then echo Failed to add blank comment line.; exit 1; fi
grep -q '^.c This is the line after the blank line.$' SCCS/s.init_test
if [ $? -ne 0 ]; then echo Failed to add last line in comment; exit 1; fi
echo OK
#echo $N Make sure delta -n works ....................................$NL
#bk get $S -e T
#bk delta $S -ny T
#if [ ! -f T ]; then echo Failed to save file; exit 1; fi
#if writable T; then :; else echo Failed to save file writeable; exit 1; fi
#echo OK
echo $N Make sure delta prompts for comments ........................$NL
rm -f T
bk get $S -e T
echo "I am the comment" | bk delta $S T 2> ${DEV_NULL}
grep -q '^.c I am the comment$' SCCS/s.T
if [ $? -ne 0 ]; then echo Failed to add comment; exit 1; fi
echo OK
echo $N Make sure delta prompts once with -Y ........................$NL
bk get $S -e T
bk get $S -e init
(echo "first comment"; echo ".";
echo "second comment"; echo ".") | bk delta $S -Y 2>${DEV_NULL}
grep -q '^.c first comment$' SCCS/s.T
if [ $? -ne 0 ]; then echo Failed to add first comment to T; exit 1; fi
grep -q '^.c first comment$' SCCS/s.init
if [ $? -ne 0 ]; then echo Failed to add first comment to init; exit 1; fi
grep -q '^.c second comment$' SCCS/s.T
if [ $? -eq 0 ]; then echo Added unwanted second comment to T; exit 1; fi
grep -q '^.c second comment$' SCCS/s.init
if [ $? -eq 0 ]; then echo Added unwanted second comment to init; exit 1; fi
echo OK
echo $N Make sure ci -u with no change works ........................$NL
bk get $S -e init2
bk ci $Q -u init2 2> ${DEV_NULL}
if [ ! -f init2 ]; then echo File not checked out.; exit 1; fi
if writable init2; then echo File not read only.; exit 1; fi
echo OK
echo $N Make sure delta -G works ....................................$NL
# Figure out which kind of touch we have
echo "G change data" > init3
touch -t 0102030489 init3 > ${DEV_NULL} 2>&1
TOUCH=NO
if [ `bk mtime init3` != 1989-01-02-03:04:00 ]
then	touch -t 8901020304.00 init3 > ${DEV_NULL} 2>&1
	if [ `bk mtime init3` != 1989-01-02-03:04:00 ]
	then	echo Your touch command seems busted `bk mtime init3`
	else	TOUCH=YES
	fi
else	TOUCH=YES
fi
if [ $TOUCH = YES ]
then	bk delta $Q -i -G init3
	echo "89/01/02 03:04:00" > CMP1
	bk prs -h -d':D: :T:\n' init3 > CMP2
	# on NT, cygwin added 02 seconds
	case X`uname -s` in
	    XCYGWIN*)	sed -e"s/:02$/:00/" CMP2 >  CMPX
			sed -e"s/ 04:04:/ 03:04:/" CMPX > CMP2
		;;
	esac
	cmp -s CMP1 CMP2
	if [ $? -ne 0 ]; then echo Failed.; diff CMP1 CMP2; exit 1; fi
	#
	# XXX - commented out until awc fixes this to be portable.
	#get $Q -T init3
	# There is a bug in cygwin (version B20) ls/timezone code;
	# It is off by one hour when we are in daylight saving time.
	#ls -l --full-time init3 | awk '{print $9}' > CMP1
	#prs -hr1.1 -d:T: init3 > CMP2
	#case X`uname -s` in
	#    XCYGWIN*)	sed -e"s/^04:/03:/" CMP2 > CMPX
	#		mv CMPX CMP2
	#		sed -e"s/^04:/03:/" CMP1 > CMPX
	#		mv CMPX CMP1
	#	;;
	#	*)
	#	;;
	#esac
	#cmp -s CMP1 CMP2
	#if [ $? -ne 0 ]; then echo Failed.; diff CMP1 CMP2; cat -n CMP[12]; exit 1; fi
	echo OK
fi
echo $N Make sure delta -a new file work ............................$NL
mkdir A
echo "echo this is a new file" > A/data
bk sfiles -x A | bk delta $Q -a -l -y"new file" -
REV=`bk prs -r+ -hd:I: A/data`
if [ ${REV}X != "1.1"X ]; then echo failed; exit 1; fi
echo OK
echo $N Make sure delta -a unchanged file work ......................$NL
bk sfiles A | bk delta $Q -a -l -y"unchanged file" -
REV=`bk prs -r+ -hd:I: A/data`
if [ ${REV}X != "1.1"X ]; then echo failed; exit 1; fi
echo OK
echo $N Make sure delta -a changed file work ........................$NL
echo "echo this is changed file" > A/data
bk sfiles A | bk delta $Q -l -a -y"changed file" -
REV=`bk prs -r+ -hd:I: A/data`
if [ ${REV}X != "1.2"X ]; then echo failed $REV; exit 1; fi
echo OK
if [ "$PLATFORM" = "UNIX" ]
then #-----------------------------------------------------------------
echo $N Make sure delta -a symlink dir works ........................$NL
mkdir A/dir
ln -s A/dir A/symdir
bk sfiles -x A | bk delta $Q -a -l -y"new symlink dir" -
REV=`bk prs -r+ -hd:I: A/symdir`
if [ ${REV}X != "1.1"X ]; then echo failed; exit 1; fi
echo OK
fi #--------------------------------------------------------------------
echo $N Make sure delta -i does not check in ........................$NL
mkdir garbage; cd garbage; touch a b c d e s.c s.f
bk delta $Q -i
if [ -d "SCCS" ]; then	echo failed - it did check stuff in; exit 1; fi
echo OK
echo $N Make sure ci -i does not check in ...........................$NL
bk ci $Q -i
if [ -d "SCCS" ]; then	echo failed - it did check stuff in; exit 1; fi
echo OK
echo $N Make sure delta -i a b c d does check in ....................$NL
bk delta $Q -i a b c d e
if [ ! -d "SCCS" ]; then	echo failed; exit 1; fi
echo OK
if [ $PLATFORM = "WIN32" ]
then #-------------------------------------------------------------
echo $N Make sure delta uses the real name of the sfile .............$NL
cd ../A
bk clean data
bk edit $Q data
rm -f data
echo new > DATA
bk delta $Q -ychk_path ../a/DATA
bk prs -h -r+ -d':DPN:\n' DATA | grep -q "A/data\$"
if [ $? -ne 0 ]; then echo failed; exit 1; fi
bk prs -h -r+ -d':DPN:\n' DATA | grep -q "A/DATA\$"
if [ $? -eq 0 ]; then echo failed; exit 1; fi
echo OK
fi #---------------------------------------------------------------
cd ..
rm -rf A garbage
echo $N Make sure delta works with checkout:edit preference .........$NL
HERE=`bk pwd`
no_logging project
BK_USER=one; BK_HOST=one.com
export BK_USER BK_HOST
cd $HERE/project
echo hi > hi.c
bk ci $Q -i hi.c
if [ -f SCCS/p.hi.c ]; then echo failed; exit 1; fi
bk edit $Q BitKeeper/etc/config
cp BitKeeper/etc/config config.sav
bk co $Q -l hi.c
for i in "" "one" "one@one.com" "one@one.com:$HERE/project" \
	"@one.com" "@one.com:$HERE/project" \
	":$HERE/project" "one:$HERE/project" 
do
	cp config.sav BitKeeper/etc/config
	echo "[${i}]checkout:edit" >> BitKeeper/etc/config
	echo hello > hi.c
	bk delta $Q -yhello hi.c
	if [ $? -ne 0 ]; then echo failed; exit 1; fi
	if [ ! -f SCCS/p.hi.c ]; then echo failed; exit 1; fi
	if [ ! -f hi.c ]; then echo failed; exit 1; fi
	writable hi.c || { echo failed; exit 1; }
done
echo OK
echo $N Make sure ci -i works with checkout:edit preference .........$NL
cp config.sav BitKeeper/etc/config
echo "checkout:edit" >> BitKeeper/etc/config
echo lo > lo.c
chmod -w lo.c
bk ci $Q -i lo.c
if [ $? -ne 0 ]; then echo failed; exit 1; fi
if [ ! -f SCCS/p.lo.c ]; then echo failed; exit 1; fi
if [ ! -f lo.c ]; then echo failed; exit 1; fi
writable lo.c || { echo failed; exit 1; }
echo OK
echo $N Make sure ci -i works with checkout:get preference ..........$NL
cp config.sav BitKeeper/etc/config
echo "checkout:get" >> BitKeeper/etc/config
echo mid > mid.c
echo low > low.c
bk sfiles -x mid.c low.c | bk ci $Q -i -
if [ ! -f mid.c ]; then echo failed; exit 1; fi
if [ -f SCCS/p.mid.c ]; then echo failed; exit 1; fi
if writable mid.c; then echo failed; exit 1; fi
if [ ! -f low.c ]; then echo failed; exit 1; fi
if [ -f SCCS/p.low.c ]; then echo failed; exit 1; fi
if writable low.c; then echo failed; exit 1; fi
echo OK
echo $N Make sure ci works with checkout:get preference .............$NL
bk edit $Q low.c mid.c
echo mid2 > mid.c
echo low2 > low.c
bk sfiles -c mid.c low.c | bk ci $Q -ynew -
if [ ! -f mid.c ]; then echo failed; exit 1; fi
if [ -f SCCS/p.mid.c ]; then echo failed; exit 1; fi
if writable mid.c; then echo failed; exit 1; fi
if [ ! -f low.c ]; then echo failed; exit 1; fi
if [ -f SCCS/p.low.c ]; then echo failed; exit 1; fi
if writable low.c; then echo failed; exit 1; fi
echo OK
echo $N Make sure checkout:GET preserve modtime if no keyword .......$NL
cp config.sav BitKeeper/etc/config
echo "checkout:GET" >> BitKeeper/etc/config
bk admin -FSCCS mid.c 
bk edit $Q mid.c low.c
sleep 1
echo mid3 > mid.c
echo low3 > low.c
bk sfiles -c mid.c low.c | bk ci $Q -G -ynew3 -
if [ ! -f mid.c ]; then echo failed; exit 1; fi
if [ -f SCCS/p.mid.c ]; then echo failed; exit 1; fi
if writable mid.c; then echo failed; exit 1; fi
if [ ! -f low.c ]; then echo failed; exit 1; fi
if [ -f SCCS/p.low.c ]; then echo failed; exit 1; fi
if writable low.c; then echo failed; exit 1; fi
find . -newer mid.c | grep -q ./SCCS/s.mid.c
if [ $? -eq 0 ]; then echo failed; exit 1; fi
echo OK
echo $N Make sure "bk new -b" forces binary encoding for text file ....$NL
echo "this is text" > text
bk new $Q -b text
ENC=`bk prs -hr+ -d:ENC: text`
if [ "$ENC" != "binary" ]; then echo failed; exit 1; fi
echo OK;

echo $N Small ascii files with nulls should be caught ...............$NL
echo baseline > baseline
bk new $Q baseline
bk edit $Q baseline
echo 'There is a null right here X>' | tr X '\000' >> baseline
echo "" >> baseline
echo and another line after that >> baseline
bk delta -q -yfail baseline 2>OUT && {
	echo failed to error
	exit 1
}
grep -q 'file format is ascii, delta is binary' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK

echo $N Large ascii files with nulls should be caught ...............$NL
cat >tmp <<EOF
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
EOF
cat tmp tmp tmp tmp tmp tmp tmp tmp tmp tmp > tmp10
mv tmp10 tmp
cat tmp tmp > big
bk new $Q big
bk edit $Q big
echo 'There is a null right here X>' | tr X '\000' >> big
echo "" >> big
echo and another line after that >> big
bk delta -q -yfail big 2>OUT && {
	echo failed to error
	exit 1
}
grep -q 'big has nulls' OUT || grep -q 'delta is binary' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK
echo $N Make sure we disallow .bk_skip file  .........................$NL
touch .bk_skip
bk new .bk_skip 2> new.out
if [ $? -eq 0 ]; then echo failed; exit 1; fi
grep -q "not allowed" new.out
if [ $? -ne 0 ]; then echo failed 2; exit 1; fi
echo OK
