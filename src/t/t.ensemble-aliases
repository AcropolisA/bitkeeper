# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2002 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Tests for aliases


echo $N Create an ensemble...........................................$NL
nested project
# add some files
cd "$HERE/project/gcc"
for i in 1 2 3 4 5
do
	touch file$i
	echo "stuff $i" > file$i
	bk new $Q -y"add" file$i
done
bk commit $Q -y"Add $i to file$i"
cd "$HERE/project" && bk commit $Q -y"Commit cset in gcc"
cd "$HERE/project/gdb"
for i in 1 2 3 4 5
do
	touch file$i
	echo "stuff $i" > file$i
	bk new $Q -y"add" file$i
	bk commit $Q -y"add file $i"
done
cd "$HERE/project" && bk commit $Q -y"add csets to gdb"
echo OK

echo $N Clone and see that we have a default alias list ,............$NL
cd "$HERE"
bk clone $Q project clone
cd clone
test -f BitKeeper/log/ALIASES || {
	echo failed to create ALIASES
	exit 1
}
grep -q default BitKeeper/log/ALIASES || {
	echo bad data
	cat BitKeeper/log/ALIASES
	exit 1
}
echo OK

echo $N Set up a test where we will add another alias ...............$NL
cd "$HERE/project"
bk alias add -Astuff gcc gdb
cd ..
bk clone $Q -Astuff project stuff
bk clone $Q -Astuff project stuff2
commercial libc
cd "$HERE/project"
bk clone $Q ../libc path/to/libc
bk clone $Q ../libc junk
bk attach $Q junk path/to/libc
bk alias add -Astuff path/to/libc
echo OK

echo $N Test that we can read the name and dirs and globs ...........$NL
bk components -Astuff | bk _sort > GOT
cat << EOF > WANT
gcc
gdb
path/to/libc
EOF
checkfiles WANT GOT
bk components -A./gcc > GOT
echo gcc > WANT
checkfiles WANT GOT
# make sure longer and shorter don't match
bk components -A./gccc\* 2> ERR > GOT && {
	echo failed
	exit 1
}
grep -q "components: no match for ./gccc*" ERR || {
	echo wrong msg
	cat ERR
	exit 1
}
bk components -A./gc/\* 2> ERR > GOT && {
	echo failed
	exit 1
}
grep -q "components: no match for ./gc/*" ERR || {
	echo wrong msg
	exit 1
}
# globs that work
for p in "g*" "gc*" "g*c" "*c" "p*" "path/*"
do	bk components -A"./$p" | bk _sort
	echo ..
done > GOT
cat << EOF > WANT
gcc
gdb
..
gcc
..
gcc
..
gcc
path/to/libc
..
path/to/libc
..
path/to/libc
..
EOF
checkfiles WANT GOT
echo OK

echo $N Test that what looks like an alias is an alias ..............$NL
bk alias add -Agcc ./gcc ./gdb
bk alias add -Asamething gcc
bk components -Agcc > WANT
bk components -Asamething > GOT
checkfiles WANT GOT
bk alias rm -Agcc
bk alias rm -Asamething
echo OK

echo $N Try a push, should add libc but not junk ....................$NL
bk parent $Q -ao ../stuff ../stuff2
bk push > ../OUT 2>&1 || {
	echo should not have failed
	cat ../OUT
	exit 1
}
cd ../stuff
test -d path/to/libc || {
	echo did not add libc
	cat ../OUT
	exit 1
}
test -d junk && {
	echo should not have added junk
	cat ../OUT
	exit 1
}
cd ../stuff2
test -d path/to/libc || {
	echo did not add libc
	cat ../OUT
	exit 1
}
test -d junk && {
	echo should not have added junk
	cat ../OUT
	exit 1
}
echo OK

echo $N Try unpull and see if that works ............................$NL
bk unpull -f > OUT 2>&1 || {
	echo failed
	exit 1
}
test -d path/to/libc && {
	echo failed to remove libc
	exit 1
}
echo OK

echo $N Try a pull, should add libc but not junk ....................$NL
bk pull > ../OUT 2>&1 || {
	echo should not have failed
	cat ../OUT
	exit 1
}
test -d path/to/libc || {
	echo did not add libc
	cat ../OUT
	exit 1
}
test -d junk && {
	echo should not have added junk
	cat ../OUT
	exit 1
}
echo OK

echo $N Setup a populate that needs to go backwards .................$NL
cd ../project
for i in 1 2
do	cd path/to/libc
	touch FILE$i
	bk new $Q FILE$i
	bk commit $Q -y$i
	cd ../../../junk
	touch FILE$i
	bk new $Q FILE$i
	bk commit $Q -y$i
	cd ..
	bk commit $Q -y$i
done
TIP=`bk changes -qr+ -d:REV: junk`
echo OK

echo $N Clone backwards, getting just libc, populate junk ...........$NL
cd "$HERE"
bk clone -r1.8 -A./path/to/libc project behind > OUT 2>&1
cd behind
test -d junk && {
	echo should not have junk
	exit 1
}
test -d path/to/libc || {
	echo should have libc
	exit 1
}
bk populate $Q -A./junk || {
	echo failed
	exit 1
}
test $TIP = `bk changes -qr+ -d:REV: junk` && {
	echo failed to roll back junk
	exit 1
}
bk -Aqr check -ac || exit 1
echo OK

echo $N Test -A./gcc/nm .............................................$NL
cd "$HERE"
commercial nm
cd "$HERE"/project
bk clone $Q ../nm gcc/nm
bk attach $Q gcc/nm
cd "$HERE"
bk clone -A./gcc/nm project project-nm > OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
echo OK

# XXX - we have a bug so not this way yet
if false; then

echo $N Set up by populating all ....................................$NL
cd project-nm
echo default > BitKeeper/log/ALIASES
bk populate $Q 
cat > WANT <<EOF
gcc
gcc/nm
gdb
junk
path/to/libc
EOF
bk components -h > GOT
cmpfiles WANT GOT
echo OK

else 

echo $N Set up by populating most ...................................$NL
cd project-nm
bk populate $Q -A./gdb -A./junk -A./path/to/libc
cat > WANT <<EOF
gcc/nm
gdb
junk
path/to/libc
EOF
bk components -h > GOT
cmpfiles WANT GOT
echo OK

fi

echo $N Test a default that is just gdb .............................$NL
bk edit $Q BitKeeper/etc/aliases
(
echo @default
cd gdb
bk id
) > BitKeeper/etc/aliases
echo default > BitKeeper/log/ALIASES
bk delta $Q -ygcc BitKeeper/etc/aliases
bk commit $Q -ygcc
cd ..
bk clone $Q project-nm project-just-gdb
cd project-just-gdb
grep -q default BitKeeper/log/ALIASES || {
	echo bad log
	cat BitKeeper/log/ALIASES
	exit 1
}
bk components -h > GOT
echo gdb > WANT
cmpfiles WANT GOT
echo OK

echo $N Test -A./gcc ................................................$NL
cd "$HERE"
bk clone -A./gcc project project-gcc > OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
test -d project-gcc/gcc || {
	echo failed to make gcc
	cat OUT
	exit 1
}
echo OK

echo $N Test -A./gcc -A./gcc*........................................$NL
cd "$HERE"
bk clone -A./gcc -A./gcc* project project-gcc-2 >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
test -d project-gcc-2/gcc || {
	echo failed to make gcc
	cat OUT
	exit 1
}
echo OK


echo $N Test -A. ....................................................$NL
cd "$HERE"
bk clone -A. project project-dot > OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
test -d project-dot || {
	echo failed to make project-dot
	exit 1
}
test -d project-dot/gcc -o -d project-dot/gdb && {
	echo should not have brought components
	cat OUT
	exit 1
}
echo OK

echo $N Make sure populate -Ano-such-dir does not add to ALIASES ....$NL
cd project-dot
cp BitKeeper/log/ALIASES .
bk populate -A./no-such-dir > OUT 2>&1 && {
	echo populate should have failed
	cat OUT
	exit 1
}
cmpfiles ALIASES BitKeeper/log/ALIASES
echo OK

echo $N Same thing with a glob ......................................$NL
bk populate -A'./no-such-dir*' > OUT 2>&1 && {
	echo populate should have failed
	cat OUT
	exit 1
}
cmpfiles ALIASES BitKeeper/log/ALIASES
echo OK

echo $N Populate junk, run populate, should do nothing ..............$NL
bk populate -A'./junk' > OUT 2>&1  || {
	echo should not have failed
	cat OUT
	exit 1
}
test -d junk || exit 1
bk populate > OUT 2>&1 
grep -q 'no match' OUT && {
	echo failed
	cat OUT
	echo ALIASES
	cat BitKeeper/log/ALIASES
	echo matches for ./junk 
	bk components -A./junk
	cd ../project
	echo matches for ./junk in project
	bk components -A./junk
	exit 1
}
grep -q 'junk is already here.' OUT || {
	echo bad message
	cat OUT
	exit 1
}
echo OK

echo $N Same thing with a glob that matches junk when we have junk ..$NL
test -d junk || exit 1
bk populate -A'./junk*' > OUT 2>&1 || {
	echo populate should not have failed
	cat OUT
	exit 1
}
echo OK

echo $N Test alias with non-recursive duplicated definitions.........$NL
cd "$HERE"/project
bk edit $Q BitKeeper/etc/aliases
(
echo @alias1
echo alias2
echo @alias2
echo alias3
echo alias3
echo @alias3
echo ./gcc
) >> BitKeeper/etc/aliases
bk delta $Q -ywhatever BitKeeper/etc/aliases
bk components -Aalias1 > GOT 2>&1 || {
	echo failed
	cat GOT
	exit 1
}
echo gcc > WANT
cmpfiles WANT GOT
echo OK

echo $N Test alias with recursive definitiion .......................$NL
cd "$HERE"/project
bk edit $Q BitKeeper/etc/aliases
(
echo @alias1
echo alias2
echo @alias2
echo alias3
echo @alias3
echo alias1
echo ./gcc
) >> BitKeeper/etc/aliases
bk delta $Q -ywhatever BitKeeper/etc/aliases
bk components -Aalias1 2> ERR && {
	echo failed
	cat GOT
	exit 1
}
grep -q 'recursive alias definition' ERR || exit 1
echo OK

echo $N Remove all aliases...........................................$NL
cd "$HERE"/project
bk alias list | grep -v all | while read x
do
	bk alias rm -A$x
done
test x`bk alias list` = x || {
	echo alias list not empty
	bk alias list
	exit 1
}
echo OK

echo $N Add all components as an alias...............................$NL
cd "$HERE"/project
bk components | bk alias add -AALL - || {
	echo failed
	exit 1
}
bk components > WANT
bk components -AALL > GOT
cmpfiles WANT GOT
echo OK

echo $N Add catch-all glob...........................................$NL
cd "$HERE"/project
bk alias add -Aall-glob './*' || {
	echo failed
	exit 1
}
bk components > WANT
bk components -Aall-glob > GOT
cmpfiles WANT GOT
echo OK

echo $N Invalid alias names should fail..............................$NL
cd "$HERE"/project
bk alias add -A'this is invalid' gcc gdb >ERR 2>&1 && {
	echo failed
	cat ERR
	exit 1
}
bk alias add -A./foobar gcc gdb >ERR 2>&1 && {
	echo failed
	cat ERR
	exit 1
}
bk alias add -A+foo gcc gdb >ERR 2>&1 && {
	echo failed
	cat ERR
	exit 1
}
echo OK

# XXX: there's a bug in bk attach in which if you run it inside a product
# that is inside another product, the component will be attached to the
# enclosing product and not to the immediate product. I didn't look into this.
# as attach was rewritten in the setup cset.... (link RTI)
echo $N Component of another product should fail.....................$NL
cd "$HERE"
printf "" > empty
bk setup -fcempty -P p2
cd p2
bk setup -fc"$HERE/empty" gcc
cd "$HERE"/project
mv "$HERE"/p2 .
bk alias add -Acompiler p2/gcc gcc >ERR 2>&1 && {
	echo failed
	echo attached a component from another product
	exit 1
}
grep -q "p2/gcc must be either a glob, key, alias, or component." ERR || {
	echo failed
	echo wrong error message
	cat ERR
	exit 1
}
echo OK

echo $N bk alias -C should leave pending aliases file................$NL
cd "$HERE"/project
bk alias add -C -Adev gcc gdb >ERR 2>&1 || {
	echo failed
	cat ERR
	exit 1
}
echo BitKeeper/etc/SCCS/s.aliases > WANT
bk sfiles -cP > GOT
cmpfiles WANT GOT
echo OK

echo $N Test show interface..........................................$NL
cd "$HERE"/project
for m in `bk alias list`
do
	echo @$m
	bk alias show -A$m
done > GOT
bk cat BitKeeper/etc/aliases > WANT
cmpfiles WANT GOT
bk alias show -A"DOESNOTEXIST" 2> ERR && {
	echo failed rc
	exit 1
}
grep -q "alias 'DOESNOTEXIST' does not exist" ERR || {
	echo failed msg
	exit 1
}
echo OK

echo $N Test creating aliases in a sparse tree ......................$NL
(
cd gcc
bk id
cd ../gdb
bk id
) > ../WANT
cd "$HERE"
bk clone $Q -A. project sparse || exit 1
cd sparse || exit 1
test -d gcc && {
	echo should not have gcc
	exit 1
}
# Note: trying both forms of "dir" and "./dir"
bk alias add -Asparse ./gcc gdb || exit 1
bk alias show -Asparse > GOT
cmpfiles ../WANT GOT
echo OK

echo $N Test creating files in the place of missing aliases .........$NL
cd "$HERE"/project-gcc
mkdir gdb
echo hi > gdb/foo
bk new $Q gdb/foo || exit 1
bk commit -ybadfile $Q 2>ERR && {
	echo should have failed
	cat ERR
	exit 1
}
grep -q "check: gdb/foo conflicts with component at gdb" ERR || exit 1

cd gcc
mkdir nm
echo hi > nm/foo
bk new $Q nm/foo || exit 1
bk commit -ybadfile $Q  2>ERR && {
	echo should have failed
	cat ERR
	exit 1
}
grep -q "check: nm/foo conflicts with component at nm" ERR || exit 1
echo OK

echo $N Make sure we can not remove the all alias ...................$NL
bk alias rm -Aall > OUT 2>&1 && {
	echo should have failed
	cat OUT
	exit 1
}
grep -q 'reserved name "all" may not be changed.' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK

echo $N Make sure we can not remove the gcc component from all.......$NL
bk alias rm -Aall ./gcc > OUT 2>&1 && {
	echo should have failed
	cat OUT
	exit 1
}
grep -q 'reserved name "all" may not be changed.' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK

echo $N Make sure we can not add to the all alias ...................$NL
bk alias add -Aall ./gcc > OUT 2>&1 && {
	echo should have failed
	cat OUT
	exit 1
}
grep -q 'reserved name "all" may not be changed.' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK

echo $N Using a relative path in bk alias should work................$NL
cd "$HERE"/project/gcc
bk alias add -Anm ./nm || {
	echo failed
	exit 1
}
bk components -Anm >GOT
cat <<EOF >WANT
gcc/nm
EOF
cmpfiles WANT GOT
echo OK
