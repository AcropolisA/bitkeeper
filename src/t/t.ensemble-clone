# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2002 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Tests for product clone.

echo $N Create initial ensemble......................................$NL
nested project
test -d gcc/BitKeeper/tmp -a -d gdb/BitKeeper/tmp || exit 1
# Now add some stuff
for r in gcc gdb
do
	cd $r
	for i in 1 2 3 4
	do
		echo $i > file$i
		bk new $Q file$i
	done
	bk commit $Q -y"add some files"
	cd ..
done
bk commit $Q -y"Added files to gcc & gdb"
echo OK

echo $N Clone the product............................................$NL
cd "$HERE"
bk clone $Q project copy >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
cd copy
bk -Ar check -a >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
echo OK

echo $N Test the parent pointer......................................$NL
P=`bk parent -l`
EP=file://"$HERE"/project
test "$P" = "$EP" || {
	echo failed
	echo "got  '$P'"
	echo "want '$EP'"
	exit 1
}
echo OK

echo $N Test that components have parent pointer ....................$NL
for r in gcc gdb
do
	cd "$HERE/copy/$r"
	P=`bk parent -l`
	EP=file://"$HERE"/project
	test "$P" = "$EP" || {
		echo failed
		echo "expected: $EP"
		echo "got     : $P"
		exit 1
	}
done
echo OK

echo $N Test that clone on a component fails ........................$NL
cd "$HERE"
bk clone $Q project/gcc mynewgcc 2> ERR && {
	echo failed
	exit 1
}
grep -q "clone of a component is not allowed" ERR || {
	echo wrong msg
	cat ERR
	exit 1
}
bk clone $Q copy/gcc mynewgcc 2> ERR && {
	echo failed
	exit 1
}
grep -q "clone of a component is not allowed" ERR || {
	echo wrong msg
	cat ERR
	exit 1
}
echo OK

cd "$HERE"
cd project
bk sfiles -R | grep -v gcc > ../LIST
cd ..

echo $N Test that -skey clones work .................................$NL
KEY=`bk changes -r+ -q -d:ROOTKEY: project/gcc`
rm -rf mynewgcc
bk clone $Q -s"$KEY" project mynewgcc 2> ERR || {
	echo failed
	cat ERR
	exit 1
}
test -d mynewgcc -a -d mynewgcc/gcc || {
	echo did not bring gcc alias across
	cat ERR
	exit 1
}
for i in `cat LIST`
do	test -d mynewgcc/$i && {
		echo should not have brought $i
		cat ERR
		exit 1
	}
done
echo OK

echo $N Test that we can clone using the COMPONENTS file.............$NL
rm -rf mynewgcc
cd project
bk alias justgcc gcc
cd ..
bk clone $Q -sjustgcc project mynewgcc 2> ERR || {
	echo failed
	cat ERR
	exit 1
}
test -d mynewgcc -a -d mynewgcc/gcc || {
	echo did not bring gcc alias across
	cat ERR
	exit 1
}
for i in `cat LIST`
do	test -d mynewgcc/$i && {
		echo should not have brought $i
		cat ERR
		exit 1
	}
done
echo OK

echo $N Test that we can clone just that component with -s./gcc .....$NL
rm -rf mynewgcc
bk clone $Q -s./gcc project mynewgcc 2> ERR || {
	echo failed
	cat ERR
	exit 1
}
test -d mynewgcc -a -d mynewgcc/gcc || {
	echo did not bring gcc alias across
	cat ERR
	exit 1
}
for i in `cat LIST`
do	test -d mynewgcc/$i && {
		echo should not have brought $i
		cat ERR
		exit 1
	}
done
echo OK

echo $N Make sure that the COMPONENTS file is correct ...............$NL
cd mynewgcc
test -f BitKeeper/log/COMPONENTS || {
	echo no COMPONENTS file
	exit 1
}
test "`cat BitKeeper/log/COMPONENTS`" = "./gcc" || {
	echo bad content
	cat BitKeeper/log/COMPONENTS
	exit 1
}
echo OK

echo $N Make sure that the COMPONENTS file propagates on clone ......$NL
cd "$HERE"
bk clone $Q mynewgcc mynewgcc2
cd mynewgcc2
test -f BitKeeper/log/COMPONENTS || {
	echo no COMPONENTS file
	exit 1
}
test "`cat BitKeeper/log/COMPONENTS`" = "./gcc" || {
	echo bad content
	cat BitKeeper/log/COMPONENTS
	exit 1
}
echo OK

echo $N Add a component with populate -s./gdb .......................$NL
cd "$HERE/mynewgcc"
bk populate $Q -s./gdb || exit 1
test -d gdb || {
	echo failed to get gdb
	exit 1
}
echo OK

echo $N Make sure that the COMPONENTS file is correct ...............$NL
test -f BitKeeper/log/COMPONENTS || {
	echo no COMPONENTS file
	exit 1
}
cat > WANT <<EOF
./gcc
./gdb
EOF
cmpfiles WANT BitKeeper/log/COMPONENTS
echo OK

echo $N Check that populate is idempotent ...........................$NL
cd "$HERE/mynewgcc"
bk populate $Q -s./gdb || exit 1
test -d gdb || {
	echo failed to get gdb
	exit 1
}
echo OK

echo $N Make sure that the COMPONENTS file is still correct .........$NL
test -f BitKeeper/log/COMPONENTS || {
	echo no COMPONENTS file
	exit 1
}
cat > WANT <<EOF
./gcc
./gdb
EOF
cmpfiles WANT BitKeeper/log/COMPONENTS
echo OK

echo $N Update a component now that it is here ......................$NL
cd gdb
bk edit $Q file1
bk delta $Q -fyempty file1
bk commit $Q -ytouch
cd ..
bk commit $Q -ytouch
echo OK

test 1 = 0 && {
echo $N Pull in new cset without component, then populate ...........$NL
cd "$HERE/mynewgcc2"
bk pull $Q
BEFORE=`bk changes -r+ -nd:I:`
bk populate $Q -s./gdb "$HERE/project"
# without accompanying unfix to clone, this is how it used to fail:
AFTER=`bk changes -r+ -nd:I:`
test "$BEFORE" = "$AFTER" && {
	echo fix test
	exit 1
}
# show they don't match
# echo was $BEFORE and now $AFTER
echo "failed (bug )"
}

# This is somewhat different in that the parent has a COMPONENTS file.
# In a fully populated tree you wouldn't expect one.
echo $N clone -s./gcc should have only that in COMPONENTS ...........$NL
cd "$HERE"
bk clone $Q -s./gcc mynewgcc mynewgcc3
cd mynewgcc3
test -d gdb && {
	echo should not have gdb
	exit 1
}
test -f BitKeeper/log/COMPONENTS || {
	echo no COMPONENTS file
	exit 1
}
test "`cat BitKeeper/log/COMPONENTS`" = "./gcc" || {
	echo bad content
	cat BitKeeper/log/COMPONENTS
	exit 1
}
echo OK

echo $N clone -sjunk when no such alias exists should fail ..........$NL
cd "$HERE"
bk clone -sjunk mynewgcc3 mynewgcc4 2> ERR && {
	echo should have failed and did not
	cat ERR
	exit 1
}
test -d mynewgcc4 && {
	echo should not have created anything
	exit 1
}
echo OK

echo $N clone -s./junk when no such directory exists should fail ....$NL
cd "$HERE"
bk clone -s./junk mynewgcc3 mynewgcc4 2> ERR && {
	echo should have failed and did not
	cat ERR
	exit 1
}
test -d mynewgcc4 && {
	echo should not have created anything
	exit 1
}
echo OK

echo $N clone -s./gdb when the parent only has gcc ..................$NL
cd "$HERE"
bk clone -s./gdb mynewgcc3 mynewgcc4 > ERR 2>&1 && {
	echo should have failed
	cat ERR
	exit 1
}
grep -q "clone: gdb not present in" ERR || {
	echo diff msg
	cat ERR
	exit 1
}
test -d mynewgcc4 && {
	echo should not have repo
	exit 1
}
echo OK

echo $N Check that we can populate gdb from elsewhere ...............$NL
bk clone mynewgcc3 mynewgcc4 > ERR 2>&1 
cd mynewgcc4 || exit 1
rm -rf gdb
bk populate -s./gdb ../mynewgcc > OUT 2>&1
bk _test -d gdb -a -f gdb/SCCS/s.ChangeSet || {
	echo failed
	cat OUT
	exit 1
}
echo OK

echo $N Add more stuff to gcc........................................$NL
cd "$HERE/project/gcc"
for i in 1 2 3 4
do
	bk edit $Q file$i
	echo "stuff $i" > file$i
	bk delta $Q -y"modify" file$i
	bk commit $Q -y"Add $i to file$i"
done
cd ..
bk commit $Q -y"more stuff to gcc"
echo OK

echo $N clone -r test................................................$NL
TIP=`cd "$HERE/copy" && bk changes -nd:REV: -r+`
cd "$HERE"
bk clone $Q -r"$TIP" project copy2 >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
cd copy2
T=`bk changes -nd:REV: -r+`
test x$T = x$TIP || {
	echo failed
	echo cloned copy has $T as tip, expected $TIP
	exit 1
}
echo OK

test 0 = 1 && {
echo $N Test that we can run changes -R in a component ..............$NL
cd gcc
bk changes -R > OUT
grep -q gcc/ChangeSet OUT || {
	echo failed
	cat OUT
	exit 1
}
echo OK
}

echo $N Test clone through a bkd.....................................$NL
cd "$HERE/project"
P=`port 50000`
# what is coming out stdout? and stderr?
# bk bkd -q -d -p$P -ikill > "$HERE/BKD" 2>&1
bk bkd -q -d -p$P -ikill 
cd "$HERE"
bk clone $Q bk://localhost:$P clone3 || {
	echo failed
	cat OUT
	exit 1
}
bk _kill bk://localhost:$P || exit 1
echo OK

echo $N Test lclone..................................................$NL
cd "$HERE"
bk lclone $Q project lcopy >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
cd lcopy
bk -Ar check -a >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
echo OK

echo $N Test the parent pointer......................................$NL
P=`bk parent -l`
EP=file://"$HERE"/project
STATUS="OK"
test "$P" = "$EP" || {
	EP=file:/"$HERE"/project
	test "$P" = "$EP" || {
		echo failed
		echo "got '$P'"
		exit 1
	}
	STATUS="failed (bug in url handling)"
}
echo $STATUS

echo $N Test that components have parent pointer ....................$NL
for r in gcc gdb
do
	cd "$HERE/copy/$r"
	P=`bk parent -l`
	EP=file://"$HERE"/project
	test "$P" = "$EP" || {
		echo failed
		echo "expected: $EP"
		echo "got     : $P"
		exit 1
	}
done
echo OK

echo $N Test lclone -r...............................................$NL
cd "$HERE"
bk lclone $Q -r"$TIP" project lcopy2 >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
cd lcopy2
T=`bk changes -nd:REV: -r+`
test x$T = x$TIP || {
	echo failed
	echo cloned copy has $T as tip, expected $TIP
	exit 1
}
echo OK

echo $N Test clone with args.........................................$NL
cd "$HERE"
bk clone -EBKU_TEST=ff $Q project copy_args >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
echo OK

echo $N Test deep nest populate scenarios ...........................$NL
cd "$HERE"/project/gcc
commercial deep
cd ../..
bk attach $Q gcc/deep
test -f BitKeeper/log/deep-nests || {
	echo failed to make deep-nests
	exit 1
}
grep -q gcc/deep BitKeeper/log/deep-nests || {
	echo failed to add gcc/deep to deep-nests
	exit 1
}
bk sfiles -p
bk components > LIST
grep -q gcc/deep LIST || {
	echo ensemble list did not list gcc/deep
	bk components
	exit 1
}
cd ..
bk clone $Q -s./gdb project deeppop
cd deeppop
bk populate $Q -s./gcc/deep || {
	echo failed
	exit 1
}
bk populate $Q -s./gcc 2> ERR || {
	echo failed
	exit 1
}
echo OK

# gcc
# gcc/deep
# gdb
echo $N Test populate with no args ..................................$NL
cd "$HERE"
bk clone $Q -s. project product
cd product
bk components -h > LIST
test -s LIST && {
	echo should not have any components yet
	cat LIST
	exit 1
}
bk populate $Q || exit 1
bk components -h > GOT
cat > WANT <<EOF
gcc
gcc/deep
gdb
EOF
cmpfiles WANT GOT
echo OK

echo $N Test populate in repair mode with nothing to do .............$NL
bk populate -r > GOT 2>&1 || exit 1
cat > WANT <<EOF
populate: gcc is already here.
populate: gcc/deep is already here.
populate: gdb is already here.
populate: no components fetched
EOF
cmpfiles WANT GOT
echo OK

echo $N Test populate in repair mode with gdb missing ...............$NL
rm -rf gdb
bk populate -r > GOT 2>&1 || exit 1
bk components -h > GOT
cat > WANT <<EOF
gcc
gcc/deep
gdb
EOF
cmpfiles WANT GOT
echo OK

echo $N Test populate in repair mode with gcc/deep missing ..........$NL
rm -rf gcc/deep
bk populate -r > GOT 2>&1 || exit 1
bk components -h > GOT
cat > WANT <<EOF
gcc
gcc/deep
gdb
EOF
cmpfiles WANT GOT
echo OK

echo $N Test populate in repair mode with gcc/deep and gcc missing ..$NL
rm -rf gcc
bk populate -r > GOT 2>&1 || exit 1
bk components -h > GOT
cat > WANT <<EOF
gcc
gcc/deep
gdb
EOF
cmpfiles WANT GOT
echo OK

echo $N Unpopulate all components ...................................$NL
bk unpopulate $Q > ERR 2>&1 || {
	echo unpopulate failed
	exit 1
}
for i in `bk components`
do	test -d $i && {
		echo failed to remove $i
		exit 1
	}
done
echo OK

echo $N Test populate in repair mode with all components missing ....$NL

echo default > BitKeeper/log/COMPONENTS
bk populate -r > GOT 2>&1 || exit 1
bk components -h > GOT
cat > WANT <<EOF
gcc
gcc/deep
gdb
EOF
cmpfiles WANT GOT
echo OK

echo $N Test populate with no parent ................................$NL
bk parent -r $Q
rm -rf gcc gdb
bk populate -r > GOT 2>&1 && {
	cat GOT
	exit 1
}
grep -q 'populate: neither parent nor url provided.' GOT || {
	echo bad error message
	cat GOT
	exit 1
}
echo OK

echo $N Test populate -r with url ...................................$NL
rm -rf gcc gdb
bk populate -r ../project > GOT 2>&1 || exit 1
bk components -h > GOT
cat > WANT <<EOF
gcc
gcc/deep
gdb
EOF
cmpfiles WANT GOT
echo OK

echo $N Test populate with url ......................................$NL
rm -rf gcc gdb
echo default > BitKeeper/log/MODULES
bk populate ../project > GOT 2>&1 || exit 1
bk components -h > GOT
cat > WANT <<EOF
gcc
gcc/deep
gdb
EOF
cmpfiles WANT GOT
echo OK

echo $N Test unpopulate no parent ...................................$NL
bk unpopulate $Q >OUT 2>&1 && {
	echo should have failed
	exit 1
}
# XXX - superset is not graceful
grep -q 'Parent: This repository has no pull parent.' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK

echo $N Test unpopulate with local extras ...........................$NL
bk parent $Q ../project
touch gcc/extra gdb/extra
bk unpopulate $Q > OUT 2>&1 && {
	echo unpopulate should have failed
	exit 1
}
grep -q 'has local changes' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
for i in `bk components`
do	test -d $i || {
		echo should not have removed $i
		exit 1
	}
done
echo OK

echo $N Test unpopulate with local extras forcing it ................$NL
bk parent $Q ../project
touch gcc/extra gdb/extra
bk unpopulate -f $Q || {
	echo unpopulate should not have failed
	exit 1
}
for i in `bk components`
do	test -d $i && {
		echo should have removed $i
		exit 1
	}
done
echo OK

echo $N Test unpopulate with local cset .............................$NL
bk parent $Q ../project
bk populate $Q
test -d gdb || exit 1
(cd gdb
echo foo > foo
bk new $Q foo
bk commit $Q -yfoo
)
bk unpopulate $Q >OUT 2>&1 && {
	echo unpopulate should have failed
	exit 1
}
grep -q 'local changes' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
for i in `bk components`
do	test -d $i || {
		echo should not have removed $i
		exit 1
	}
done
echo OK

echo $N Test unpopulate with local cset forcing it ..................$NL
bk parent $Q ../project
bk unpopulate -f $Q || {
	echo unpopulate should not have failed
	exit 1
}
for i in `bk components`
do	test -d $i && {
		echo should have removed $i
		exit 1
	}
done
echo OK

