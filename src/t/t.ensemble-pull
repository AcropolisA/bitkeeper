# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2008 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
#
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

echo $N Create an ensemble...........................................$NL
nested project
# add some files
cd "$HERE/project/gcc"
for i in 1 2 3 4 5
do
	touch file$i
	echo "stuff $i" > file$i
	bk new $Q -y"add" file$i
done
bk commit $Q -y"Add $i to file$i"
cd "$HERE/project" && bk commit $Q -y"Commit cset in gcc"
cd "$HERE/project/gdb"
for i in 1 2 3 4 5
do
	touch file$i
	echo "stuff $i" > file$i
	bk new $Q -y"add" file$i
	bk commit $Q -y"add file $i"
done
cd "$HERE/project" && bk commit $Q -y"add csets to gdb"
echo OK

echo $N Try a null pull..............................................$NL
cd "$HERE"
bk clone $Q project null-pull
cd "$HERE/null-pull"
bk pull >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
grep -q "Nothing to pull." OUT || {
	echo failed
	cat OUT
	exit 1
}
echo OK

echo $N Try a simple pull............................................$NL
cd "$HERE"
bk clone $Q project copy
# add some csets to gcc
cd "$HERE/project/gcc"
for i in 1 2 3 4 5
do
	bk edit $Q file$i
	echo "new stuff $i" >> file$i
	bk delta $Q -y"modify" file$i
	bk commit $Q -y"Add $i to file$i"
done
cd "$HERE/project"
bk commit $Q -y"more stuff to gcc"
cd "$HERE/copy"
bk pull >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
test -z "`bk changes -qR`" || {
	echo failed
	echo Did not pull
	bk changes -qR
	cat OUT
	exit 1
}
bk -Ar check -av >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
echo OK

echo $N Test rootkey urls, file url, component root key .............$NL
cd ../project
RK=`bk prs -r1.0 -hnd:KEY: gcc/ChangeSet`
touch foo
bk new $Q foo
bk mv foo bar
BADRK=`bk prs -r1.0 -hnd:KEY: bar`
cd ../copy
RK2=`bk changes -q -r1.0 -nd:KEY: ../project?ROOTKEY=$RK`
test "$RK" = "$RK2" || exit 1
echo OK

echo $N Test rootkey urls, file url, product root key ...............$NL
PRK=`bk -R prs -r1.0 -hnd:KEY:`
RK2=`bk changes -q -r1.0 -nd:KEY: ../project?ROOTKEY=$PRK`
test "$PRK" = "$RK2" || exit 1
echo OK

echo $N Test rootkey urls, file url, nonexistant root key ...........$NL
bk changes -q -r1.0 -nd:KEY: ../project?ROOTKEY=$RK.junk 2> ERR && {
	echo should have failed
	exit 1
}
grep -q "cannot use key" ERR || {
	echo wrong msg
	cat ERR
	exit 1
}
echo OK

echo $N Test rootkey urls, file url, file root key ..................$NL
bk changes -q -r1.0 -nd:KEY: ../project?ROOTKEY=$BADRK 2> ERR && {
	echo should have failed
	exit 1
}
grep -q "cannot use key" ERR || {
	echo wrong msg
	cat ERR
	exit 1
}
echo OK

echo $N Test rootkey urls, file url, component key, no component ....$NL
cd ../project
mv gcc hidden
cd ../copy
bk changes -q -r1.0 -nd:KEY: ../project?ROOTKEY=$RK 2> ERR && {
	echo should have failed
	exit 1
}
grep -q "ERROR-cannot cd to gcc " ERR || {
	echo wrong msg
	cat ERR
	exit 1
}
cd ../project
mv hidden gcc
cd ../copy
echo OK

echo $N Test rootkey urls, bk:// url above, component root key ......$NL
cd "$HERE"
P=`port 50000`
bk bkd -q -d -p$P -ikill > "$HERE/BKD" 2>&1
RK2=`bk changes -q -r1.0 -nd:KEY: bk://localhost:$P/project?ROOTKEY=$RK`
test "$RK" = "$RK2" || {
	echo failed
	bk _kill bk://localhost:$P
	exit 1
}
# leave bkd running for next test
echo OK

echo $N Test rootkey urls, bk:// url above, product root key ........$NL
RK2=`bk changes -q -r1.0 -nd:KEY: bk://localhost:$P/project?ROOTKEY=$PRK`
test "$PRK" = "$RK2" || {
	echo failed
	bk _kill bk://localhost:$P
	exit 1
}
echo OK
bk _kill bk://localhost:$P

echo $N Test rootkey urls, bk:// url in repo, component root key ....$NL
cd "$HERE/project"
P=`port 50000`
bk bkd -q -d -p$P -ikill > "$HERE/BKD" 2>&1
RK2=`bk changes -q -r1.0 -nd:KEY: bk://localhost:$P?ROOTKEY=$RK`
test "$RK" = "$RK2" || {
	echo failed
	bk _kill bk://localhost:$P
	exit 1
}
echo OK

echo $N Test rootkey urls, bk:// url in repo, product root key ......$NL
RK2=`bk changes -q -r1.0 -nd:KEY: bk://localhost:$P?ROOTKEY=$PRK`
test "$PRK" = "$RK2" || {
	echo failed
	bk _kill bk://localhost:$P
	exit 1
}
echo OK

echo $N Test rootkey urls, bk:// url, nonexistant root key ..........$NL
bk changes -q -r1.0 -nd:KEY: bk://localhost:$P?ROOTKEY=$RK.junk 2> ERR && {
	echo should have failed
	exit 1
}
grep -q "cannot use key" ERR || {
	echo wrong msg
	cat ERR
	bk _kill bk://localhost:$P
	exit 1
}
echo OK

echo $N Test rootkey urls, bk:// url, file root key .................$NL
bk changes -q -r1.0 -nd:KEY: bk://localhost:$P?ROOTKEY=$BADRK 2> ERR && {
	echo should have failed
	exit 1
}
grep -q "cannot use key" ERR || {
	echo wrong msg
	cat ERR
	bk _kill bk://localhost:$P
	exit 1
}
echo OK

echo $N Test rootkey urls, bk:// url, component key, no component ...$NL
cd "$HERE/project"
mv gcc hidden
cd ../copy
bk changes -q -r1.0 -nd:KEY: bk://localhost:$P?ROOTKEY=$RK 2> ERR && {
	echo should have failed
	bk _kill bk://localhost:$P
	exit 1
}
grep -q "ERROR-cannot cd to gcc " ERR || {
	echo wrong msg
	cat ERR
	bk _kill bk://localhost:$P
	exit 1
}
cd ../project
mv hidden gcc
cd ../copy
echo OK
bk _kill bk://localhost:$P

echo $N Try a pull with conflicts that can be automerged.............$NL
cd "$HERE"
bk clone $Q null-pull remote
bk clone $Q remote local
cd remote
echo bam > bam
bk new $Q -b bam
cd "$HERE"/remote/gcc
echo bam > bam
bk new $Q -b bam
for i in 1 2 3 4 5
do
	bk edit $Q file$i
	echo "new stuff $i" >> file$i
	bk delta $Q -y"modify" file$i
	bk commit $Q -y"Add $i to file$i"
done
cd "$HERE"/remote
bk commit $Q -y"remote gcc"
cd "$HERE"/local/gcc
for i in 6 7 8 9
do
	echo "new stuff $i" >> file$i
	bk new $Q -y"modify" file$i
	bk commit $Q -y"Add $i to file$i"
done
cd "$HERE"/local
bk commit $Q -y"local gcc"
bk pull >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
grep -q "sccs_init" OUT && {
	echo failed sccs_init
	cat OUT
	exit 1
}

# check must pass
bk -Ar check -av >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}

# gcc/ChangeSet is in product's changeset
cd "$HERE"/local
cat <<EOF > WANT
ChangeSet
gcc/ChangeSet
EOF
bk changes -nd:GFILE: -vr+ > GOT
cmpfiles WANT GOT

# Files were actually pulled
cd "$HERE"/local/gcc
cat <<EOF >WANT
SCCS/s.ChangeSet
SCCS/s.bam
SCCS/s.file1
SCCS/s.file2
SCCS/s.file3
SCCS/s.file4
SCCS/s.file5
SCCS/s.file6
SCCS/s.file7
SCCS/s.file8
SCCS/s.file9
BitKeeper/etc/SCCS/s.collapsed
BitKeeper/etc/SCCS/s.config
BitKeeper/etc/SCCS/s.gone
BitKeeper/etc/SCCS/s.ignore
EOF
bk sfiles > GOT
cmpfiles WANT GOT

test -f SCCS/d.ChangeSet && {
	echo failed
	echo left dfile
	pwd
	ls SCCS
	exit 1
}
echo OK


echo $N Try a pull that adds a component.............................$NL
cd "$HERE/project"
commercial newcomp
cd ..
bk attach $Q newcomp
cd "$HERE/copy"
bk pull >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
test -d newcomp || {
	echo failed
	exit 1
}
cd newcomp
bk -r check -av >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
cd ..
bk -Ar check -av >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
echo OK

echo $N Setup for pulling conflict into missing component ...........$NL
cd "$HERE"
rm -fr project copy sparse
nested project
cd ..
bk clone $Q project copy
bk clone $Q -s./gcc project sparse
# modify both components in both repos in a way which autoresolves
for i in project copy
do	for c in gcc gdb
	do	cd "$HERE/$i/$c"
		touch $i-$c
		bk new $Q $i-$c
		bk commit $Q -ywhatever
	done
	cd "$HERE/$i"
	bk commit $Q -ywhatever
done
echo OK

echo $N Pull of one should work .....................................$NL
cd "$HERE/sparse"
# make a conflict in the component that we have
cd gcc
touch sparse
bk new $Q sparse
bk commit $Q -ywhatever
cd ..
bk commit $Q -ywhatever
bk pull $Q ../project 2> ERR || {
	echo pull failed
	cat ERR
	exit 1
}
echo OK

echo $N Pull of second one should fail ..............................$NL
bk pull ../copy > OUT 2>&1 && {
	echo should have failed
	cat OUT
	exit 1
}
grep -q "Unable to resolve conflict in non-present component 'gdb'." OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK

echo $N Try a pull where source did rm -rf component ................$NL
cd "$HERE"
bk clone $Q project clone
cd project/gdb
touch junk
bk new $Q junk
bk commit $Q -ywhatever
cd ..
bk commit $Q -ywhatever
cd "$HERE"
tar cf TAR project clone
rm -rf project/gdb
cd clone
bk pull > OUT 2>&1 && {
	echo should have failed
	cat OUT
	exit 1
}
grep -q 'pull: gdb is missing' OUT || {
	echo bad message
	cat OUT
	exit 1
}
echo OK

echo $N Try a pull where destination did rm -rf component ...........$NL
cd "$HERE"
rm -rf project clone
tar xf TAR
cd clone 
rm -rf gdb
bk pull > OUT 2>&1 && {
	echo should have failed
	cat OUT
	exit 1
}
grep -q "Could not chdir to  component 'gdb'" OUT || {
	echo bad message
	cat OUT
	exit 1
}
echo OK

# Not until we do renames
exit 0

echo $N Try a pull with a moved component............................$NL
cd "$HERE"
rm -rf remote local
bk clone $Q null-pull remote
bk clone $Q remote local
cd "$HERE"/local
mv gcc gcc4
bk edit $Q gcc4/ChangeSet
bk delta $Q -y'rename' gcc4/ChangeSet
bk commit $Q -y'rename component'
cd "$HERE"/remote/gcc
for i in 1 
do
	bk edit $Q file$i
	echo "new stuff $i" >> file$i
	bk delta $Q -y"modify" file$i
	bk commit $Q -y"Add $i to file$i"
done
cd "$HERE"/remote
bk commit $Q -y"remote gcc"
cd "$HERE"/local

bk pull ../project >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
test -d gcc && {
	echo should not have made gcc
	find gcc
	# exit 1
}
echo '(bug)'
