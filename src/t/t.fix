# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Copyright (c) 1999 Larry McVoy
# %K%

echo $N Check bk fix to re-edit a file ..............................$NL
no_logging project
date > FILE
bk ci $Q -i FILE
bk co $Q -l FILE
echo "New changes that I want to modify" >> X
bk undos X > FILE
cp FILE SAVE
bk ci $Q -y'Oops' FILE
bk fix $Q FILE
if [ ! -f SCCS/p.FILE ]; then echo Failed to edit FILE; exit 1; fi
writable FILE || { echo Failed to edit File; exit 1; }
cmp -s SAVE FILE
if [ $? != 0 ]; then echo failed to restore FILE; diff FILE SAVE; exit 1; fi
set `cat SCCS/p.FILE`
if [ "X$1" != "X1.1" ]; then echo failed to restore revision; exit 1; fi

## unfortunately this test doesn't seem to work everywhere, sunx86
## still wants to rebuild the file
#make FILE > /dev/null || {
#	echo FILE should be newer than SCCS/s.FILE
#	ls -l --full-time FILE SCCS/s.FILE
#	exit 1
#}
echo OK

echo $N Make sure that we can not fix a committed delta .............$NL
bk ci $Q -y'OK' FILE
bk commit $Q -y'commit'
echo "stripdel: can't remove committed delta FILE@1.2" > X
bk undos X > CMP1
bk fix $Q FILE 2> CMP2
cmp -s CMP1 CMP2
if [ $? != 0 ]; then echo failed to fail stripdel; diff CMP1 CMP2; exit 1; fi
echo OK

echo $N Make sure file was not left edited or writable ..............$NL
test -w FILE && {
	echo FILE is writeable
	exit 1
}
test -f SCCS/p.FILE && {
	echo FILE is locked
	exit 1
}
echo OK

echo $N Make sure cset lists changes in latest .. earliest order ....$NL
echo foo > ORDER
bk new $Q ORDER
bk unedit FILE
for i in 2 3 4 5
do	bk edit $Q FILE ORDER
	echo $i >> FILE
	echo $i >> ORDER
	bk delta $Q -ywhatever$i FILE ORDER
done
bk commit $Q -y'ChangeSet comments'
cat > WANT <<EOF
ORDER|1.5
ORDER|1.4
ORDER|1.3
ORDER|1.2
ORDER|1.1
ORDER|1.0
EOF
bk cset -r+ | grep ORDER > REVS
cmp -s WANT REVS || {
	echo cset listed wrong order or incorrect list
	cat WANT
	echo ====== got ======
	cat REVS
	exit 1
}
cat > WANT <<EOF
FILE|1.6
FILE|1.5
FILE|1.4
FILE|1.3
EOF
bk cset -r+ | grep FILE > REVS
cmp -s WANT REVS || {
	echo cset listed wrong order or incorrect list
	cat WANT
	echo ====== got ======
	cat REVS
	bk cset -r+
	exit 1
}
echo OK

# We'll need this later
bk clone $Q $HERE/project $HERE/save

echo $N Make sure ChangeSet is not left edited by fix -c ............$NL
bk fix $Q -c
test -f SCCS/p.ChangeSet && {
	echo Left a lock file
	exit 1
}
echo OK

echo $N Make sure ChangeSet comments were left by fix -c ............$NL
test -f SCCS/c.ChangeSet || {
	echo No comments
	exit 1
}
echo ChangeSet comments > C
cmp -s C SCCS/c.ChangeSet || {
	echo incorrect comments
	echo Wanted ChangeSet comments
	echo got `cat SCCS/c.ChangeSet`
	exit 1
}
echo OK

echo $N Make sure multiple deltas in same cset undoes top only ......$NL
test `bk prs -hnd:REV: -r+ ORDER` = 1.4 || {
	echo Should have left rev 1.4
	bk prs ORDER
	exit 1
}
echo OK

echo $N Make sure multiple deltas in same cset leaves top c.file ....$NL
test -f SCCS/c.ORDER || {
	echo No comment file found
	exit 1
}
cat > WANT <<EOF
whatever5
EOF
cmp -s SCCS/c.ORDER WANT || {
	echo Incorrect comments
	cat GOT
	exit 1
}
echo OK

if [ "$PLATFORM" != "WIN32" ]
then #-----------------------------------------------------------------
echo $N Make sure permissions are preserved .........................$NL
bk unedit FILE
rm ORDER
bk chmod +x FILE
bk commit $Q -ychmod
bk get $Q FILE
test -x FILE || {
	echo bk chmod did not stick
	exit 1
}
bk clean FILE
bk fix -c $Q
test -x FILE || {
	echo Did not preserve execute
	exit 1
}
echo OK
fi #------------------------------------------------------------------

echo $N Make sure we may not fix a merge changeset ..................$NL
cd $HERE
bk clone $Q save clone
cd save
touch BitKeeper/etc/SCCS/x.marked
bk edit $Q FILE
bk delta -ysave $Q FILE
bk commit -ysave $Q
cd ../clone
touch BitKeeper/etc/SCCS/x.marked
bk edit $Q FILE
bk delta -yclone $Q FILE
bk commit -yclone $Q
bk pull $Q
bk fix -c 2>OUT && {
	echo fix failed to exit with an error
	exit 1
}
grep -q 'fix merge changesets' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK

echo $N Make sure renames are not stripped but are left pending .....$NL
cd $HERE
cp -rp clone pending
cd pending
bk mv FILE RENAME
bk commit $Q -yrename
bk fix -c $Q || {
	echo fix should not have failed
	exit 1
}
test "`bk sfiles -gp`" = RENAME || {
	echo bad pending list from sfiles -p
	bk sfiles -p
	exit 1
}
test "`bk sfiles -gP`" = RENAME || {
	echo bad pending list from sfiles -P
	bk sfiles -P
	exit 1
}
echo OK

echo $N Make sure bk new-ed files are left but s.file is removed ....$NL
cd $HERE
cp -rp clone new
cd new
ls > NEW
cp NEW SAVE
bk new $Q NEW
bk commit $Q -ynew
bk fix -c $Q || exit 1
test -f NEW || {
	echo failed to leave NEW
	exit 1
}
test -w NEW || {
	echo failed to leave NEW with write permission
	exit 1
}
cmp -s NEW SAVE || {
	echo different contents
	exit 1
}
test -f SCCS/s.NEW && {
	echo should have removed s.NEW
	exit 1
}
test -f SCCS/c.NEW || {
	echo should have left a c.NEW
	exit 1
}
test -s SCCS/c.NEW || {
	echo should have left a non-empty c.NEW
	exit 1
}
test -z "$BK_TESTGUI" || {
	echo ""
	cat SCCS/c.NEW
	echo click commit, it should have NEW marked new
	bk citool
}
echo OK

echo $N Make sure bk new-ed files are left without keywords expanded.$NL
cd $HERE
cp -rp clone keywords
cd keywords
bk edit $Q BitKeeper/etc/config
echo "keywords: sccs" >> BitKeeper/etc/config
bk delta $Q -y'sccs keywords' BitKeeper/etc/config
echo '%A%' > foo
cp foo bar
bk new $Q foo
bk commit $Q -ybasefoo
bk get $Q foo
bk fix -c $Q
cmp -s foo bar || {
	echo should not have expanded keywords
	sdiff -w40 foo bar
	exit 1
}
echo OK

echo $N Make sure files with spaces are OK ..........................$NL
echo "hi" > 'new file'
bk new $Q 'new file'
bk commit $Q -yy
bk edit $Q 'new file'
echo bye >> 'new file'
bk ci $Q -ybye 'new file'
bk commit $Q -ybye
bk fix -c $Q || {
	echo fix should not have failed
	exit 1
}
echo OK

# Create a cset that has an inc/exc in a file 
# bk fix -c it
# bk pull the cset and make sure we get a reasonable error message

cd $HERE
rm -rf project clone
echo $N Create initial repository and file with exclude .............$NL
no_logging project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
echo foo > foo
echo bar > bar.c
bk new $Q foo bar.c
bk commit $S -a -yCset
bk get -e -x1.1 $Q foo
bk delta -yexclude $Q foo
bk commit $S -a -yCset2
echo OK
cores

echo $N Clone repository ............................................$NL
bk clone $Q $HERE/project $HERE/clone
echo OK

echo $N Fix the cset, pull, should fill in and allow update .........$NL
cd $HERE/clone
bk stripdel $Q -C -r+ ChangeSet
bk admin -D foo
bk cset -M1.1..
bk -R sfiles -P >/dev/null
bk -r check -ac || exit 1

# What is happening is that we are pulling in the data which fills in the
# changeset around this delta.  The data is already in the local file and
# the keys match so we don't have to fill it in.  But we also don't mark
# the file as having D_CSET on the tip so it looks like it is pending and
# we try and commit it at the end and find that we already have this key
# in the ChangeSet file.
#
# We could either fail the update completely because of the pending delta
# or notice in applypatch that it isn't marked and fix the marks.
#
# If we are going to get clever we need to try and force a test with both
# local deltas should be pending and local deltas which should not be
# pending after the pull.
bk pull $Q > OUT 2>&1 || {
	cat OUT
	exit 1
}
echo OK

# Create a cset that has an inc/exc in a file 
# bk fix -c it and add another genuinely local change
# bk pull the cset and make sure we get a reasonable error message

cd $HERE
rm -rf project clone
echo $N Create initial repository and file with exclude .............$NL
no_logging project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
echo foo > foo
echo bar > bar.c
bk new $Q foo bar.c
bk commit $S -a -yCset
bk get -e -x1.1 $Q foo
bk delta -yexclude $Q foo
bk commit $S -a -yCset2
echo OK
cores

echo $N Clone repository ............................................$NL
bk clone $Q $HERE/project $HERE/clone
echo OK

echo $N Fix the cset, pull, should fail update due to pending .......$NL
cd $HERE/clone
bk stripdel $Q -C -r+ ChangeSet
bk admin -D foo
bk cset -M1.1..
bk edit $Q foo
bk delta $Q -ywhatever foo
bk -R sfiles -P >/dev/null
bk -r check -ac || exit 1

bk pull $Q > OUT 2>&1 && {
	echo should have failed
	cat OUT
	exit 1
}
grep -q "has uncommitted changes" OUT || {
	echo Bad error message
	cat OUT
	exit 1
}
echo OK

# Facetime fix bug when trying to fix a cset with a missing file.
echo $N Create a cset containing multiple files .....................$NL
cd $HERE
bk clone -q project facetime
cd facetime
# The names are important, we have to have a file sorted after kasplooey
for i in blech whoops zorro
do	echo $i > $i
	bk new $Q $i
done
bk commit $Q -ybaseline
bk edit $Q
for i in blech whoops zorro
do	echo change >> $i
done
bk ci $Q -ychange
bk commit $Q -ychange
echo OK

echo $N Remove one of the s.files and attempt a fix -c ..............$NL
rm -f SCCS/s.whoops
bk fix -c > OUT 2>&1
EXIT=$?
for i in blech zorro
do	test "${i}@1.2" = `bk prs -hr+ -nd:GFILE:@:REV: $i` || {
		echo should not have removed top delta in $i
		cat OUT
		exit 1
	}
done
grep -q 'File named by key' OUT || {
	echo bad message
	cat OUT
	exit 1
}
grep -q 'whoops' OUT || {
	echo bad message
	cat OUT
	exit 1
}
test $EXIT = 0 && {
	echo fix should have exited with an error
	exit 1
}
echo OK
exit 0

# This doesn't work, there is too much stuff that wants the gone file updated.
echo $N Try it again, forcing it past errors ........................$NL
bk fix -c -f > OUT 2>&1
for i in blech whoops zorro
do	test "${i}@1.1" = `bk prs -hr+ -nd:GFILE:@:REV: $i` || {
		echo should have removed top delta in $i
		bk sccslog
		exit 1
	}
	test -f SCCS/c.$i || {
		echo failed to save comments
		exit 1
	}
done
test $EXIT = 0 || {
	echo fix should have not exited with an error
	exit 1
}
echo OK
