# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# $image -u
# $image --upgrade
# $image relative
# $image absolute
# $image
# 
# We pick up the config from dotbk but don't leave it in config.
# We pick up the config from a repo, if present, but don't leave it in config.
# Install/upgrades fail if the license isn't accepted
# Upgrades do not install config files, they leave them.
#
# Not done yet:
# Installs do install embedded config files but no others.
# All files are read-only after the install/upgrade (XXX - leave config?)

BK_INSTALLER=
# Lazy way to get full path
find "`bk bin`/utils" -name 'bk*.exe' -o -name 'bk*.bin' > /tmp/bk$$
test `wc -l < /tmp/bk$$` -gt 1 && {
	echo You have too many bk images, skipping this test
	cat /tmp/bk$$
	$RM -f /tmp/bk$$
	exit 0
}
test `wc -l < /tmp/bk$$` -eq 1 && BK_INSTALLER="`cat /tmp/bk$$`"
$RM /tmp/bk$$
test "X$BK_INSTALLER" = X && exit 0

echo "license: $BKL_PRO" > c
echo "licsign1: $BKL_P1" >> c
echo "licsign2: $BKL_P2" >> c
echo "licsign3: $BKL_P3" >> c
DOTBK=`bk dotbk`
mv c "$DOTBK"/config || exit 1

if [ X$PLATFORM = X"WIN32" ]
then #-------------------- WIN32 tests ---------------------
echo $N Check registry is good and has been saved....................$NL
# make sure we haven't hosed the registry up to this point
. win32_common
win32_regDiff || {
	echo failed
	echo corrupt registry, aborting
	exit 1
}
echo OK
fi

echo $N Relative path installation, no config file...................$NL
rm -f "$DOTBK"/accepted
echo y | "$BK_INSTALLER" relative > OUT 2>&1
grep -q LICENSE OUT || {
	echo Did not prompt for license
	cat OUT
	exit 1
}
test -d relative || {
	echo did not create relative 
	cat OUT
	exit 1
}
test -f relative/config && {
	echo left config file
	cat OUT
	exit 1
}
echo OK

echo $N Absolute path installation, no config file...................$NL
rm -f "$DOTBK"/accepted
echo y | "$BK_INSTALLER" "$HERE/absolute" > OUT 2>&1
grep -q LICENSE OUT || {
	echo Did not prompt for license
	cat OUT
	exit 1
}
test -d absolute || {
	echo did not create relative 
	cat OUT
	exit 1
}
test -f absolute/config && {
	echo left config file
	cat OUT
	exit 1
}
echo OK

echo $N Refuse license, should fail and leave no installation .......$NL
rm -f "$DOTBK"/accepted
echo n | "$BK_INSTALLER" refuse > OUT 2>&1
grep -q LICENSE OUT || {
	echo Did not prompt for license
	cat OUT
	exit 1
}
test -d refuse && {
	echo did not create relative 
	cat OUT
	exit 1
}
echo OK

echo $N Use repo license rather than .bk/config, should work ........$NL
commercial repo
rm -f "$DOTBK"/accepted
mv "$DOTBK"/config "$HERE"
echo y | "$BK_INSTALLER" "$HERE/use_repo" > "$HERE/OUT" 2>&1
cd "$HERE"
grep -q LICENSE OUT || {
	echo Did not prompt for license
	cat OUT
	exit 1
}
test -d use_repo || {
	echo did not create use_repo 
	cat OUT
	exit 1
}
echo OK

echo $N Upgrade with installed config, leave it and it should work ..$NL
rm -f "$DOTBK"/accepted
# XXX - it would be nice if we looked in the destination for the config
# on upgrades.
cp "$HERE/config" "$DOTBK"/config
chmod +w absolute >/dev/null 2>&1	# SCO's chmod barfs
cp "$HERE/config" absolute
echo "foo: bar" >> absolute/config
OLDPATH="$PATH"
PATH="$HERE/absolute:$PATH"
export PATH
echo y | "$BK_INSTALLER" -u > OUT 2>&1
PATH="$OLDPATH"
export PATH
cd "$HERE"
grep -q LICENSE OUT || {
	echo Did not prompt for license
	cat OUT
	exit 1
}
test -f absolute/config || {
	echo should have left config file
	exit 1
}
grep -q "foo: bar" absolute/config || {
	echo stomped on config
	exit 1
}
echo OK

echo $N Embedded license, should leave config file...................$NL
rm -f "$DOTBK"/accepted "$DOTBK"/config
echo "license: $BKL_ACADEMIC" > c
echo "licsign1: $BKL_A1" >> c
echo "licsign2: $BKL_A2" >> c
echo "licsign3: $BKL_A3" >> c
cp "$BK_INSTALLER" bk-academic
bk inskeys bk-academic c > OUT 2>&1
grep -q 'Inserted keys into binary' OUT || {
	echo failed to run inskeys
	cat OUT
	wc c
	exit 1
}
echo y | ./bk-academic-licensed embedded > OUT 2>&1
grep -q LICENSE OUT || {
	echo Did not prompt for license
	cat OUT
	exit 1
}
test -d embedded || {
	echo did not create relative 
	cat OUT
	exit 1
}
test -f embedded/config || {
	echo did not leave config file
	cat OUT
	exit 1
}
echo OK

if [ X$PLATFORM = X"WIN32" ]
then #-------------------- WIN32 tests ---------------------
echo $N Make sure we preserve registry settings and use long paths...$NL
echo y | ./bk-academic-licensed "$HERE/DEAD BEEF" > OUT 2>&1 || {
	echo failed $?
	echo Installer failed to install
	cat OUT
	exit 1
}
bk _registry set $SHELLXKEY networkDrive 100 || exit 1
bk _registry set $SHELLXKEY LocalDrive 100 || exit 1

# We need the new BK to come first in the path, so we mangle it by hand
P=`bk _registry get "$SYSPATHKEY" Path`
P="$HERE/DEAD BEEF;$P"
bk _registry set "$SYSPATHKEY" Path expand_sz:"$P"
PATH="$P" ./bk-academic-licensed -u > OUT 2>&1 || {
	echo failed $?
	echo Installer failed to upgrade
	cat OUT
	exit 1
}
grep -qi "DEAD BEEF" OUT || {
	echo failed
	echo Installer used short path names e.g. dead~1
	cat OUT
	exit 1
}
grep -qi "docume~1" OUT && {
	echo failed
	echo Installer short path names e.g. docume~1
	cat OUT
	exit 1
}
bk _registry get "$SYSPATHKEY" Path | grep "DEAD BEEF" >TEXT || {
	echo failed
	echo Installer did not modify PATH
	cat TEXT
	tail -16 OUT
	exit 1
}
KEY1=`bk _registry get "$SHELLXKEY" networkDrive` || exit 1
KEY2=`bk _registry get "$SHELLXKEY" LocalDrive` || exit 1

if [ $KEY1 -ne 100 ]; then
	echo failed
	echo Failed to preserve networkDrive: $KEY1
	exit 1
fi
if [ $KEY2 -ne 100 ]; then
	echo failed
	echo Failed to preserve LocalDrive: $KEY2
	exit 1
fi
echo OK

echo $N Installer should honor command line options..................$NL
BK="$HERE/DEAD BEEF/bk"
echo y | "$BK" install -vf -s -l -n "$HERE/DEAD2" > OUT 2>&1 || {
	echo failed $?
	echo Installer failed to install
	cat OUT
	exit 1
}
KEY1=`bk _registry get "$SHELLXKEY" networkDrive` || exit 1
KEY2=`bk _registry get "$SHELLXKEY" LocalDrive` || exit 1

if [ $KEY1 -ne 1 ]; then
	echo failed
	echo Failed to set networkDrive: $KEY1
	exit 1
fi
if [ $KEY2 -ne 1 ]; then
	echo failed
	echo Failed to set LocalDrive: $KEY2
	exit 1
fi
CTRLPROV="HKEY_LOCAL_MACHINE\\Software\\SourceCodeControlProvider"
INSTPROV="HKEY_LOCAL_MACHINE\\Software\\SourceCodeControlProvider\\InstalledSCCProviders"
SCCKEY1=`bk _registry get "$BMKEY" SCCServerName` || exit 1
SCCKEY2=`bk _registry get "$BMKEY" SCCserverPath` || exit 1
PROVKEY1=`bk _registry get "$CTRLPROV" ProviderRegkey` || exit 1
PROVKEY2=`bk _registry get "$INSTPROV" BitKeeper` || exit 1
SCCPATH=`bk pwd -w "$HERE/DEAD2"`\\bkscc.dll

test "$SCCKEY1" = "BitKeeper" || {
	echo failed
	echo SCCServerName was "$SCCKEY1" instead of "BitKeeper"
	exit 1
}
test "$SCCKEY2" = "$SCCPATH" || {
	echo failed
	echo SCCServerPath was "$SCCKEY2" instead of "$SCCPATH"
	exit 1
}
PK1="SOFTWARE\\bitmover\\bitkeeper"
test "$PROVKEY1" = "$PK1" || {
	echo failed
	echo ProviderRegkey was "$PROVKEY1" instead of "$PK1"
	exit 1
}
test "$PROVKEY2" = "$PK1" || {
	echo failed
	echo InstalledSCCProviders was "$PROVKEY2" instead of "$PK1"
	exit 1
}
echo OK

echo $N Make sure uninstaller works as advertised....................$NL
BIN="$HERE/DEAD BEEF"
BK="$HERE/DEAD BEEF/bk"
VERSION=`bk _registry get "$BMKEY" rel`
# Make sure there is a BK installed in BIN
test -f "$BK" || {
	echo failed
	echo There is no BK in $BIN
	exit 1
}
"$BK" uninstall -f >OUT 2>&1
test -d "$BIN" && {
	echo failed
	echo "$BIN" still exists
	cat OUT
	exit 1
}
# make sure PATH doesn't have BK in it
if [ "x$OLDUSRPATH" != "xentry not found" ];
then	bk _registry get "$USRPATHKEY" Path | grep "DEAD BEEF" > TEXT && {
		echo failed
		echo BitKeeper left in User PATH
		cat TEXT OUT
		exit 1
	}
fi
bk _registry get "$SYSPATHKEY" Path | grep "DEAD BEEF" > TEXT && {
	echo failed
	echo BitKeeper left in System PATH
	cat TEXT OUT
	exit 1
}
# Make sure we're not polluting the Uninstall area
bk _registry get "$UNINSTALLKEY" $VERSION | grep "DEAD BEEF" > TEXT && {
	echo failed
	echo BitKeeper left crud in the Uninstall registry key
	cat TEXT OUT
	exit 1
}
echo OK

echo $N Uninstaller in upgrade mode should not remove everything.....$NL
./bk-academic-licensed "$HERE/DEADBEEF" >OUT 2>&1
bk _registry get "$SYSPATHKEY" Path | grep "DEADBEEF" > TEXT || {
	echo failed
	echo Installer did not install PATH
	cat TEXT OUT
	exit 1
}
test -f "$HERE/DEADBEEF/bk" || {
	echo failed
	echo Installer failed to install
	cat OUT
	exit 1
}
BK="$HERE/DEADBEEF/bk"
"$BK" uninstall -u >OUT 2>&1 || {
	echo failed $?
	echo Uninstaller in upgrade mode
	cat OUT
	exit 1
}
# make sure PATH STILL has BK in it
if [ "x$OLDUSRPATH" != "xentry not found" ];
then	bk _registry get "$USRPATHKEY" Path | grep "DEADBEEF" > TEXT || {
		echo failed
		echo Uninstaller in upgrade mode removed BK from USRPATH
		cat TEXT OUT
		exit 1
	}
fi
bk _registry get "$SYSPATHKEY" Path | grep "DEADBEEF" > TEXT || {
	echo failed $?
	echo Uninstaller in upgrade mode removed BK from SYSPATH
	bk _registry get "$SYSPATHKEY" Path
	cat TEXT OUT
	exit 1
}
echo OK

echo $N Restoring registry...........................................$NL
# we know we corrupt the registry, so put it back
win32_regRestore || exit 1
echo OK

else #-------------------- UNIX tests ---------------------
echo $N Make sure uninstaller removes subdirs........................$NL
BIN="$HERE/DEADBEEF"
echo y | ./bk-academic-licensed "$HERE/DEADBEEF" >OUT 2>&1
test -f "$HERE/DEADBEEF/bk" || {
	echo failed
	echo installer failed
	cat OUT
	exit 1
}
find "$HERE/DEADBEEF" -type d -exec chmod 555 {} \;
chmod 777 "$HERE/DEADBEEF"
"$BIN/bk" uninstall -f || {
	echo failed
	echo bk uninstall failed
	chmod -R +w "$HERE/DEADBEEF"
	exit 1
}
test -d "$HERE/DEADBEEF" && {
	# some platforms, like hp11, need some time,
	# because a background process is spawned to clean up
	# bk after bk exits.
	times=5
	while [ "$times" -ne 0 ]; do
		sleep 1
		times=`expr $times - 1`
		test -d "$HERE/DEADBEEF" || break
	done
	test -d "$HERE/DEADBEEF" && {
		echo failed
		echo did not obliterate "$HERE/DEADBEEF"
		chmod -R +w "$HERE/DEADBEEF"
		exit 1
	}
}
echo OK

echo $N Make sure uninstaller removes symlinks.......................$NL
BIN="$HERE/DEADBEEF.1"
echo y | ./bk-academic-licensed "$BIN" >OUT 2>&1
test -f "$BIN/bk" || {
	echo failed
	echo installer failed
	cat OUT
	exit 1
}
mkdir "$HERE/bin"
"$BIN/bk" links "$HERE/bin" >OUT 2>&1 || {
	echo failed
	echo could not create symlinks
	cat OUT
	exit 1
}
export PATH="$HERE/bin:$PATH"
"$BIN/bk" uninstall -f || {
	echo failed
	echo bk uninstall failed
	exit 1
}
test -h "$HERE/bin/bk" && {
	echo failed
	echo left symlinks
	ls "$HERE/bin" | tr '\n' ' '
	echo ""
	exit 1
}
echo OK

echo $N Uninstaller in upgrade mode should not remove symlinks.......$NL
BIN="$HERE/DEADBEEF.2"
echo y | ./bk-academic-licensed "$BIN" >OUT 2>&1
test -f "$BIN/bk" || {
	echo failed
	echo installer failed
	cat OUT
	exit 1
}
# Make sure there are symlinks
"$BIN/bk" links "$HERE/bin" >OUT 2>&1 || {
	echo failed
	echo could not create symlinks
	cat OUT
	exit 1
}
export PATH="$HERE/bin:$PATH"
"$BIN/bk" uninstall -u >OUT 2>&1 || {
	echo failed
	echo Uninstaller in upgrade mode failed
	cat OUT
	exit 1
}
times=2
while [ -d "$BIN" ]; do
	test $times -eq 0 && {
		echo failed to uninstall
		exit 1
	}
	times=`expr $times - 1`
	sleep 1
done
test -h "$HERE/bin/admin" || {
	echo failed
	echo Uninstaller in upgrade mode removed symlinks
	exit 1
}
echo OK
fi

#####################################################################
# Careful!!!!
#####################################################################
cd "$HERE"
chmod -R +w * >/dev/null 2>&1	# SCO's chmod barfs
rm -rf *
