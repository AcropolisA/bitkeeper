# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Copyright (c) 2000 Larry McVoy
# %K%

# Create a repository 
echo $N Create initial repository ...................................$NL
commercial project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
touch BitKeeper/etc/SCCS/x.marked
echo OK

echo $N Create some data ............................................$NL
echo 1 > A
echo 2 > B
bk ci $Q -i A B
if [ ! -f SCCS/s.A ]; then echo failed to create history; exit 1; fi
bk commit $S -y"This is a \"Change Set\""
echo OK

echo $N Make sure zero sized z.locks are respected ..................$NL
bk edit $Q A
touch SCCS/z.A
bk delta $Q -y'should fail' A > /dev/null 2>&1
if [ ! -f SCCS/z.A ]; then echo failed, removed zlock; exit 1; fi
if [ ! -w A ]; then echo failed, removed A; exit 1; fi
echo OK

echo $N Make sure stale zlocks are discarded ........................$NL
bk mklock > SCCS/z.A 
#bk delta $Q -y'should work' A > /dev/null 2>&1
bk delta $Q -y'should work' A 
if [ -f SCCS/z.A ]; then echo failed to remove zlock; exit 1; fi
if [ -f A ]; then echo failed to remove A; exit 1; fi
echo OK

echo $N Check edit with existing stale read lock ....................$NL
bk lock -tr >L &
bk lock -L
LOCKURL=`cat L`
bk edit $Q A 2> /dev/null
if [ ! -w A ]; then echo failed to get writable file; exit 1; fi
bk clean A
bk _kill $LOCKURL
bk lock -U
echo OK

echo $N Check edit with existing stale write lock ...................$NL
if [ -d BitKeeper/readers ]
then	echo failed to clean up read lock; ls -l BitKeeper/readers; exit 1
fi
bk lock -tw >L &
bk lock -L
LOCKURL=`cat L`
bk edit $Q A 2> /dev/null
if [ ! -w A ]; then echo failed to get writable file; exit 1; fi
bk _kill $LOCKURL
bk lock -U
echo OK

echo $N Check edit with existing valid read lock ....................$NL
bk clean A
bk lock -tr >L &
bk lock -L
LOCKURL=`cat L`
mv BitKeeper/readers/* BitKeeper/readers/1234@nowhere.nowhere
bk edit $Q A
writable A || { echo failed to lock A; exit 1; }
echo OK

echo $N Make sure delta fails with existing read lock ...............$NL
bk delta $Q -yXXX A 2> OUT
test -w A || {
	echo failed to fail delta
	cat OUT
	exit 1
}
echo OK

echo $N Make sure clean works with existing read lock ...............$NL
bk clean $Q A 
if [ -w A ]; then echo failed to clean; exit 1; fi
echo OK

echo $N Check edit with existing valid write lock ...................$NL
bk _kill $LOCKURL
bk unlock -r
bk lock -U
rm -rf BitKeeper/writer
mkdir BitKeeper/writer
echo 1234 nowhere.nowhere 2147480000 > BitKeeper/writer/1234@nowhere.nowhere.lock
ln BitKeeper/writer/1234@nowhere.nowhere.lock BitKeeper/writer/lock
bk edit $Q A
writable A || { echo failed to lock A; exit 1; }
test -f BitKeeper/writer/lock || {
	echo write lock is gone
	exit 1
}
test -f BitKeeper/writer/1234@nowhere.nowhere.lock || {
	echo BitKeeper/writer/1234@nowhere.nowhere.lock is gone
	exit 1
}
echo OK

echo $N Make sure delta fails with existing write lock ..............$NL
bk lock -l > LOCKS 2>&1
bk delta $Q -yXXX A 2> OUT
test -w A || {
	echo failed to fail delta
	echo LOCKS:
	cat LOCKS
	echo DELTA OUTPUT
	cat OUT
	exit 1
}
echo OK

echo $N Make sure clone fails with existing write lock in source ....$NL
cd $HERE
bk clone $Q project clone 2>/dev/null
if [ -d clone ]; then echo clone failed to clean up; exit 1; fi
echo OK

echo $N Make sure clone fails with existing write lock in source \#2 .$NL
cd $HERE/project
P=`port 50000`
bk bkd -d -p$P -ikill 2>/dev/null
cd $HERE
bk clone bk://localhost:$P clone 2> clone.out
echo "ERROR-Can't get read lock on the repository." > ref
cmp -s clone.out ref || {
	echo Failed
	diff clone.out ref
	exit 1
}
if [ -d clone ]; then echo clone failed to clean up; exit 1; fi
bk _kill bk://localhost:$P || exit 1
echo OK

echo $N Make sure clone works with existing read lock in source .....$NL
cd $HERE/project
bk unlock -w
bk lock -U
bk lock -tr >L &
bk lock -L
LOCKURL=`cat L`
mv BitKeeper/readers/* BitKeeper/readers/1234@nowhere.nowhere
cd $HERE
bk clone $Q project clone 2>/dev/null
EXIT=$?
if [ $EXIT != 0 ]; then echo failed with exit $EXIT; exit 1; fi
if [ ! -d clone -o ! -f clone/SCCS/s.A ]; then echo clone failed; exit 1; fi
if [ ! -f clone/BitKeeper/log/parent ]; then echo clone failed to set parent; exit 1; fi
echo OK

echo $N Make sure clone works with existing read lock in source \#2 ..$NL
cd $HERE
#bk clone $Q bk://localhost:$P clone2 2>/dev/null
bk clone $Q project clone2
EXIT=$?
if [ $EXIT != 0 ]; then echo failed with exit $EXIT; exit 1; fi
if [ ! -d clone2 -o ! -f clone2/SCCS/s.A ]; then echo clone2 failed; exit 1; fi
if [ ! -f clone2/BitKeeper/log/parent ]; then echo clone2 failed to set parent; exit 1; fi
echo OK

echo $N Make sure pull fails with global write lock .................$NL
cd $HERE/project
bk _kill $LOCKURL
bk unlock -r
bk lock -U
ls > C
bk new $Q C
bk commit $Q -ywhatever
touch $HERE/write_lock
cd $HERE/clone
BK_WRITE_LOCK=$HERE/write_lock bk pull -t -c0 $Q >/dev/null 2>&1
if [ $? != 1 ]; then echo pull failed to exit with error; exit 1; fi
echo OK

echo $N Make sure pull fails with existing write lock in source .....$NL
cd $HERE/project
ls > CC
bk new $Q CC
bk commit $Q -ywhatever
bk lock -tw >L &
bk lock -L
LOCKURL=`cat L`
cd $HERE/clone
bk pull -t -c0 $Q 2>/dev/null
if [ $? != 1 ]; then echo pull failed to exit with error; exit 1; fi
echo OK

echo $N Make sure pull works with existing read lock in source ......$NL
cd $HERE/project
bk _kill $LOCKURL
bk lock -U
bk lock -tr >L &
bk lock -L
LOCKURL=`cat L`
mv BitKeeper/readers/* BitKeeper/readers/1234@nowhere.nowhere
cd $HERE/clone
bk pull -t $Q -R 2>/dev/null
if [ ! -d RESYNC ]; then echo pull failed; exit 1; fi
bk resolve -t $Q || exit 1
echo OK

echo $N Make sure pull works with existing read lock in source \#2 ...$NL
cd $HERE/clone2
bk pull -t -R  > XXX 2>&1
if [ ! -d RESYNC ]; then echo pull failed; cat XXX; exit 1; fi
bk resolve -t $Q
echo OK

echo $N Make sure push fails with existing read lock in dest ........$NL
cd $HERE/clone
ls > D
bk new $Q D
bk commit $Q -ywhatever
bk push -c0 $Q
if [ $? != 1 ]; then echo push failed to exit with an error; exit 1; fi
echo OK

echo $N Make sure push fails with global read lock ..................$NL
cd $HERE/project
bk _kill $LOCKURL
bk unlock -r
bk lock -U
cd $HERE/clone
touch $HERE/read_lock
BK_READ_LOCK=$HERE/read_lock bk push -c0 > OUT 2>&1 && {
	echo push failed to exit with an error
	cat OUT
	kill $LOCKPID
	exit 1
}
grep -q 'ERROR-Unable to lock repository for update.' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK

echo $N Make sure push fails with global write lock .................$NL
cd $HERE/clone
BK_WRITE_LOCK=$HERE/write_lock bk push -c0 > OUT 2>&1 && {
	echo push failed to exit with an error
	cat OUT
	kill $LOCKPID
	exit 1
}
grep -q 'Global write lock .*/write_lock' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK

echo $N Make sure push fails with existing write lock in dest .......$NL
cd $HERE/project
bk lock -tw >L &
bk lock -L
LOCKURL=`cat L`
cd $HERE/clone
bk push -c0 > OUT 2>&1 && {
	echo push failed to exit with an error
	cat OUT
	bk _kill $LOCKURL
	exit 1
}
grep -q 'ERROR-Unable to lock repository for update.' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
cd $HERE/project
bk _kill $LOCKURL
bk lock -U
echo OK

echo $N Make sure push succeeds with no locks in destination ........$NL
cd $HERE/clone
bk push $Q
if [ $? != 0 ]; then echo push exited with an error; exit 1; fi
cd $HERE/project
bk pull -t $HERE/clone > OUT 2>&1
grep -q 'Nothing to pull' OUT || {
	echo failed - bad status message
	cat OUT
	exit 1
}
echo OK

echo $N Make sure commit respects global read lock ..................$NL
bk co $Q -l D
date > D
bk ci $Q -ynew_styff D
BK_READ_LOCK=$HERE/read_lock bk commit $Q -y"should-failed" > commit.out 2>&1
if [ $? -eq 0 ]; then echo failed; exit 1; fi
grep -q 'ERROR-Unable to lock repository for update.' commit.out || {
	echo unexpected error message
	cat commit.out
	exit 1
}
BK_READ_LOCK=$HERE/read_lock bk lock -l > OUT 2>&1
grep -q 'Global read lock .*/read_lock' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK

echo $N Make sure commit respects global write lock .................$NL
bk co $Q -l D
date > D
bk ci $Q -ynew_styff D
BK_WRITE_LOCK=$HERE/write_lock bk commit $Q -y"should-failed" > commit.out 2>&1
if [ $? -eq 0 ]; then echo failed; exit 1; fi
grep -q 'ERROR-Unable to lock repository for update.' commit.out || {
	echo unexpected error message
	cat commit.out
	exit 1
}
BK_WRITE_LOCK=$HERE/write_lock bk lock -l > OUT 2>&1
grep -q 'Global write lock .*/write_lock' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK


echo $N Make sure commit respects repository lock ...................$NL
bk co $Q -l D
date > D
bk ci $Q -ynew_styff D
mkdir -p $HERE/project/RESYNC/stuff
bk commit $Q -y"should-failed" > commit.out 2>&1
if [ $? -eq 0 ]; then echo failed; exit 1; fi
grep -q 'ERROR-Unable to lock repository for update.' commit.out || {
	echo unexpected error message
	cat commit.out
	exit 1
}
echo OK

echo $N Parallel lock tests .........................................$NL
for i in 1 2 3 4
do	bk _locktest LOCK 100 &
done > OUT 2>&1
wait
grep O_EXCL OUT && exit 1
echo OK
