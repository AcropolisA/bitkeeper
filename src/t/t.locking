# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Copyright (c) 2000 Larry McVoy
# %K%

# Create a repository 
echo $N Create initial repository ...................................$NL
HERE=`pwd`
echo "logging: none" > $HERE/config
bk setup -f -n'BitKeeper Test repository' -c$HERE/config project
if [ ! -d project ]; then echo failed to make top level directory; exit 1; fi
cd project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
touch BitKeeper/etc/SCCS/x.marked
echo OK
echo $N Create some data ............................................$NL
echo 1 > A
echo 2 > B
bk ci $Q -i A B
if [ ! -f SCCS/s.A ]; then echo failed to create history; exit 1; fi
bk commit $S -f -y"This is a \"Change Set\""
echo OK
echo $N Make sure zero sized z.locks are respected ..................$NL
bk edit $Q A
touch SCCS/z.A
bk delta $Q -y'should fail' A > /dev/null 2>&1
if [ ! -f SCCS/z.A ]; then echo failed, removed zlock; exit 1; fi
if [ ! -w A ]; then echo failed, removed A; exit 1; fi
echo OK
echo $N Make sure stale zlocks are discarded ........................$NL
bk mklock > SCCS/z.A 
#bk delta $Q -y'should work' A > /dev/null 2>&1
bk delta $Q -y'should work' A 
if [ -f SCCS/z.A ]; then echo failed to remove zlock; exit 1; fi
if [ -f A ]; then echo failed to remove A; exit 1; fi
echo OK
echo $N Check edit with existing stale read lock ....................$NL
bk lock -r &
while bk lock; do true; done
bk edit $Q A 2> /dev/null
if [ ! -w A ]; then echo failed to get writable file; exit 1; fi
bk clean A
echo OK
echo $N Check edit with existing stale write lock ...................$NL
bk unlock -r 2> /dev/null
if [ -d BitKeeper/readers ]
then	echo failed to clean up read lock; exit 1
fi
bk lock -w &
while bk lock; do true; done
bk edit $Q A 2> /dev/null
if [ ! -w A ]; then echo failed to get writable file; exit 1; fi
echo OK
echo $N Check edit with existing valid read lock ....................$NL
bk clean A
bk unlock -w
bk lock -r &
while bk lock; do true; done
mv BitKeeper/readers/* BitKeeper/readers/1234@nowhere.nowhere
bk edit $Q A
#if [ ! -w A ]; then echo failed to lock A; fi
writable A || { echo failed to lock A; }
echo OK
echo $N Make sure delta fails with existing read lock ...............$NL
bk delta $Q -yXXX A 2> /dev/null
if [ ! -w A ]; then echo failed to fail delta; exit 1; fi
echo OK
echo $N Make sure clean works with existing read lock ...............$NL
bk clean $Q A 
if [ -w A ]; then echo failed to clean; exit 1; fi
echo OK
echo $N Check edit with existing valid write lock ...................$NL
bk unlock -r
bk lock -w &
while bk lock; do true; done
rm -f BitKeeper/writer/lock
mv BitKeeper/writer/* BitKeeper/writer/1234@nowhere.nowhere
ln BitKeeper/writer/1234@nowhere.nowhere BitKeeper/writer/lock
bk edit $Q A
if [ ! -w A ]; then echo failed to lock A; fi
echo OK
echo $N Make sure delta fails with existing write lock ..............$NL
bk delta $Q -yXXX A 2> /dev/null
if [ ! -w A ]; then echo failed to fail delta; exit 1; fi
echo OK
echo $N Make sure clone fails with existing write lock in source ....$NL
cd $HERE
bk clone $Q project clone 2>/dev/null
if [ -d clone ]; then echo clone failed to clean up; exit 1; fi
echo OK
echo $N Make sure clone fails with existing write lock in source \#2 .$NL
cd $HERE/project
P=50000
bk bkd -d -p$P -t120 2>/dev/null
while [ $? -eq 2 ]
do	P=`expr $P + 1`
	bk bkd -d -p$P -t120 2>/dev/null
done
cd $HERE
bk clone $Q bk://localhost:$P clone 2>/dev/null
if [ -d clone ]; then echo clone failed to clean up; exit 1; fi
echo OK
echo $N Make sure clone works with existing read lock in source .....$NL
cd $HERE/project
bk unlock -w
bk lock -r &
while bk lock; do true; done
mv BitKeeper/readers/* BitKeeper/readers/1234@nowhere.nowhere
cd $HERE
bk clone $Q project clone 2>/dev/null
EXIT=$?
if [ $EXIT != 0 ]; then echo failed with exit $EXIT; exit 1; fi
if [ ! -d clone -o ! -f clone/SCCS/s.A ]; then echo clone failed; exit 1; fi
if [ ! -f clone/BitKeeper/log/parent ]; then echo clone failed to set parent; exit 1; fi
echo OK
echo $N Make sure clone works with existing read lock in source \#2 ..$NL
cd $HERE
#bk clone $Q bk://localhost:$P clone2 2>/dev/null
bk clone $Q project clone2
EXIT=$?
if [ $EXIT != 0 ]; then echo failed with exit $EXIT; exit 1; fi
if [ ! -d clone2 -o ! -f clone2/SCCS/s.A ]; then echo clone2 failed; exit 1; fi
if [ ! -f clone2/BitKeeper/log/parent ]; then echo clone2 failed to set parent; exit 1; fi
echo OK
echo $N Make sure pull fails with existing write lock in source .....$NL
cd $HERE/project
rm -rf BitKeeper/readers BitKeeper/writer
ls > C
bk new $Q C
bk commit $Q -ywhatever
bk lock -w &
while bk lock; do true; done
cd $HERE/clone
bk pull -t $Q 2>/dev/null
if [ $? != 1 ]; then echo pull failed to exit with error; exit 1; fi
echo OK
echo $N Make sure pull works with existing read lock in source ......$NL
cd $HERE/project
bk unlock -w
bk lock -r &
while bk lock; do true; done
mv BitKeeper/readers/* BitKeeper/readers/1234@nowhere.nowhere
cd $HERE/clone
bk pull -t $Q -r 2>/dev/null
if [ ! -d RESYNC ]; then echo pull failed; exit 1; fi
bk resolve -t $Q
echo OK
echo $N Make sure pull works with existing read lock in source \#2 ...$NL
cd $HERE/clone2
bk pull -t -r  2>XXX
if [ ! -d RESYNC ]; then echo pull failed; cat XXX; exit 1; fi
bk resolve -t $Q
echo OK
echo $N Make sure push fails with existing read lock in dest ........$NL
cd $HERE/clone
ls > D
bk new $Q D
bk commit $Q -ywhatever
bk push $Q
if [ $? != 1 ]; then echo push failed to exit with an error; exit 1; fi
echo OK
echo $N Make sure push fails with existing write lock in dest .......$NL
cd $HERE/project
rm -rf BitKeeper/readers BitKeeper/writer
bk lock -w &
while bk lock; do true; done
cd $HERE/clone
bk push $Q
if [ $? != 1 ]; then echo push failed to exit with an error; exit 1; fi
echo OK
echo $N Make sure push succeeds with no locks in destination ........$NL
cd $HERE/project
rm -rf BitKeeper/readers BitKeeper/writer
cd $HERE/clone
bk push $Q
if [ $? != 0 ]; then echo push exited with an error; exit 1; fi
cd $HERE/project
bk pull -t $HERE/clone > OUT 2>&1
if [ "`cat OUT`" != "Nothing to pull." ]
then	echo failed - bad status message
	cat OUT
	exit 1
fi
echo OK
