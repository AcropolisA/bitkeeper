# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Copyright (c) 1999 Larry McVoy
# %K%

${RM} -rf FILE SCCS
R=1
for D in '87/05/28 23:49:57' '97/05/28 23:49:57' '97/05/30 01:34:11' '97/06/23 01:33:45+06:30' '98/01/30 17:45:17-05:00'
do	${CAT} > INITX <<EOF
D 1.$R $D $USER 0 0 0/0/0
c This is revision 1.$R of $D
c This the second comment of 1.$R
P this/is/the/pathname.$R
------------------------------------------------
EOF
	echo 1.$R >> FILE
	if [ $R -eq 1 ]
	then	bk delta $Q -i -IINITX FILE
	else	bk delta $Q -IINITX FILE
	fi
	R=`expr $R + 1`
	bk co $Q -l FILE
done
bk clean FILE
bk co  $Q -l -r1.3 FILE
echo "added in 1.3.1.1" >> FILE
bk ci $Q -y FILE
bk co $Q -l -r1.3.1 FILE
echo "added in 1.3.1.2" >> FILE
bk ci $Q -y FILE
echo $N 'Check get -M (1 node from GCA)...............................'$NL
bk get $Q -e -r1.5 -M1.3.1.1 FILE
bk delta $Q -y FILE
${ECHO} 6 > CMP1
bk prs -h -r1.6 -d':MGP:' FILE > CMP2
cmp -s CMP1 CMP2
if [ $? -ne 0 ]; then echo Failed.; exit 1; fi
echo OK
echo $N 'Check get -M (2 node from GCA)...............................'$NL
${CAT} > CMP1 << EOF
1.1
1.2
1.3
added in 1.3.1.1
added in 1.3.1.2
1.4
1.5
EOF
bk get $Q -e -r1.6 -M1.3.1.2 FILE
cmp -s CMP1 FILE
if [ $? -ne 0 ]; then echo Failed.; exit 1; fi
bk delta $Q -y FILE
${ECHO} 7 > CMP1
bk prs -h -r1.7 -d':MGP:' FILE > CMP2
cmp -s CMP1 CMP2
if [ $? -ne 0 ]; then echo Failed.; exit 1; fi
echo OK
echo $N 'Check co -M (2 node from GCA)................................'$NL
bk co $Q -l -r1.7 -M1.3.1.2 FILE
bk ci $Q -y FILE
${ECHO} 7 > CMP1
bk prs -h -r1.8 -d':MGP:' FILE > CMP2
cmp -s CMP1 CMP2
if [ $? -ne 0 ]; then echo Failed.; exit 1; fi
echo OK
echo $N Check admin -M ..............................................$NL
bk get $Q -e -i1.3.1.1 FILE
bk delta $Q -y FILE
bk admin -M1.3.1.1 FILE
${ECHO} 6 > CMP1
bk prs -h -r1.9 -d':MGP:' FILE > CMP2
cmp -s CMP1 CMP2
if [ $? -ne 0 ]; then echo Failed.; exit 1; fi
echo OK
echo $N Check admin -r -M ...........................................$NL
bk admin -r1.8 -M1.3.1.1 FILE
${ECHO} 6 > CMP1
bk prs -h -r1.8 -d':MGP:' FILE > CMP2
cmp -s CMP1 CMP2
if [ $? -ne 0 ]; then echo Failed.; exit 1; fi
echo OK
# Do some SET merge tests.  Test one:
#   Build on FILE with branches where elements get -x , then do -M
#   -x elements should not reappear.
echo $N Merge with delta on branch excluded on branch ...............$NL
get $Q -e -r1.3.1 FILE
echo DISAPPEAR >> FILE
delta $Q -y1.3.1.3 FILE
get $Q -e -r1.3.1 -x1.3.1.3 FILE
delta $Q -y1.3.1.4 FILE
get $Q -e -M1.3.1.4 FILE
grep -q DISAPPEAR FILE
if [ $? -eq 0 ]; then echo Failed locked; exit 1; fi
delta $Q -y FILE
get $Q FILE
grep -q DISAPPEAR FILE
if [ $? -eq 0 ]; then echo Failed unlocked; exit 1; fi
echo OK
# Do a weird graph, in the sense that it is knocking out things
# it doesn't even have.  This isn't as much a test of the set gca
# as when we get to the merge stuff.  Need to handle this case.
echo $N Merge a graph with some weird pathalogical -i and -x ........$NL
echo 1.1 > bar.c
ci $Q -i bar.c
if [ ! -f SCCS/s.bar.c ]; then echo failed to create history; exit 1; fi
get $Q -e bar.c
echo 1.2 >> bar.c
delta $Q -y1.2 bar.c
# make 2 new branches and include trunk 1.2 into each
get $Q -e -i1.2 -r1.1 bar.c
echo 1.1.1.1 >> bar.c
delta $Q -y1.1.1.1 bar.c
get $Q -e -i1.2 -r1.1 bar.c
echo 1.1.2.1 >> bar.c
delta $Q -y1.1.2.1 bar.c
# add to branch, excluding something from the other side
get $Q -e -x1.1.2.1 -r1.1.1 bar.c
echo 1.1.1.2 >> bar.c
delta $Q -y1.1.1.2 bar.c
get $Q -e -x1.1.1.1 -r1.1.2 bar.c
echo 1.1.2.2 >> bar.c
delta $Q -y1.1.2.2 bar.c
# do a merge of 1.1.1 and 1.1.2 branches, see what happens
get $Q -e -r1.1.1.2 -M1.1.2.2 bar.c
echo 1.1.1.3 >> bar.c
delta $Q -y1.1.1.3 bar.c
get $Q -r1.1.1 bar.c
cat - <<EOF > CMP1
1.1
1.1.2.2
1.1.1.2
1.1.1.3
EOF
cmp -s bar.c CMP1
# will pass if a real 2 parent SCCS merge
if [ $? -ne 0 ]; then echo Failed; exit 1; fi
echo OK
