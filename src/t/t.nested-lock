echo $N Test basic lock/unlock operations............................$NL
nested product
NLOCK=`bk lock -Ppidfile -Wt`
PID=`cat pidfile`
test -f BitKeeper/writer/nested_lock || fail
bk lock -l 2>&1 | tee X | grep -q "Write locked" || fail -f X
grep -q "$PID" X || fail -f X
bk _kill $NLOCK
test -f BitKeeper/writer/nested_lock && fail
bk lock -l 2>&1 | tee X | grep -q "No active lock in repository" || fail -f X
test -d RESYNC && fail
NLOCK=`bk lock -Ppidfile -Rt`
PID=`cat pidfile`
test -d BitKeeper/readers || fail
test 1 = `ls BitKeeper/readers | wc -l` || fail
test -d RESYNC || fail
bk lock -l 2>&1 | tee X | grep -q "Read locked" || fail -f X
grep -q "$PID" X || fail -f X
# Grab another one
NLOCK2=`bk lock -Ppidfile -Rt`
PID2=`cat pidfile`
test 2 = `ls BitKeeper/readers | wc -l` || fail `ls BitKeeper/readers`
bk lock -l 2>&1 | tee X | grep -q "$PID2" || fail -f X
grep -q "$PID" X || fail -f X
bk _kill $NLOCK2
test 1 = `ls BitKeeper/readers | wc -l` || fail
bk lock -l 2>&1 | tee X | grep -q "$PID2" && fail -f X
bk _kill $NLOCK
test -d BitKeeper/readers && fail
test -d RESYNC && fail
bk lock -l 2>&1 | tee X | grep -q "No active lock in repository" || fail -f X
echo OK

echo $N Test corrupt lock gets staled................................$NL
NLOCK=`bk lock -Ppidfile -Wt 2> LOCKMSG`
PID=`cat pidfile`
test -f BitKeeper/writer/nested_lock || fail
echo "corrupt lock" > BitKeeper/writer/nested_lock
NLOCK2=`bk lock -Ppidfile -Wt`
PID2=`cat pidfile`
bk lock -l 2>&1 | tee X | grep -q "$PID" && fail -f X
grep -q "$PID2" X || fail -f X
# nested unlock should refuse to unlock the wrong lock
bk _kill $NLOCK
grep -q "lock does not match this lock" LOCKMSG || fail -f LOCKMSG
bk _kill $NLOCK2
echo OK

echo $N Test stale write lock is cleared.............................$NL
_BK_LEAVE_LOCKED=1
export _BK_LEAVE_LOCKED
NLOCK=`bk lock -Ppidfile -Wt 2> LOCKMSG`
PID=`cat pidfile`
bk lock -l 2>&1 | grep -q "$PID" || fail did not lock
bk _kill $NLOCK
c=0
while bk _kill -0 $PID
do	bk _usleep 1000
	c=`expr $c + 1`
	test $c = 10 && fail too many retries
done
test -f BitKeeper/writer/nested_lock || fail did not leave locked
bk lock -l 2>&1 | grep -q "$PID" && fail did not clear stale lock
_BK_LEAVE_LOCKED=
export _BK_LEAVE_LOCKED
echo OK

echo $N Test we do not go into an infinite loop......................$NL
cd "$HERE"
bk clone $Q product child
cd product/gcc
touch afile
bk new $Q afile
bk commit $Q -yafile
cd ..
bk commit $Q -yafile
cd "$HERE/child"
# pull, but don't apply
bk pull $Q -R
# I need to remove the BitKeeper dir from gcc
# so that the abort code thinks it's already been
# applied
rm -rf gcc/RESYNC
_BK_LEAVE_LOCKED=1
export _BK_LEAVE_LOCKED
NLOCK=`bk lock -Ppidfile -Wt 2> LOCKMSG`
PID=`cat pidfile`
bk lock -l 2>&1 | grep -q "$PID" || fail did not lock
bk _kill $NLOCK
c=0
while bk _kill -0 $PID
do	bk _usleep 1000
	c=`expr $c + 1`
	test $c = 10 && fail too many retries
done
test -f BitKeeper/writer/nested_lock || fail did not leave locked
bk lock -l 2>&1 | tee LOUT | grep -q "$PID" && fail did not clear stale lock
grep -q "Forced Shutdown. Recursed too deep." LOUT && \
	fail -f LOUT infinite loop killed bk
_BK_LEAVE_LOCKED=
export _BK_LEAVE_LOCKED
echo OK
