# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2008 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
#
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

echo $N Create an ensemble...........................................$NL
nested project
touch amerge
bk new $Q amerge
# add some files
cd "$HERE/project/gcc"
for i in 1 2 3 4 5
do
	touch file$i
	echo "stuff $i" > file$i
	bk new $Q -y"add" file$i
done
bk commit -S $Q -y"Add $i to file$i"
cd "$HERE/project" && bk commit -S $Q -y"Commit cset in gcc"
cd "$HERE/project/gdb"
for i in 1 2 3 4 5
do
	touch file$i
	echo "stuff $i" > file$i
	bk new $Q -y"add" file$i
	bk commit -S $Q -y"add file $i"
done
cd "$HERE/project" && bk commit $Q -y"add csets to gdb"
echo OK

echo $N Try a null pull..............................................$NL
cd "$HERE"
bk clone $Q project null-pull
cd "$HERE/null-pull"
bk pull >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
grep -q "Nothing to pull." OUT || {
	echo failed
	cat OUT
	exit 1
}
echo OK

echo $N Try a simple pull............................................$NL
cd "$HERE"
bk clone $Q project copy
bk clone $Q project twin
cd "$HERE/project"
bk parent $Q -a ../copy ../twin
cd ..
# multiple parents
for proj in copy twin
do
	# add some csets to gcc
	cd $proj/gcc || exit 2
	for i in 1 2 3 4 5
	do
		bk edit $Q file$proj$i || true
		echo "new stuff $i" >> file$proj$i
		bk delta $Q -a -y"modify" file$proj$i
		bk commit -S $Q -y"Add $i to file$proj$i"
	done
	cd ..
	bk commit -S $Q -y"more stuff to gcc"
	cd ..
done
cd "$HERE/project"
bk pull $Q || {
	echo failed
	exit 1
}
test -z "`bk changes -qR`" || {
	echo failed
	echo Did not pull
	bk changes -qR
	exit 1
}
bk -e -r check -av >OUT 2>&1 || {
	echo failed
	exit 1
}
echo OK

echo $N Test rootkey urls, file url, component root key .............$NL
cd ../project
RK=`bk prs -r1.0 -hnd:KEY: gcc/ChangeSet`
touch foo
bk new $Q foo
bk mv foo bar
BADRK=`bk prs -r1.0 -hnd:KEY: bar`
cd ../copy
RK2=`bk changes -Sq -r1.0 -nd:KEY: ../project?ROOTKEY=$RK`
test "$RK" = "$RK2" || exit 1
echo OK

echo $N Test rootkey urls, file url, product root key ...............$NL
PRK=`bk -R prs -r1.0 -hnd:KEY: ChangeSet`
RK2=`bk changes -Sq -r1.0 -nd:KEY: ../project?ROOTKEY=$PRK`
test "$PRK" = "$RK2" || exit 1
echo OK

echo $N Test rootkey urls, file url, nonexistant root key ...........$NL
bk changes -q -r1.0 -nd:KEY: ../project?ROOTKEY=$RK.junk 2> ERR && {
	echo should have failed
	exit 1
}
grep -q "cannot use key" ERR || {
	echo wrong msg
	cat ERR
	exit 1
}
echo OK

echo $N Test rootkey urls, file url, file root key ..................$NL
bk changes -q -r1.0 -nd:KEY: ../project?ROOTKEY=$BADRK 2> ERR && {
	echo should have failed
	exit 1
}
grep -q "cannot use key" ERR || {
	echo wrong msg
	cat ERR
	exit 1
}
echo OK

echo $N Test rootkey urls, file url, component key, no component ....$NL
cd ../project
mv gcc hidden
cd ../copy
bk changes -q -r1.0 -nd:KEY: ../project?ROOTKEY=$RK 2> ERR && {
	echo should have failed
	exit 1
}
grep -q "ERROR-cannot cd to gcc " ERR || {
	echo wrong msg
	cat ERR
	exit 1
}
cd ../project
mv hidden gcc
cd ../copy
echo OK

echo $N Test rootkey urls, bk:// url above, component root key ......$NL
cd "$HERE"
bk bkd -q -d -aPORT -ikill > "$HERE/BKD" 2>&1 || exit 1
P=`cat PORT`
RK2=`bk changes -Sq -r1.0 -nd:KEY: bk://localhost:$P/project?ROOTKEY=$RK`
test "$RK" = "$RK2" || {
	echo failed
	bk _kill bk://localhost:$P
	exit 1
}
# leave bkd running for next test
echo OK

echo $N Test rootkey urls, bk:// url above, product root key ........$NL
RK2=`bk changes -q -r1.0 -nd:KEY: bk://localhost:$P/project?ROOTKEY=$PRK`
test "$PRK" = "$RK2" || {
	echo failed
	bk _kill bk://localhost:$P
	exit 1
}
echo OK
bk _kill bk://localhost:$P

echo $N Test rootkey urls, bk:// url in repo, component root key ....$NL
cd "$HERE/project"
bk bkd -q -d -aPORT -ikill > "$HERE/BKD" 2>&1 || exit 1
P=`cat PORT`
RK2=`bk changes -Sq -r1.0 -nd:KEY: bk://localhost:$P?ROOTKEY=$RK`
test "$RK" = "$RK2" || {
	echo failed
	bk _kill bk://localhost:$P
	exit 1
}
echo OK

echo $N Test rootkey urls, bk:// url in repo, product root key ......$NL
RK2=`bk changes -q -r1.0 -nd:KEY: bk://localhost:$P?ROOTKEY=$PRK`
test "$PRK" = "$RK2" || {
	echo failed
	bk _kill bk://localhost:$P
	exit 1
}
echo OK

echo $N Test rootkey urls, bk:// url, nonexistant root key ..........$NL
bk changes -q -r1.0 -nd:KEY: bk://localhost:$P?ROOTKEY=$RK.junk 2> ERR && {
	echo should have failed
	exit 1
}
grep -q "cannot use key" ERR || {
	echo wrong msg
	cat ERR
	bk _kill bk://localhost:$P
	exit 1
}
echo OK

echo $N Test rootkey urls, bk:// url, file root key .................$NL
bk changes -q -r1.0 -nd:KEY: bk://localhost:$P?ROOTKEY=$BADRK 2> ERR && {
	echo should have failed
	exit 1
}
grep -q "cannot use key" ERR || {
	echo wrong msg
	cat ERR
	bk _kill bk://localhost:$P
	exit 1
}
echo OK

echo $N Test rootkey urls, bk:// url, component key, no component ...$NL
cd "$HERE/project"
mv gcc hidden
cd ../copy
bk changes -q -r1.0 -nd:KEY: bk://localhost:$P?ROOTKEY=$RK 2> ERR && {
	echo should have failed
	bk _kill bk://localhost:$P
	exit 1
}
grep -q "ERROR-cannot cd to gcc " ERR || {
	echo wrong msg
	cat ERR
	bk _kill bk://localhost:$P
	exit 1
}
cd ../project
mv hidden gcc
cd ../copy
echo OK
bk _kill bk://localhost:$P

echo $N Try a pull with conflicts that can be automerged.............$NL
cd "$HERE"
bk clone $Q null-pull remote
cd remote
bk portal $Q . || fail
bk setup -f x/y/z/comp || exit 1
bk clone $Q ../remote ../local
cd x/y/z/comp
touch f.remote
bk new $Q f.remote || exit 1
bk commit -S $Q -yremote || exit 1
cd "$HERE"/remote
echo bam > bam
bk new $Q -b bam
bk edit $Q amerge
bk delta $Q -fyamerge amerge
cd "$HERE"/remote/gcc
echo bam > bam
bk new $Q -b bam
for i in 1 2 3 4 5
do
	bk edit $Q file$i
	echo "new stuff $i" >> file$i
	bk delta $Q -y"modify" file$i
	bk commit -S $Q -y"Add $i to file$i"
done
cd "$HERE"/remote
bk commit $Q -y"remote gcc"
cd "$HERE"/local
echo junk > fff
bk new $Q fff
bk commit $Q -y'new file'
bk tag $Q OLD
cd "$HERE"/local/gcc
for i in 6 7 8 9
do
	echo "new stuff $i" >> file$i
	bk new $Q -y"modify" file$i
	bk commit -S $Q -y"Add $i to file$i"
done
bk edit $Q file1
cp file1 old
echo "stuff at top" > file1
cat old >> file1
rm old
bk delta $Q -ymodify file1 || exit 1
bk commit -S $Q -y"modify file1" || exit 1
cd "$HERE"/local
bk edit $Q amerge
bk delta $Q -fyamerge amerge
bk commit $Q -y"local gcc"
mkdir BitKeeper/triggers
cat <<EOF > BitKeeper/triggers/post-commit.bug
#!/bin/sh

bk changes -v -r+ -nd:DPN:@:REV: > "$HERE"/commit.log 2>&1 || exit 1
bk changes -v -rOLD -nd:DPN:@:REV: >> "$HERE"/commit.log 2>&1 || exit 1
EOF
chmod +x BitKeeper/triggers/post-commit.bug
cat <<EOF > BitKeeper/triggers/pre-resolve.bug
#!/bin/sh

# we should not have a gone file in RESYNC
test -f BitKeeper/etc/gone && {
     echo RESYNC shouldn\'t have a gone file
     exit 1
}
exit 0
EOF
chmod +x BitKeeper/triggers/pre-resolve.bug

cd ..
tar cf local.tar local
cd local
bk pull $Q || {
	echo failed
	exit 1
}
bk lock -q || fail

# check must pass
bk $Q -e -r check -a || {
	echo failed
	cat OUT
	exit 1
}

cat <<EOF > ../WANT.commit.log
ChangeSet@1.7
amerge@1.3
gcc/ChangeSet@1.8
gcc/file1@1.3
ChangeSet@1.5.1.1
fff@1.1
fff@1.0
EOF

cmpfiles ../commit.log ../WANT.commit.log

# gcc/ChangeSet is in product's changeset
cd "$HERE"/local
cat <<EOF > ../WANT.changes
ChangeSet
amerge
gcc/ChangeSet
gcc/file1
EOF
bk changes -nd:GFILE: -vr+ > GOT
cmpfiles ../WANT.changes GOT

# Files were actually pulled
cd "$HERE"/local/gcc
cat <<EOF > "$HERE/WANT.actual"
SCCS/s.ChangeSet
SCCS/s.bam
SCCS/s.file1
SCCS/s.file2
SCCS/s.file3
SCCS/s.file4
SCCS/s.file5
SCCS/s.file6
SCCS/s.file7
SCCS/s.file8
SCCS/s.file9
BitKeeper/etc/SCCS/s.attr
BitKeeper/etc/SCCS/s.collapsed
BitKeeper/etc/SCCS/s.config
BitKeeper/etc/SCCS/s.gone
BitKeeper/etc/SCCS/s.ignore
EOF
bk sfiles > GOT
cmpfiles "$HERE/WANT.actual" GOT

bk _test -f SCCS/d.ChangeSet && {
	echo failed
	echo left dfile
	pwd
	bk _find SCCS
	exit 1
}
echo OK

echo $N Do it again, but in two steps: bk pull -R and bk resolve -a .$NL
cd "$HERE"/local
bk unpull $Q -sf || exit 1
bk pull $Q -R
bk resolve $Q -a 2>ERR || fail -f ERR did not resolve
bk lock -q || fail
# gcc/ChangeSet is in product's changeset
cd "$HERE"/local
bk changes -nd:GFILE: -vr+ > GOT
cmpfiles ../WANT.changes GOT
# Files were actually pulled
cd "$HERE"/local/gcc
bk sfiles > GOT
cmpfiles "$HERE/WANT.actual" GOT
echo OK

echo $N Do it again, bk:// url ......................................$NL
cd "$HERE"
bk bkd -q -aPORT -ikill
M=localhost:`cat PORT`
trap "bk _kill bk://$M" 0
rm -fr local
tar xf local.tar
cd local
bk pull $Q bk://$M/remote || fail
bk lock -q || fail
bk changes -nd:GFILE: -vr+ > GOT
cmpfiles ../WANT.changes GOT
# Files were actually pulled
cd "$HERE"/local/gcc
bk sfiles > GOT
cmpfiles "$HERE/WANT.actual" GOT
echo OK

echo $N Do it again, http:// url ....................................$NL
cd "$HERE"
rm -fr local
tar xf local.tar
cd local
bk pull $Q http://$M/remote || fail
bk lock -q || fail
bk changes -nd:GFILE: -vr+ > GOT
cmpfiles ../WANT.changes GOT
# Files were actually pulled
cd "$HERE"/local/gcc
bk sfiles > GOT
cmpfiles "$HERE/WANT.actual" GOT
echo OK

echo $N Pull with committed new-file conflict in component...........$NL
cd "$HERE"
nested project2
cd ..
bk clone $Q project2 copy2 || fail clone
# Add a new file to project2/gcc.
cd project2/gcc
echo "from project2" >conflict-test
bk new $Q conflict-test || fail new
bk commit $Q -S -y'add conflict-test in project2' || fail commit
bk -P commit $Q -y'add conflict-test in project2/gcc' || fail prod commit
# Add a new file with the same name to copy2/gcc.
cd ../../copy2/gcc
echo "from copy2" >conflict-test
bk new $Q conflict-test || fail new
bk commit -S $Q -y'add conflict-test in copy2' || fail commit
bk -P commit $Q -y'add conflict-test in copy2/gcc' || fail prod commit
cd ..
# Pull project2 into copy2 but do not resolve.
bk pull $Q -R ../project2 || fail pull
# Resolve in the Product -- rr is to remove remote file.
bk resolve -a $Q <<EOF > OUT 2>&1 || exit 11
rr
y
EOF
# Should get the new-file cset and a merge cset.
bk changes -Sfr1.3,1.4 -nd:KEY: > WANT || exit 12
cmpfiles WANT BitKeeper/etc/csets-in
test "`bk log -r1.4 -nd:MERGE:`" = "1.4" || exit 14
bk cat gcc/conflict-test >OUT
grep -q 'from copy2' OUT || fail -f OUT
cd "$HERE"
rm -rf project2 copy2
echo OK

echo $N Pull with uncomitted new-file conflict in component..........$NL
cd "$HERE"
nested project2
cd ..
bk clone $Q project2 copy2 || exit 1
# Add a new file to project2/gcc.
cd project2/gcc
echo "from project2" >conflict-test
bk new $Q conflict-test || exit 2
bk commit -S $Q -y'add conflict-test in project2' || exit 3
bk -P commit $Q -y'add conflict-test in project2/gcc' || exit 4
# Add a new file with the same name to copy2/gcc, but do NOT commit it.
cd ../../copy2/gcc
echo "from copy2" >conflict-test
bk new $Q conflict-test || exit 5
cd ..
# Pull project2 into copy2 but do not resolve.
bk pull $Q -R ../project2 || exit 6
bk resolve -a $Q <<EOF > OUT 2>&1 || exit 9
rr
y
EOF
# Should get the new-file cset and a merge cset.
bk changes -Sfr1.3,1.4 -nd:KEY: > WANT || exit 10
cmpfiles WANT BitKeeper/etc/csets-in
test "`bk log -r1.4 -nd:MERGE:`" = "" || exit 12
bk cat gcc/conflict-test | grep -q 'from copy2' || exit 13
cd "$HERE"
rm -rf project2 copy2
echo OK

echo $N Try a pull that adds a component.............................$NL
cd "$HERE/project"
commercial newcomp
cd ..
bk attach $Q -N newcomp
cd "$HERE/copy"
bk pull >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
# check progressbar
perl -lne 'print $1 if /(\d\/\d)/' OUT > GOT
cat <<EOF > WANT
1/3
2/3
3/3
EOF
cmpfiles GOT WANT
test -d newcomp || {
	echo failed
	exit 1
}
cd newcomp
bk -r check -av >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
cd ..
bk -e -r check -av >OUT 2>&1 || {
	echo failed
	cat OUT
	exit 1
}
echo OK

echo $N Setup for pulling conflict into missing component ...........$NL
cd "$HERE"
bk _rm -fr project copy
nested project
cd ..
bk clone $Q project copy
bk clone $Q -s./gcc project sparse
# modify both components in both repos in a way which autoresolves
for i in project copy
do	for c in gcc gdb
	do	cd "$HERE/$i/$c"
		touch $i-$c
		bk new $Q $i-$c
		bk commit -S $Q -ywhatever
	done
	cd "$HERE/$i"
	bk commit $Q -ywhatever
done
echo OK

echo $N Pull of one should work .....................................$NL
cd "$HERE/sparse"
# make a conflict in the component that we have
cd gcc
touch sparse
bk new $Q sparse
bk commit -S $Q -ywhatever
cd ..
bk commit $Q -ywhatever
bk pull $Q ../project || {
	echo pull failed
	exit 1
}
echo OK

echo $N Pull of second one should fail ..............................$NL
bk pull --unsafe ../copy > OUT 2>&1 && {
	echo should have failed
	cat OUT
	exit 1
}
grep -q "Unable to resolve conflict in non-present component 'gdb'." OUT || {
	echo bad error message
	cat OUT
	exit 1
}
bk abort -qf || fail
echo OK

echo $N Setup N-way pull where a later pull fails ...................$NL
cd "$HERE"
bk clone $Q -s. sparse ponly || fail
cd ponly
echo junk > junk
bk new $Q junk
bk commit $Q -yjunk || fail
cd ../sparse
bk pull --unsafe -q ../ponly ../copy 2>ERR && fail
cat <<EOF > WANT
pull: Unable to resolve conflict in non-present component 'gdb'.
pull: update aborted due to errs with 1 components.
EOF
cmpfiles WANT ERR
echo OK

echo $N Try a pull where source did rm -rf component ................$NL
cd "$HERE"
bk clone $Q project clone
cd project/gdb
touch junk
bk new $Q junk
bk commit -S $Q -ywhatever
cd ..
bk commit $Q -ywhatever
cd "$HERE"
tar cf TAR project clone
rm -rf project/gdb
cd clone
bk pull > OUT 2>&1 && {
	echo should have failed
	cat OUT
	exit 1
}
# XXX bad error message
grep -q 'Pulling gdb failed' OUT || {
	echo bad message
	cat OUT
	exit 1
}
echo OK

echo $N Try a pull where destination did rm -rf component ...........$NL
cd "$HERE"
rm -rf project clone
tar xf TAR
cd clone 
rm -rf gdb
# should auto-fix repo by cloning component
bk pull $Q || {
	echo failed
	exit 1
}
echo OK

echo $N Try a pull with a moved component............................$NL
cd "$HERE"
bk _rm -rf remote local
bk clone $Q null-pull remote
bk clone $Q remote local
cd "$HERE"/local
mvcomp gcc gcc4
bk commit $Q -y'rename component'
cd "$HERE"/remote/gcc
for i in 1 
do
	bk edit $Q file$i
	echo "new stuff $i" >> file$i
	bk delta $Q -y"modify" file$i
	bk commit -S $Q -y"Add $i to file$i"
done
cd "$HERE"/remote
bk commit $Q -y"remote gcc"
cd "$HERE"/local

bk pull $Q ../project || {
	echo failed
	cat OUT
	exit 1
}
test -d gcc && {
	echo should not have made gcc
	find gcc
	# exit 1
}
echo OK

echo $N Do a pull where the remote is using a new alias .............$NL
cd ../remote
bk alias new GCC ./gcc || exit 1
bk here add $Q GCC || exit 1
cd ../local
bk pull $Q || exit 1
echo OK

echo $N Now unpull and setup a conflict in aliases ..................$NL
bk unpull $Q -f || exit 1
bk alias new GCC ./gdb || exit 1
bk here add $Q GCC || exit 1
echo q | bk pull $Q || exit 1
echo OK

echo $N Now that HERE has GCC alias, pull any cset ..................$NL
cd ../remote
touch foo
bk new $Q foo
bk commit $Q -f
cd ../local
bk pull $Q || exit 1
echo OK

echo $N Try a tag-only pull .........................................$NL
cd ../remote
bk tag $Q -r1.3 badbug || exit 1
cd ../local
bk pull $Q || exit 2
echo OK

echo $N Now pull tag along with another cset ........................$NL
bk unpull -f $Q || exit 1
cd ../remote
touch tagf
bk new $Q tagf || exit 2
bk commit $Q -ytagf || exit 3
cd ../local
bk pull $Q || exit 4
echo OK

# XXX - test in product and then test in component
echo $N Test that bk pull -u shows local work and does not pull .....$NL
cd "$HERE/remote"
touch remote-file
bk new $Q remote-file
bk commit $Q -yremote || fail
cd ../local
touch local-file
bk new $Q local-file
bk commit $Q -ylocal || fail
bk pull -u > OUT 2>&1 && fail -f OUT should have failed
grep -q 'Not updating due to the following' OUT || fail -f OUT bad message
echo OK

echo $N Same thing with local work in the component only ............$NL
cd "$HERE"
rm -rf local
bk clone -q -r1.8 -sHERE remote local
cd remote/gcc
touch gcc-file1
bk new $Q gcc-file1
bk commit -S $Q -ygcc || exit 3
cd ..
bk commit $Q -ygcc || exit 3
cd ../local/gcc
touch gcc-file
bk new $Q gcc-file
bk commit -S $Q -ygcc || exit 3
cd ..
bk pull -u > OUT 2>&1 && fail -f OUT should have failed
grep -q 'gcc has uncommitted changes' OUT || fail -f OUT bad message
echo OK

# # XXX - we should check that the repo is cleaned up but we need the nested
# # abort/cleanup code first.

echo $N Test pull in a component goes up to the product..............$NL
cd "$HERE"
rm -rf local
bk clone -q -r1.8 -sHERE remote local
cd local/gcc
bk pull $Q 2>ERR || fail -f ERR pull should have worked
echo OK

echo $N Try pulling from unrelated product...........................$NL
cd "$HERE"
fresh_nested n1
cd "$HERE"
fresh_nested n2
bk pull $Q "$HERE/n1" 2>ERR && fail -f ERR should have failed
grep -q "You are trying to pull from an unrelated package." ERR \
	|| fail -f ERR wrong error msg
echo OK

echo $N Try pulling from nested to non-nested........................$NL
cd "$HERE"
fresh_commercial nn
bk pull $Q "$HERE/n1" 2>ERR && fail -f ERR should have failed
grep -q "You are trying to pull from an unrelated package." ERR \
	|| fail -f ERR wrong error msg
echo OK

echo $N Try pulling from non-nested to nested........................$NL
cd "$HERE/n2"
bk pull $Q "$HERE/nn" 2>ERR && fail -f ERR should have failed
grep -q "You are trying to pull from an unrelated package." ERR \
	|| fail -f ERR wrong error msg
echo OK

echo $N Update-only pull does not commit pending.....................$NL
cd "$HERE"
nested parent
cd gcc
echo `date` > afile
bk new $Q afile
bk commit -S $Q -yafile
bk -P commit $Q -yafile
cd "$HERE"
bk clone $Q parent child
# add cset to parent
cd "$HERE/parent/gcc"
bk edit $Q afile
echo new stuff > afile
bk delta $Q -yafile-parent
bk commit -S $Q -yafile-parent
bk -P commit $Q -yafile-parent
# add pending to child (that does not conflict)
cd "$HERE/child/gcc"
echo `date` > bfile
bk new $Q bfile
bk commit -S $Q  -ybfile
# pull should fail (we have a pending)
bk -P pull $Q 2>ERR && fail should have failed
grep -q "gcc has uncommitted changes" ERR || fail -f ERR
# we should have no local changes
test -n "`bk -P changes -qL`" && fail local changes found
echo OK

echo $N Setup pull with a conflict in product and quit ..............$NL
cd "$HERE/parent/gcc"
echo hi > cfile
bk new $Q cfile
bk commit -S $Q -ycfile
cd ..
echo hi > conflict
bk new $Q conflict
bk commit $Q -yparent

cd ../child
echo hi2 > conflict
bk new $Q conflict
bk commit $Q -ychild

bk changes -v -r+ > BEFORE
(echo q; echo y) | bk pull $Q 2>ERR && fail
bk abort -qf
bk -e -r check -ac || fail
bk changes -v -r+ > AFTER
# this shouldn't change
cmpfiles BEFORE AFTER
echo OK

echo $N Now repeat conflicting pull with abort ......................$NL
(echo a; echo y) | bk pull $Q 2>ERR && fail
bk -e -r check -ac || fail
bk changes -v -r+ > AFTER
# this shouldn't change
cmpfiles BEFORE AFTER
echo OK

echo $N Now do the pull in two steps with resolve -c ................$NL
bk pull -R $Q || fail
cd gcc
bk resolve -S -c $Q 2>ERR || fail
cd ..
bk resolve -S -c $Q 2>ERR && fail
bk -e -r check -ac || fail
echo OK

echo $N Set up for urllist pull populates ...........................$NL
cd "$HERE"/project
for c in A B C D
do	bk setup -f $c || fail
done
bk clone -sA -sB -sC -sD $Q . ../copy1 || fail
cd ../copy1
rm BitKeeper/log/urllist
bk clone -sA -sC $Q . ../copy2 || fail
bk here set $Q B D || fail
cd ../copy2
bk gate $Q . || fail
bk alias new TRACK C D || fail
bk clone $Q -sTRACK . ../copy3 || fail
bk alias set TRACK A B || fail

bk comps -h | bk _sort > OUT
cat <<EOF > WANT
./A
./C
EOF
cmpfiles OUT WANT

cd ../copy3

bk comps -h | bk _sort > OUT
cat <<EOF > WANT
./C
./D
EOF
cmpfiles OUT WANT

echo OK

echo $N Ensure pull fails unpopulate if pending local work present ..$NL
# Now:
#    copy1: B,D
#    copy2: A,C TRACK=A,B
#    copy3: C,D HERE=TRACK=C,D
# A pull of copy2 into copy3 should fail if there is pending local work in
# C because C then cannot be unpopulated.
cd C
date >new-file
bk new $Q new-file || fail
bk commit -S $Q -ynew-file || fail
cd ..
bk pull >OUT 2>ERR && fail -f ERR should have failed
perl -pe "s/.*\r//;s,$HERE,ROOT," < ERR > ERR2
cat <<EOF > WANT
.                                  100% |==============================| OK
pull: unable to remove ./C, it contains csets not committed in product.
pull: searching ROOT/copy1...ok
pull: problem populating components.
EOF
cmpfiles ERR2 WANT
bk abort -qf
# Remove the local work in C for the subsequent tests.
cd C
bk undo -Sfr+ $Q || fail
cd ..
echo OK

echo $N Demonstrate urllist pull populates ..........................$NL
# Magic pull that updates TRACK in the HERE alias from C D to A B
# and only A and C are populated in my parent and B and D have to be found
# in a different URL:
bk pull 2>ERR >OUT || fail -f ERR
# Now:
#    copy3: A,B HERE=TRACK=A,B

perl -pe "s/.*\r//;s,$HERE,ROOT," < ERR > ERR2
cat <<EOF > WANT
.                                  100% |==============================| OK
pull: searching ROOT/copy1...ok
1/3 A                              100% |==============================| OK
Source ROOT/copy1
2/3 B                              100% |==============================| OK
pull: removing ./D...done
pull: removing ./C...done
3/3 .                                1 changeset,   no merges in   2 files
EOF
cmpfiles WANT ERR2

bk comps -h | bk _sort > OUT
cat <<EOF > WANT
./A
./B
EOF
cmpfiles OUT WANT
echo OK

echo $N Show when pull can\'t find a component it needs ..............$NL
bk unpull -f $Q || fail
cd ../copy1
bk unpopulate $Q ./B || fail
cd ../copy3
bk pull 2>ERR > OUT && fail -f ERR
perl -pe "s/.*\r//;s,$HERE,ROOT," < ERR > ERR2
cat << EOF > WANT
.                                  100% |==============================| OK
pull: searching ROOT/copy1...ok
1/3 A                              100% |==============================| OK
pull: No other sources for ./B known
pull: problem populating components.
EOF
cmpfiles ERR2 WANT

bk comps -h | bk _sort > OUT
cat <<EOF > WANT
./C
./D
EOF
cmpfiles OUT WANT
bk abort -qf
echo OK

echo $N Show when pull can\'t find a component to unpopulate .........$NL
cd ../copy1
bk here set $Q ./B || fail
cd ../copy3
bk pull 2>ERR > OUT && fail -f ERR
perl -pe "s/.*\r//;s,$HERE,ROOT," < ERR > ERR2
cat << EOF > WANT
.                                  100% |==============================| OK
pull: searching ROOT/copy1...ok
pull: No other sources for ./D known
pull: unable to remove ./D
pull: problem populating components.
EOF
cmpfiles ERR2 WANT

bk comps -h | bk _sort > OUT
cat <<EOF > WANT
./C
./D
EOF
cmpfiles OUT WANT
echo OK

echo $N Check paths in changes and pull..............................$NL
cd "$HERE"
bk clone $Q project copy4
bk clone $Q copy4 copy5
cd copy4
touch C/copy4_file
bk --cd=C new $Q copy4_file
bk --cd=C commit -S $Q -ycopy4_file
bk commit $Q -ycopy4_file
cd ../copy5
touch C/copy5_file
bk --cd=C new $Q copy5_file
bk --cd=C commit -S $Q -ycopy5_file
bk commit $Q -ycopy5_file
bk --cd=C changes -SRL > GOT
grep -q "==== changes -L .*/C ====" GOT || fail -f GOT wrong local output
grep -q "==== changes -R .*/C ====" GOT || fail -f GOT wrong remote output
bk pull $Q ../copy4 || fail
bk changes -vr+ > GOT
grep -q "Merge .*/C" GOT || fail -f GOT wrong remote path
grep -q "into .*/C" GOT || fail -f GOT wrong local path
echo OK

echo $N Create a component conflict and see that cleanup works ......$NL
cd "$HERE"
nested repo
touch gcc/foo
bk new $Q gcc/foo
bk commit $Q -yfiles
bk clone $Q . ../repocopy
bk edit $Q gcc/foo
echo remote > gcc/foo
bk delta $Q -fyfiles gcc/foo
bk commit $Q -yremote
cd ../repocopy
bk edit $Q gcc/foo
echo local > gcc/foo
bk pull $Q > OUT 2>&1 && fail should have failed
grep -q "The following files are modified locally and " OUT || fail -f OUT
bk unedit gcc/foo
bk pull $Q || fail should have worked
echo OK
