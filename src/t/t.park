# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.


# Copyright (c) 2000 Andrew Chang
# %K%

if [ X$PLATFORM = X"WIN32" ]
then
	binary_data="`bk bin`/bk.exe"
	binary_data2="`bk bin`/diff.exe"
	binary_data3="`bk bin`/diff3.exe"
else
	binary_data="/bin/ls"
	binary_data2="/bin/rm"
	binary_data3="/bin/cp"
fi

HERE=`bk pwd`
echo $N Create initial repository ...................................$NL
no_logging project
bk admin -Z
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
echo OK
echo $N Create some data ............................................$NL
mkdir src
cd src
echo foo > foo.c
echo bar > bar.c
echo h > h.h
bk ci $Q -i foo.c bar.c h.h
if [ ! -f SCCS/s.foo.c ]; then echo failed to create history; exit 1; fi
echo OK
echo $N Check basic park/unpark cycle ...............................$NL
bk edit $Q foo.c bar.c
echo foo-new > foo.c
echo bar-new >> bar.c
echo "This a comment for bar.c" > SCCS/c.bar.c
cp SCCS/c.bar.c $HERE/c.ref
cp foo.c $HERE/foo.sav
cp bar.c $HERE/bar.sav
bk park -y 2> /dev/null || exit 1
NUM=`bk sfiles -c | wc -l`
if [ $NUM -ne 0 ]; then echo failed; exit 1; fi;
if [ -f SCCS/c.bar.c ]; then echo failed; exit 1; fi
bk edit $Q bar.c
bk unpark 2> /dev/null 1>&2 || exit 1
cmp -s foo.c $HERE/foo.sav
if [ $? -ne 0 ]; then echo failed 1; exit 1; fi
cmp -s bar.c $HERE/bar.sav 
if [ $? -ne 0 ]; then echo failed 2; od -c bar.c; od -c bar.sav; exit 1; fi
if [ ! -f SCCS/c.bar.c ]; then echo failed; exit 1; fi
cmp -s SCCS/c.bar.c $HERE/c.ref
if [ $? -ne 0 ]; then echo failed 3; exit 1; fi
echo OK
echo $N Check basic park/unpark via stdin ...........................$NL
bk park -y"hi mom" 2> /dev/null || exit 1
mv $HERE/project/BitKeeper/tmp/parkfile_1.sfio $HERE/parkfile$$
bk unpark - < $HERE/parkfile$$ 2>/dev/null 1>&2 || exit 1
cmp -s foo.c $HERE/foo.sav
if [ $? -ne 0 ]; then echo failed 1; exit 1; fi
echo OK
rm -f $HERE/parkfile$$ 
echo $N Check basic park/unpark with reject file ....................$NL
bk unedit bar.c
bk edit $Q foo.c
echo foo-new2 > foo.c
bk park <<EOF 2> /dev/null
hi mom
hi dad
.
EOF
NUM=`bk sfiles -c | wc -l`
if [ $NUM -ne 0 ]; then echo failed; exit 1; fi;
bk edit $Q foo.c
echo foo-new3 > foo.c
bk ci $Q -y foo.c
bk unpark 2> /dev/null 1>&2
# make sure unpark does not delete the parkfile
if [ ! -f $HERE/project/BitKeeper/tmp/parkfile_1.sfio ]; then echo failed; exit 1; fi
echo OK
echo $N Check park/unpark with offset diff ..........................$NL
bk clean foo.c
bk fix $Q foo.c
echo foo-new4 > foo.c
bk get $Q -p -r1.1 foo.c >> foo.c
bk unpark -c 2>/dev/null 1>&2
bk undos > CMP2 <<EOF
foo-new4
foo-new2
EOF
cmp -s foo.c CMP2
if [ $? -ne 0 ]; then echo failed; exit 1; fi
echo OK
echo $N Check unpark with renamed and edited file ...................$NL
bk undos > move_me <<EOF
111
222
333
EOF
bk new $Q -l move_me
echo "444" >> move_me
bk park -y 2> /dev/null
bk edit $Q move_me
cp $HERE/project/BitKeeper/etc/SCCS/x.id_cache x.id_cache
bk mv move_me new_me
mv x.id_cache $HERE/project/BitKeeper/etc/SCCS/x.id_cache
sed -e "s/111/000/" new_me > new_me.tmp
mv new_me.tmp new_me
bk unpark 2>/dev/null 1>&2
bk undos > new_me.ref <<EOF
000
222
333
444
EOF
cmp -s new_me new_me.ref || { echo failed; exit 1; }
echo OK
echo $N Should not unpark binary over changed file ..................$NL
cp $binary_data binary
bk new $Q -lb binary
cp $binary_data2 binary
echo "I am a extra file" > extra
cp extra $HERE/extra.ref
bk park -y -a 2> /dev/null
if [ -f extra ]; then echo failed 0; exit 1; fi
bk edit $Q binary
cp $binary_data3 binary
bk unpark 2> unpark.out 1>&2
grep -q "unsafe to unpark over changed binary file" unpark.out || {
							echo failed 1; exit 1; }
echo OK
bk park -c
echo $N Check unpark with moved binary file .........................$NL
rm -f binary
bk mv binary binary_moved
bk unpark  2>/dev/null 1>&2
if [ -f binary ]; then echo failed; exit 1; fi
cmp -s $binary_data2 binary_moved || { echo failed; exit 1; }
if [ ! -f extra ]; then echo failed; exit 1; fi
cmp -s extra $HERE/extra.ref || { echo failed 3; exit 1; }
echo OK
echo $N Should failed unpark binary changed delta ...................$NL
bk park -y -a 2> /dev/null
bk edit $Q binary_moved
cp $binary_data3 binary_moved
bk delta  $Q -uy"new" binary_moved
if [ ! -f binary_moved ]; then echo failed; exit1; fi
bk unpark 2> unpark.out 1>&2
grep -q "unsafe to unpark over changed binary file" unpark.out || {
							echo failed; exit 1; }
echo OK
echo $N Unpark \-f should overide local changed delta  ................$NL
bk unpark -cf 2> /dev/null 1>&2
if [ ! -f binary_moved ]; then echo failed; exit1; fi
cmp -s $binary_data2 binary_moved || { echo failed; exit 1; }
echo OK
if [ "$PLATFORM" = "WIN32" ]
then #--------------------------------------------------------------------
echo $N Check park/unpark with mix Unix Dos EOLN ....................$NL
bk admin $Q -fEOLN_NATIVE bar.c
bk edit $Q bar.c
# This test assume echo output in binary mode
echo -e "new-new\r" >> bar.c
bk edit $Q foo.c
echo "666" >> foo.c
cp bar.c bar.ref
cp foo.c foo.ref
bk park -y 2> /dev/null
if [ -f bar.c ]; then echo failed; exit 1; fi
if [ -f foo.c ]; then echo failed; exit 1; fi
bk unpark 2> /dev/null 1>&2
cmp -s bar.c bar.ref || { echo failed; exit 1; }
cmp -s foo.c foo.ref || { echo failed; exit 1; }
echo OK
fi   #--------------------------------------------------------------------
if [ "$PLATFORM" = "UNIX" ]
then  #--------------------------------------------------------------------
echo $N Make sure park/unpark ignore symlink ........................$NL
bk unedit foo.c bar.c new_me
bk edit $Q foo.c bar.c new_me
sed -e "s/111/000/" new_me > new_me.tmp
mv new_me.tmp new_me
bk undos > new_me.ref <<EOF
000
222
333
EOF
ln -s bar.c sym
bk delta $Q -i sym
bk edit $Q sym
rm -f sym
ln -s foo.c sym
bk park -y 2> park.out 1>&2
grep -q "sym.*not parked" park.out || { echo failed; exit 1; }
if [ ! -e sym ]; then echo failed; exit 1; fi
bk unpark 2> /dev/null 1>&2
cmp -s new_me new_me.ref || { echo failed; exit 1; }
echo OK
echo $N Make sure park -a handle symlink ............................$NL
bk park -y -a 2> /dev/null
if [ -L "sym" ]; then echo failed; exit 1; fi
bk unpark 2> /dev/null 1>&2
if [ ! -L "sym" ]; then echo failed; exit 1; fi
ls -l sym | grep -q "\-> foo.c" || { echo failed; exit 1; }
echo OK
echo $N Make sure park -a handle symlink to Text case  ...............$NL
rm -f sym
echo "I AM CHANGING FROM A SYMLINK TO A TEXT FILE" > sym
cp sym sym.ref
bk park -y -a 2> /dev/null
if [ -e sym ]; then echo failed; exit 1; fi
bk unpark 2> /dev/null 1>&2
cmp -s sym sym.ref || { echo failed; exit 1; }
echo OK
echo $N Make sure park -a handle symlink as extra file ..............$NL
bk unedit $Q sym
ln -s foo.c extra_sym
bk park -y -a 2> /dev/null
if [ -e extra_sym ]; then echo failed; exit 1; fi
bk unpark 2> /dev/null 1>&2
if [ ! -L "extra_sym" ]; then echo failed; exit 1; fi
ls -l extra_sym | grep -q "\-> foo.c" || { echo failed; exit 1; }
echo OK
fi   #--------------------------------------------------------------------
