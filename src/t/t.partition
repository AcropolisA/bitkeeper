# Theory of operation: start out with a clean single repository
# and chop it up a number of times into a nested collection and
# see if it has all the properities we want.
# 
#   src - a b c
#   doc - a b c
# 
# With the understanding that src and doc will be components,
# do some moves between src and doc and src and repo root.
# Then make src and doc a component.

set -e

echo $N Try to partition a product ..................................$NL
nested nest
cd ..
echo gdb > nest.map
bk partition $Q -Cnest.map nest nest.part 2> ERR && fail -f ERR
grep -q "partition: only works on standalone repositories" ERR || fail -f ERR
echo OK

echo $N Try to partition a component ................................$NL
bk partition $Q -Cnest.map nest/gcc nest.comp 2> ERR && fail -f ERR
grep -q "clone of a component is not allowed" ERR || fail -f ERR
test -d nest.comp && fail
# done with nest
rm -fr nest
echo OK

echo $N Create initial repository ...................................$NL
commercial project
mkdir src doc
cd src
mkdir -p deep/prune/path/starts/here
touch a b c deep/prune/path/starts/here/a
bk new $Q a b c deep/prune/path/starts/here/a
cd ../doc
# file path name that collides, but not listed in cset
touch a c
bk new $Q a c
bk mv c collide
bk mv collide c
echo bam > b
bk new $Q -b b
cd ..
bk commit $Q -SROOT -ybaseline
bk mv src/a a
touch src/a
bk new $Q src/a
bk commit $Q -ymoveit
# two files each originally src/a, each moved out of component
# should be no deleted in simple
bk mv src/a doc/fromsrc
# use for scompress verification
touch doc/tip
bk new $Q doc/tip
bk commit $Q -ydoc-tip
bk tag $Q TIP
cd ..
fresh_commercial comp1
cd ..
fresh_commercial comp2
cd ..
cat <<EOF > mapfile
# The source component
src

# The doc component
doc

# The deep component
src/deep/prune/path
src/deep/prune/path/starts/here

# Attach these when done
path/to/attachfoo|$HERE/comp1
path/to/newbar|$HERE/comp2
EOF
# collide with file paths in cset file
cat <<EOF > badmap.cset
src/a
EOF
# collide with file paths in cset file in a tipkey
cat <<EOF > badmap.tip
a/b/c
EOF
# collide with file paths inbetween csets, so only in file.
cat <<EOF > badmap.file
doc
doc/collide/on/down/the/road
EOF
echo OK

echo $N Test out command line .......................................$NL
bk partition 2> ERR && exit 1
grep -q "partition: must list source and destination" ERR || fail -f ERR
bk partition a b 2> ERR && exit 1
grep -q "partition: must specify a -C<file> list" ERR || fail -f ERR
bk partition -Cnotthere a b 2> ERR && exit 1
grep -q "partition: component list 'notthere' does not exist" ERR || fail -f ERR
bk partition -q -Cmapfile notthere b 2> ERR && exit 1
grep -q "illegal, nonexistent, or not package root" ERR || fail -f ERR
bk partition -Cmapfile project project 2> ERR && exit 1
grep -q "partition: destination 'project' exists" ERR || fail -f ERR
# collide file namespace with component namespace in different ways
bk partition $Q -Cbadmap.cset project copy-bad.cset 2> ERR && fail -f ERR
grep -q "csetprune: key path matches a component path src/a" ERR || fail -f ERR
bk partition $Q -Cbadmap.tip project copy-bad.tip 2> ERR && fail -f ERR
grep -q "tipkey path matches a component path 'a'" ERR || fail -f ERR
bk partition $Q -Cbadmap.file project copy-bad.file 2> ERR && fail -f ERR
grep -q "delta 1.2 matches a component path 'doc/collide'" ERR || fail -f ERR
# do it again with -X, as it catches the error in a different spot
bk partition $Q -X -Cbadmap.cset project copy-bad.csetX 2> ERR && fail -f ERR
grep -q "rootkey path matches component path" ERR || fail -f ERR
bk partition $Q -X -Cbadmap.tip project copy-bad.tipX 2> ERR && fail -f ERR
grep -q "deltakey path matches component path" ERR || fail -f ERR
bk partition $Q -X -Cbadmap.file project copy-bad.fileX 2> ERR && fail -f ERR
grep -q "delta 1.2 matches a component path 'doc/collide'" ERR || fail -f ERR
echo OK

echo $N Run a simple test ...........................................$NL
bk partition $Q -Cmapfile project copy || exit 1
TOP=`cd copy && bk changes -r+ -nd:DS:`
COMP=`cd copy/doc && bk changes -r+ -nd:DS:`
test "$TOP" -gt "$COMP" || {
	echo failed scompress $TOP $COMP
	exit 1
}
cd copy/BitKeeper/etc
bk get $Q -S config
test -s config || echo empty config
cd ../../src/BitKeeper/etc
bk get $Q -S config
test -s config && echo non-empty config
# Check idache
cd "$HERE"/copy/src/deep/prune/path/starts/here
bk log -r+ -nd:ROOTKEY: ChangeSet > "$HERE"/dnrk
# See that there are no deleted, because all moved were pruned
cd "$HERE"/copy/src
bk sfiles BitKeeper/deleted > deleted
test -s deleted && fail -f deleted "no files should be deleted"
cd "$HERE"/copy
cat ../dnrk | bk key2path > GOT
echo src/deep/prune/path/starts/here/ChangeSet > WANT
checkfiles WANT GOT
bk comps -h > GOT
cat <<'EOF' > WANT
./doc
./path/to/attachfoo
./path/to/newbar
./src
./src/deep/prune/path/starts/here
EOF
checkfiles WANT GOT
DBKPART="`tail -1 "$HERE/project/BitKeeper/log/ROOTKEY"`"
DBKPART="$BK_DOTBK/partition/$DBKPART/`tail -1 BitKeeper/log/ROOTKEY`"
test -f "$DBKPART" || fail no dotbk partition "$DBKPART"
cd "$HERE"
echo OK

echo $N See that bk names removes empty directories .................$NL
test -d copy/src/src && {
	echo failed
	find copy/src/src
	exit 1
}
echo OK

echo $N See that tags only happen in the product repo ...............$NL
cd copy/src
test 0 -eq `bk changes -r+ -nd'$if(:TAG:){tagged}' | wc -l` || {
	echo failed tags in component
	exit 1
}
cd ../doc
test 0 -eq `bk changes -r+ -nd'$if(:TAG:){tagged}' | wc -l` || {
	echo failed tags in component
	exit 1
}
cd ..
test 2 -eq `bk changes -nd'$if(:TAG:){tagged}' | wc -l` || {
	echo failed wrong number of tags in product
	exit 1
}
cd ..
echo OK

echo $N Test that files are checked out according to checkout .......$NL
test -f copy/src/b && {
	echo failed
	echo file checked out when none expected
	exit 1
}
rm -fr copy
BK_CONFIG="checkout: get! " \
    bk partition $Q -Cmapfile -X project copy || exit 1
test -f copy/src/b || {
	echo failed
	echo no file checked out when one expected
	exit 1
}
echo OK

echo $N Test rollback without -X means src/a is there ...............$NL
cd copy
bk undo $Q -sfaROOT 2> WARN || exit 1
bk _test -f src/SCCS/s.a || {
	echo not there
	exit 1
}
grep -q "undo is rolling back before the partition" WARN || fail -f WARN
cd ..
echo OK

echo $N Test rollback without -X means src/a is not there ...........$NL
bk partition $Q -Cmapfile project xcomps || exit 1
cd xcomps
bk undo $Q -sfaROOT 2> WARN || exit 1
bk _test -f src/SCCS/s.a && {
	echo there
	exit 1
}
grep -q "undo is rolling back before the partition" WARN || fail -f WARN
cd ..
echo OK

echo $N Add a cset, run again, push to first partition ..............$NL
cd project
bk edit $Q a
bk delta $Q -fynull a
bk commit $Q -ya
cd ..
bk partition $Q -Cmapfile -X project copy2 || exit 1
cd copy2
bk push $Q ../copy 2> ERR || {
   echo push failed
   cat ERR
   exit 1
}
echo OK

echo $N Move a file between components and push again ...............$NL
# We need to prune history such that the first cset that shows
# up is a user space name as opposed to being created in the deleted
# directory as is now down.  This needs to be a part of csetprune
# and cset marks need to be regenerated for those files / csets.
cd "$HERE/project"
bk mv src/b doc/was-src-b
bk commit $Q -ya
cd ..
bk partition $Q -Cmapfile -X project copymv || exit 1
cd copymv
bk push $Q ../copy || {
	echo failed
	exit 1
}
echo OK

test "$HOSTNAME" != netbsd.bitmover.com && {
echo $N Do partiton with -j4 ........................................$NL
cd ../copy
bk unpull -f $Q || fail
cd ..
BK_LIMITPATH= bk partition $Q -j4 -X -Cmapfile project copymv2 2>ERR \
    || fail -f ERR
cat ERR | grep -v 'partiton: no GNU make found, -j4 ignored' || true
cd copymv2
bk push $Q ../copy || {
	echo failed
	exit 1
}
echo OK
}

echo $N Remove empty components .....................................$NL
cd "$HERE"
echo empty/repo > emptymap
bk partition $Q -Cemptymap project empty || exit 1
test -d empty/empty && {
	echo failed
	exit 1
}
echo OK

echo $N Make a diamond graph moving a file into comp on trunk .......$NL
# This core dumped without accompanying fix
# The trick is to have a file born out of the component (in root)
# then move to the component, then have a newer cset change the
# file in its original out of component place.  In filterWeave()
# this will test parent and merge and both will be false.
cd "$HERE"
commercial trunk
touch foo
bk new $Q foo
bk commit $Q -yfoo
bk clone $Q . ../branch
mkdir src
bk mv foo src
bk commit $Q -yfoo
cd ../branch
bk edit $Q foo
bk delta $Q -fyfoo foo
bk commit $Q -yfoo
bk pull $Q
cd ..
echo src > map
bk partition $Q -Cmap branch parted
echo OK

echo $N Test the filtering of gone information when files are rm ....$NL
cd "$HERE/project"
RMNAME=`bk log -r+ -nd:RM_NAME: doc/was-src-b`
bk rm doc/was-src-b src/c
bk commit $Q -y'make a deltakey'
TIP=`bk prs -r+ -hnd:KEY: "$RMNAME"`
bk stripdel $Q -Cr+ "$RMNAME"
bk -r names $Q
bk admin $Q -fMONOTONIC BitKeeper/etc/gone
bk _rm -fr BitKeeper/deleted
bk -r check -aggg | bk gone - 2> ERR || fail -f ERR
bk edit $Q BitKeeper/etc/gone
echo "this is junk|1.2" >> BitKeeper/etc/gone
bk delta $Q -yappendjunk BitKeeper/etc/gone
bk rm doc/was-src-b
bk commit $Q -ygoned
cd ..
bk partition $Q -Cmapfile project gone.regular || fail
bk _getkv gone.regular/BitKeeper/log/partition PRUNE > plist
grep -q src/c plist && fail
grep -q "$TIP" plist && fail
echo OK

echo $N Test remapping of the contents of the gone file .............$NL
cd "$HERE"
bk partition $Q -Cmapfile -X project gone || fail
bk get -qpk gone/BitKeeper/etc/gone | tail -1 > OUT
grep -q '^# csetpruned: this is junk|1.2$' OUT || fail -f OUT
echo OK

echo $N Test partition failing if dangling deltas in gone ...........$NL
cd "$HERE/project"
bk undo $Q -sfr+
cd ..
bk partition $Q -Cmapfile -X project dangling 2>ERR && fail -f ERR
grep -q "dangling deltas in gone need to be removed" ERR || fail -f ERR
echo OK

echo $N Verify different command line map and gone lead to diff .....$NL
cd "$HERE"
rm -fr project
commercial project
cat <<EOF > x
#!/bin/sh
exit 0
EOF
chmod +x x
mkdir -p BitKeeper/triggers
mv x BitKeeper/triggers/post-incoming
bk new $Q BitKeeper/triggers/post-incoming
mkdir src doc
cd src
touch newfile mvfile
bk new $Q newfile mvfile
cd ../doc
touch newfile
bk new $Q newfile
cd ..
bk commit $Q -ynewfiles
bk mv src/mvfile mvfile
bk commit $Q -ymvfile
cd ..
echo src > map
bk partition $Q -Cmap project one
bk partition $Q -X -Cmap project one.x
echo doc >> map
bk partition $Q -Cmap project two
bk partition $Q -X -Cmap project two.x
cd one
test -d BitKeeper/triggers \
    -a -d src/BitKeeper -a ! -d src/BitKeeper/triggers || fail triggers
bk changes -qL -ndx ../one.x 2> ERR && echo fail -f ERR
grep -q "trying to synchronize with an unrelated package" ERR || fail -f ERR
bk changes -qL -ndx ../two 2> ERR && fail -f ERR
grep -q "trying to synchronize with an unrelated package" ERR || fail -f ERR
cd src
bk changes -qL -ndx ../../one.x 2> ERR && echo fail -f ERR
grep -q "cannot use key" ERR || fail -f ERR
bk changes -qL -ndx ../../one.x/src 2> ERR && echo fail -f ERR
grep -q "trying to synchronize with an unrelated package" ERR || fail -f ERR
echo OK

echo $N Verify partition -@ fails if something unknown in kv ........$NL
cd "$HERE"
cp one.x/BitKeeper/log/partition backup
echo foo | bk _setkv one.x/BitKeeper/log/partition WACKO
bk partition -q -@one.x project one.x.ref 2> GOT && fail
echo "Unknown feature 'WACKO'" > WANT
cmpfiles WANT GOT
cp backup one.x/BitKeeper/log/partition
echo OK

echo $N Verify partition state sticks and does not propagate -X .....$NL
cd "$HERE"
bk clone $Q one.x refer.x
bk partition $Q -@refer.x project one.x.ref 2>ERR && fail
grep -q "refer.x - no partition information found" ERR || fail -f ERR
cp one.x/BitKeeper/log/partition refer.x/BitKeeper/log/partition
bk partition $Q -@refer.x project one.x.ref
cd one.x.ref
bk pull $Q ../one.x
echo OK

echo $N Verify partition state sticks and does not propagate ........$NL
cd "$HERE"
bk clone $Q one refer
bk partition $Q -@refer project one.ref 2>ERR && fail
grep -q "refer - no partition information found" ERR || fail -f ERR
cp one/BitKeeper/log/partition refer/BitKeeper/log/partition
bk partition $Q -@refer project one.ref
cd one.ref
bk pull $Q ../one
echo OK

echo $N Verify new gone with reference makes new cset ...............$NL
cd "$HERE"
bk clone $Q project missing
cd missing
bk _cp SCCS/s.mvfile save
bk edit $Q mvfile
echo new content > mvfile
bk delta $Q -ynew-stuff mvfile
bk commit $Q -ymvfile
bk _rm src/SCCS/s.newfile
bk _cp save SCCS/s.mvfile
bk -r check -aggg | bk gone -q -
bk commit $Q -ygone
cd ..
BK_USER=wallawalla BK_HOST=zippy.moc \
    bk partition $Q -@refer missing missing.ref || fail
cd missing.ref
DATA=`bk changes -r+ -nd':USER:@:HOST:'`
test "wallawalla@zippy.moc" = "$DATA" || fail Got "$DATA"
bk push $Q ../one || fail
bk parent -l > GOT
echo "file://$HERE/refer" > WANT
checkfiles WANT GOT
bk pull $Q || fail
echo OK

echo $N Verify partition without -X must contain baseline cset ......$NL
cd "$HERE"
bk clone $Q -r1.2 project small
bk partition $Q -@one small borker 2> ERR && fail -f ERR
grep -q "It must be present for partition to work" ERR || fail -f ERR
echo OK

echo $N Test name mapping of deleted files ..........................$NL
cd "$HERE"
commercial normal 
touch foo~bar
bk new $Q foo~bar
bk mv foo~bar src/file
bk commit $Q -yfile
echo src > comps
bk partition $Q -Ccomps . ../nested-deltest
cd ../nested-deltest/src
bk rm -f file
# write a test and run it
bk -rBitKeeper/deleted \
    log -r1.0 -nd'test ":DPN:" = "BitKeeper/deleted/:GFILE:" || fail -f X' > X
. ./X
echo OK
