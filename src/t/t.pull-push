# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

if [ X$PLATFORM = X"WIN32" ]
then
        # It is unlikely in that ssh/rsh to localhost will work on NT.
        # We let the user tell us otherwise.
        if [ -z "$DO_REMOTE" ]; then DO_REMOTE=NO; fi
else
	if [ -z "$DO_REMOTE" ]; then DO_REMOTE=YES; fi
fi

# Tests for pull, push, and clone.
echo $N Create initial repository ...................................$NL
no_logging project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
mkdir src
cd src
echo foo > 'F!O#O$ B%A^R&RR(R)RR'
echo bar > bar.c
echo h > h.h
bk ci $Q -i 'F!O#O$ B%A^R&RR(R)RR' bar.c h.h
if [ ! -f SCCS/s.'F!O#O$ B%A^R&RR(R)RR' ]; then echo failed to create history; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 15 ]; then echo wrong pending result $P; bk pending; exit 1; fi
bk commit $S -a -yCset
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo failed to clear pending list; bk pending; exit 1; fi
echo OK
cores
echo $N Clone repository ............................................$NL
if [ X$PLATFORM = X"WIN32" ]; then SLASH="//"; else SLASH="/"; fi
mkdir -p $HERE/tst
cd $HERE/tst
bk clone $Q $HERE/project || { echo failed; exit 1; }
[ -f $HERE/tst/project/src/SCCS/s.'F!O#O$ B%A^R&RR(R)RR' ] || \
							{ echo failed; exit 1; }
cd $HERE
bk clone $Q $HERE/project $HERE/copy || { echo failed; exit 1; }
[ -f copy/src/SCCS/s.'F!O#O$ B%A^R&RR(R)RR' ] || { echo failed; exit 1; }
[ -f copy/BitKeeper/log/parent ] || { echo no parent; exit 1; }
parent=`cat copy/BitKeeper/log/parent`
host=`bk gethost`
[ x$parent = xfile:$SLASH$HERE/project ] || \
					{ echo wrong parent $parent; exit 1; }
cd $HERE/project; checkLocks; cd $HERE/copy; checkLocks
echo OK
echo $N Clone a nested repository ...................................$NL
cd $HERE/project/src
bk clone $Q $HERE/project sub_proj
if [ ! -d $HERE/project/src/sub_proj ]; then echo failed; exit 1; fi
rm -rf $HERE/project/src/sub_proj
echo OK
echo $N Pull with no changes in child ...............................$NL
cd $HERE/project/src
bk get $Q -e 'F!O#O$ B%A^R&RR(R)RR'
echo delta two >> 'F!O#O$ B%A^R&RR(R)RR'
bk delta $Q -y2 'F!O#O$ B%A^R&RR(R)RR'
bk commit $Q -y2
cd $HERE/copy
bk pull -t $Q || { echo failed; exit 1; }
revs=`bk prs -hd':I:\n' src/'F!O#O$ B%A^R&RR(R)RR' | wc -l`
[ $revs -eq 2 ] || { echo failed; exit 1; }
cd $HERE/project; checkLocks; cd $HERE/copy; checkLocks
echo OK
if [ $DO_REMOTE = YES ]; then
 cd $HERE/copy
 echo $N Pull with explicit remote parent ............................$NL
 bk pull -t $Q localhost:$HERE/project || { echo failed; exit 1; }
 revs=`bk prs -hd':I:\n' src/'F!O#O$ B%A^R&RR(R)RR' | wc -l`
 [ $revs -eq 2 ] || { echo failed; exit 1; }
 cd $HERE/project; checkLocks; cd $HERE/copy; checkLocks
 echo OK
 echo $N Pull with explicit remote parent and username ...............$NL
 cd $HERE/copy
 bk pull -t $Q $USER@localhost:$HERE/project || { echo failed; exit 1; }
 revs=`bk prs -hd':I:\n' src/'F!O#O$ B%A^R&RR(R)RR' | wc -l`
 [ $revs -eq 2 ] || { echo failed; exit 1; }
 cd $HERE/project; checkLocks; cd $HERE/copy; checkLocks
 echo OK
else
 echo Pull with explicit remote parent ............................skipped
 echo Pull with explicit remote parent and username................skipped
fi
echo $N Pull with explicit local parent .............................$NL
cd $HERE/copy
HOSTNAME=`bk gethost`
bk pull -t $Q $HOSTNAME:$HERE/project || { echo failed; exit 1; }
revs=`bk prs -hd':I:\n' src/'F!O#O$ B%A^R&RR(R)RR' | wc -l`
[ $revs -eq 2 ] || { echo failed; exit 1; }
cd $HERE/project; checkLocks; cd $HERE/copy; checkLocks
echo OK
echo $N Pull with explicit local parent and username ................$NL
bk pull -t $Q $USER@$HOSTNAME:$HERE/project || { echo failed; exit 1; }
revs=`bk prs -hd':I:\n' src/'F!O#O$ B%A^R&RR(R)RR' | wc -l`
[ $revs -eq 2 ] || { echo failed; exit 1; }
echo OK
echo $N Pull from subdirectory of repository ........................$NL
cd src
bk pull -t $Q || { echo failed; exit 1; }
revs=`bk prs -hd':I:\n' 'F!O#O$ B%A^R&RR(R)RR' | wc -l`
[ $revs -eq 2 ] || { echo failed; exit 1; }
echo OK
echo $N Pull with mergeable changes in child ........................$NL
bk get $Q -e bar.c
echo line three >>bar.c
bk delta $Q -ythree bar.c
bk commit $Q -ythree
cd $HERE/project/src
bk get $Q -e bar.c
mv bar.c bar.x
echo line zero >bar.c
cat bar.x >>bar.c
rm -f bar.x
bk delta $Q -yzero
bk commit $Q -y0
cd $HERE/copy
bk pull -t $Q || { echo failed; exit 1; }
cd src
cat > X <<EOF
line zero
bar
line three
EOF
bk undos X > ref-bar.c
bk get $Q bar.c
cmp -s ref-bar.c bar.c
[ $? -eq 0 ] || { echo failed; diff ref-bar.c bar.c; exit 1; }
echo OK
bk clean 
echo $N Push with no upstream deltas ................................$NL
bk push $Q || { echo failed; exit 1; }
mv ref-bar.c $HERE/project/src
cd $HERE/project/src
bk get $Q bar.c
cmp -s ref-bar.c bar.c
[ $? -eq 0 ] || { echo failed; diff ref-bar.c bar.c; exit 1; }
cd $HERE/project; checkLocks; cd $HERE/copy; checkLocks
echo OK
bk clean 
rm -f ref-bar.c
echo $N Push with an unrelated upstream delta .......................$NL
cd $HERE/project
date > stamp
bk delta $Q -i stamp
bk commit $Q -ytime
KEY="`bk prs -hd:KEY: -r+ ChangeSet`"
cd $HERE/copy/src
bk get $Q -e h.h
sed 's/h/qwerty/' <h.h >h.x
mv h.x h.h
bk delta $Q -ydvorak h.h
cd ..
bk commit $Q -yzxcvbnm
bk push -t -a $Q || { echo push w/ autopull failed; exit 1; }
cd $HERE/project
KEY2="`bk prs -hd:KEY: -r+ ChangeSet`"
[ "$KEY" = "$KEY2" ] || { echo bad push; exit 1; }
cd $HERE/project; checkLocks; cd $HERE/copy; checkLocks
echo OK
echo $N Push with a conflicting upstream delta ......................$NL
cd $HERE/project/src
bk get $Q -e h.h
sed 's/h/yuhjklbn/' <h.h >h.x
mv h.x h.h
bk delta $Q -yrogue h.h
cd ..
bk commit $Q -yrogue
KEY="`bk prs -hd:KEY: -r+ ChangeSet`"
cd $HERE
tar cf PUSH.tar project copy
cd $HERE/copy
bk push -t -a $Q 2> resolve.out
test $? -ne 0 || { echo failed; cat resolve.out; exit 1; }
grep -q 'unresolved conflicts, nothing is applied' resolve.out || {
	echo should have had conflicts, but did not
	cat resolve.out
	exit 1
}
KEY2="`bk prs -hd:KEY: -r+ $HERE/project/ChangeSet`"
[ "$KEY" = "$KEY2" ] || { echo bad push; exit 1; }
echo OK
echo $N Resolve by hand and push again ..............................$NL
bk resolve $Q -F -t <<EOF >resolve.out 2>&1
m
C
whatever
.
u
EOF
[ $? -eq 0 ] || { echo resolve failed; cat resolve.out; exit 1; }
L=`bk get $Q -p src/h.h | wc -l`
target=5
if [ "X$BK_RESOLVE_MERGEPROG" == "Xsmerge" ]; then
	target=7
fi
[ $L -eq $target ] || { echo merge failed; exit 1; }
cd $HERE/project; checkLocks; cd $HERE/copy; checkLocks
cd $HERE
cp -rp project project2
cp -rp project project3
cd copy
KEY="`bk prs -hd:KEY: -r+ ChangeSet`"
bk push $Q || { echo failed; exit 1; }
KEY2="`cd $HERE/project && bk prs -hd:KEY: -r+ ChangeSet`"
[ "$KEY" = "$KEY2" ] || { echo no push; exit 1; }
cd $HERE/project; checkLocks; cd $HERE/copy; checkLocks
echo OK
if [ $DO_REMOTE = YES -a X$NO_TTY = X ]; then
 echo $N Push with explicit remote parent ............................$NL
 cd $HERE/copy
 bk push $Q localhost:$HERE/project2 || { echo failed; exit 1; }
 KEY2="`cd $HERE/project2 && bk prs -hd:KEY: -r+ ChangeSet`"
 [ "$KEY" = "$KEY2" ] || { echo no push; exit 1; }
 cd $HERE/project; checkLocks; cd $HERE/copy; checkLocks
 echo OK
else
 echo Push with explicit remote parent ............................skipped
fi
echo $N Push with conflict in uncomitted remote delta ...............$NL
cd $HERE/copy/src
bk get $Q -e 'F!O#O$ B%A^R&RR(R)RR'
sed 's/delta two/delta two-local/' 'F!O#O$ B%A^R&RR(R)RR'  > x
mv x 'F!O#O$ B%A^R&RR(R)RR'
bk delta $Q -y 'F!O#O$ B%A^R&RR(R)RR'
cd $HERE/project/src
bk get $Q -e 'F!O#O$ B%A^R&RR(R)RR'
sed 's/delta two/delta two-remote/' 'F!O#O$ B%A^R&RR(R)RR'  > x
mv x 'F!O#O$ B%A^R&RR(R)RR'
bk delta $Q -y 'F!O#O$ B%A^R&RR(R)RR'
bk commit $Q -ytest
bk push $HERE/copy > push.out 2>&1
grep -q "has uncommitted changes" push.out
if [ $? -ne 0 ]; then echo failed; cat push.out; exit 1; fi
echo OK
echo $N pull with a delete event ....................................$NL
bk clone $Q $HERE/project $HERE/copy2
cd $HERE/project/src
bk rm 'F!O#O$ B%A^R&RR(R)RR'
bk commit $Q -ydelete
cd $HERE/copy2/src
bk get $Q 'F!O#O$ B%A^R&RR(R)RR'
bk pull -t $Q $HERE/project
if [ -f 'F!O#O$ B%A^R&RR(R)RR' ]; then echo failed to delete gfile; exit 1; fi
echo OK
echo $N pull with a mvdir event .....................................$NL
cd $HERE/project
bk mvdir src src2/src3
bk commit $Q -ymvdir
cd $HERE/copy2
bk pull $Q -t $HERE/project
if [ ! -f src2/src3/SCCS/s.bar.c ]; then echo failed; exit 1; fi
if [ ! -f src2/src3/SCCS/s.h.h ]; then echo failed; exit 1; fi
echo OK
if [ $PLATFORM != "WIN32" ]
then # -----------------------------------------------------------------
echo $N push -n to a read locked repository should work .............$NL
cd $HERE/copy2
date > newfile
bk new $Q newfile
bk commit $Q -ywhatever
cd $HERE/project
bk lock -r &
KILLME=$!
cd $HERE/copy2
bk push -c1 -n $HERE/project > OUT 2>&1
grep -q 'Would send' OUT || {
	echo failed
	cat OUT
	exit 1
}
echo OK
echo $N push to a read locked repository should fail ................$NL
bk push -c0 $HERE/project > OUT 2>&1
grep -q 'Unable to lock repository for update' OUT || {
	echo failed
	cat OUT
	exit 1
}
kill $KILLME
echo OK
fi #-------------------------------------------------------------------
echo $N push to unrelated project should error ......................$NL
cd $HERE
no_logging unrelated
cd $HERE/project
bk push -nl $HERE/unrelated 2> push.out
grep -q "trying to push to an unrelated" push.out
if [ $? -ne 0 ]; then echo failed; exit 1; fi
cd $HERE/unrelated
waitForUnlock $HERE/unrelated
echo OK
echo $N pull from unrelated project should error ....................$NL
cd $HERE/project
bk pull -nl $HERE/unrelated 2> pull.out
grep -q "trying to pull from an unrelated" pull.out
if [ $? -ne 0 ]; then echo failed; exit 1; fi
cd $HERE/unrelated
waitForUnlock $HERE/unrelated
echo OK

# XXX TODO need test case for pull/pull/clone to/from space in pathname
