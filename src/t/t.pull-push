# Tests for pull, push, and clone.

echo $N Create initial repository ...................................$NL
HERE=`${CWD}`
echo "logging: /dev/null" > $HERE/c
echo "logging_ok: t" >>$HERE/c
bk setup -f -n'BitKeeper Test repository' -c$HERE/c project
if [ ! -d project ]; then echo failed to make top level directory; exit 1; fi
cd project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
mkdir src
cd src
echo foo > foo.c
echo bar > bar.c
echo h > h.h
bk ci $Q -i foo.c bar.c h.h
if [ ! -f SCCS/s.foo.c ]; then echo failed to create history; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 21 ]; then echo wrong pending result $P; bk pending; exit 1; fi
bk commit $S -f -yCset
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo failed to clear pending list; bk pending; exit 1; fi
echo OK
cores
echo $N Clone repository ............................................$NL
cd $HERE
bk clone $Q $HERE/project $HERE/copy || { echo failed; exit 1; }
[ -f copy/src/SCCS/s.foo.c ] || { echo failed; exit 1; }
[ -f copy/BitKeeper/log/parent ] || { echo no parent; exit 1; }
parent=`cat copy/BitKeeper/log/parent`
[ x$parent = x$HERE/project ] || { echo wrong parent $parent; exit 1; }
echo OK

echo $N Pull with no changes in child ...............................$NL
cd project/src
get $Q -e foo.c
echo delta two >> foo.c
delta $Q -y2 foo.c
bk commit $Q -y2
cd $HERE/copy
bk pull $Q || { echo failed; exit 1; }
revs=`prs -hd:I: src/foo.c | wc -l`
[ $revs -eq 2 ] || { echo failed; exit 1; }
echo OK
echo $N Pull with mergeable changes in child ........................$NL
cd src
get $Q -e bar.c
echo line three >>bar.c
delta $Q -ythree bar.c
bk commit $Q -ythree
cd $HERE/project/src
get $Q -e bar.c
mv bar.c bar.x
echo line zero >bar.c
cat bar.x >>bar.c
rm -f bar.x
delta $Q -yzero
bk commit $Q -y0
cd $HERE/copy
bk pull $Q || { echo failed; exit 1; }
cd src
cat >ref-bar.c <<EOF
line zero
bar
line three
EOF
get $Q bar.c
cmp -s ref-bar.c bar.c
[ $? -eq 0 ] || { echo failed; diff ref-bar.c bar.c; exit 1; }
echo OK
clean 
echo $N Push with no upstream deltas ................................$NL
bk push $Q || { echo failed; exit 1; }
mv ref-bar.c $HERE/project/src
cd $HERE/project/src
get $Q bar.c
cmp -s ref-bar.c bar.c
[ $? -eq 0 ] || { echo failed; diff ref-bar.c bar.c; exit 1; }
echo OK
clean 
rm -f ref-bar.c
echo $N Push with an unrelated upstream delta .......................$NL
cd ..
date > stamp
delta $Q -i stamp
bk commit $Q -ytime
KEY="`bk prs -hd:LONGKEY: -r+ ChangeSet`"
cd $HERE/copy/src
get $Q -e h.h
sed 's/h/qwerty/' <h.h >h.x
mv h.x h.h
delta $Q -ydvorak h.h
cd ..
bk commit $Q -yzxcvbnm
bk push $Q || { echo failed; exit 1; }
[ ! -d RESYNC ] || { echo failed; exit 1; }
cd $HERE/project
KEY2="`bk prs -hd:LONGKEY: -r+ ChangeSet`"
[ "$KEY" = "$KEY2" ] || { echo bad push; exit 1; }
echo OK
echo $N Push with a conflicting upstream delta ......................$NL
nextsecond
nextsecond
cd src
get $Q -e h.h
sed 's/h/yuhjklbn/' <h.h >h.x
mv h.x h.h
delta $Q -yrogue h.h
cd ..
bk commit $Q -yrogue
KEY="`bk prs -hd:LONGKEY: -r+ ChangeSet`"
cd $HERE/copy
bk push $Q 2> resolve.out || { echo failed; cat resolve.out; exit 1; }
grep -q 'Overlap change' resolve.out || { echo no conflict; cat resolve.out; exit 1; }
KEY2="`bk prs -hd:LONGKEY: -r+ $HERE/project/ChangeSet`"
[ "$KEY" = "$KEY2" ] || { echo bad push; exit 1; }
echo OK
echo $N Resolve by hand and push again ..............................$NL
EDITOR=ed bk resolve $Q -f - <<EOF 2>resolve.out
m
e
g/^[<>=]/d
w
q
C
EOF
[ $? -eq 0 ] || { echo resolve failed; cat resolve.out; exit 1; }
L=`get $Q -p src/h.h | wc -l`
[ $L -eq 2 ] || { echo merge failed; exit 1; }
KEY="`bk prs -hd:LONGKEY: -r+ ChangeSet`"
bk push $Q || { echo failed; exit 1; }
cd $HERE/project
KEY2="`bk prs -hd:LONGKEY: -r+ ChangeSet`"
[ "$KEY" = "$KEY2" ] || { echo no push; exit 1; }
echo OK
