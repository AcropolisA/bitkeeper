# Copyright (c) 1999 Larry McVoy
# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Test cases:
#	create
#	create with a file but the file gets moved later rename in the patch
#	create with an sfile in the location of the new file
#	create with a gfile (no sfile) in the location of the new file
#	rename with no conflict
#	rename with conflict
#	rename with conflict that gets moved out of the way
#
# In all cases, all files which are affected can not have pending deltas.
# Well, we could make those pending deltas part of a "merge" or "import"
# changeset.

if [ X$Q = X ]
then	L=-l
else	L=
fi

# Create a repository with 5 files in it.  The files contain
# 1, 2, 3, 4, 5 and start out as A, B, C, D, E
echo $N Create initial repository ...................................$NL
HERE=`pwd`
echo "logging: none" > $HERE/config
bk setup -f -n'BitKeeper Test repository' -c$HERE/config project
if [ ! -d project ]; then echo failed to make top level directory; exit 1; fi
cd project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
echo OK
echo $N Create 5 files with 1,2,3,4,5 as contents ...................$NL
echo 1 > A
echo 2 > B
echo 3 > C
echo 4 > D
echo 5 > E
ci $Q -i A B C D E
if [ ! -f SCCS/s.A ]; then echo failed to create history; exit 1; fi
bk commit $S -f -y"This is a \"Change Set\""
echo OK
cores
echo $N Clone a copy of it and save a tarball of it .................$NL
cd $HERE
tar cf SAVE project
resync $Q project copy
echo OK

echo $N create a file w/ tmp conflict which gets renamed away .......$NL
cd $HERE
rm -rf project copy
tar xf SAVE
cp -rp project copy
# project:
#	A -> moved
#	create A
cd project
bk mv A MOVED
touch A
bk new $Q A
bk commit $Q -ywhatever
cd $HERE
bk resync $Q project copy
# Rework the patch to be in the order we want.  We want A first and MOVED 2nd.
cd copy/PENDING
FILE=`echo *`
# Sometimes there is a fudge in the patch so we have to adjust the line numbers
LINES=`wc -l < $FILE`
if [ $LINES -eq 55 ]
then	sed -e 1,29d -e 55d < $FILE > A
	sed -e 1,16d -e 30,55d < $FILE > MOVED
	sed -e 17,55d < $FILE | cat - A MOVED | adler32 > PATCH
fi
if [ $LINES -eq 56 ]
then    sed -e 1,30d -e 56d < $FILE > A
	sed -e 1,17d -e 31,56d < $FILE > MOVED
	sed -e 18,56d < $FILE | cat - A MOVED | adler32 > PATCH
fi
if [ $LINES -ne 55 -a $LINES -ne 56 ]
then	echo Do not understand this patch
    	echo "LINES = '$LINES'"
    	cat -n $FILE
	exit 1
fi
cd ..
rm -rf RESYNC
VV=
if [ X$Q = X ]; then VV=-vv; fi
takepatch $VV -f PENDING/PATCH
if [ $? != 0 ]
then	echo takepatch failed;
	cat -n PENDING/$FILE
	cat -n PENDING/PATCH
	exit 1
fi
cd $HERE
resolve $Q $L copy
if [ $? != 0 ]
then	echo resolved did not exit 0; exit 1
fi
get -s copy/MOVED copy/A project/MOVED project/A
if ! cmp -s copy/MOVED project/MOVED
then	echo MOVED does not match; exit 1
fi
if ! cmp -s copy/A project/A
then	echo A does not match; exit 1
fi
echo OK

echo $N create a file in same pathname slot without s.file ..........$NL
cd $HERE
rm -rf project copy
tar xf SAVE
cp -rp project copy
# project:
#	create CONFLICT
# copy:
#	create CONFLICT
# resync
cd project
echo "I am the project file" > CONFLICT
bk new $Q CONFLICT
bk commit $Q -ywhatever
cd $HERE/copy
echo "I am the copy file" > CONFLICT
cd $HERE
bk resync $Q project copy
tar cf SAVE.copy copy
echo OK
echo $N Resolve by removing local file ..............................$NL
bk resolve $Q $L copy 2>/dev/null <<EOF
r
y
EOF
if [ ! -f copy/CONFLICT ]
then	echo Failed to get CONFLICT file
	find copy -type f -print
	exit 1
fi
if [ "`cat copy/CONFLICT`" != "I am the project file" ]
then	echo Failed to put new file in place; exit 1
fi
if [ `prs -hr+ -d:I: copy/CONFLICT` != "1.1" ]
then	echo 'Added new rev to CONFLICT?'; exit 1
fi
echo OK

echo $N Resolve by renaming local file ..............................$NL
/bin/rm -rf copy
tar xf SAVE.copy
bk resolve $Q $L copy 2>/dev/null <<EOF
ml
LOCAL
EOF
if [ ! -f copy/LOCAL ]
then	echo Failed to rename local file; exit 1
fi
if [ "`cat copy/LOCAL`" != "I am the copy file" ]
then	echo Bad data in local file; cat copy/LOCAL; exit 1
fi
if [ ! -f copy/CONFLICT ]
then	echo Failed to get CONFLICT file
	find copy -type f -print
	exit 1
fi
if [ "`cat copy/CONFLICT`" != "I am the project file" ]
then	echo Failed to put new file in place; exit 1
fi
if [ `prs -hr+ -d:I: copy/CONFLICT` != "1.1" ]
then	echo 'Added new rev to CONFLICT?'; exit 1
fi
echo OK

echo $N Resolve by renaming remote file .............................$NL
/bin/rm -rf copy
tar xf SAVE.copy
bk resolve $Q $L copy 2>/dev/null <<EOF
mr
REMOTE
EOF
if [ ! -f copy/CONFLICT ]
then	echo Failed to leave local file; exit 1
fi
if [ "`cat copy/CONFLICT`" != "I am the copy file" ]
then	echo Bad data in local file; cat copy/CONFLICT; exit 1
fi
if [ ! -f copy/REMOTE ]
then	echo Failed to get REMOTE file
	find copy -type f -print
	exit 1
fi
if [ "`cat copy/REMOTE`" != "I am the project file" ]
then	echo Failed to put new file in place; exit 1
fi
if [ `prs -hr+ -d:I: copy/REMOTE` != "1.2" ]
then	echo 'Failed to add rename rev to REMOTE?'; exit 1
fi
echo OK
exit 1


echo $N create a file in same pathname slot with s.file .............$NL
cd $HERE
rm -rf project copy
tar xf SAVE
cp -rp project copy
# project:
#	create CONFLICT
# copy:
#	create CONFLICT
# resync
cd project
touch CONFLICT
bk new $Q CONFLICT
bk commit $Q -ywhatever
cd $HERE/copy
touch CONFLICT
bk new $Q CONFLICT
bk commit $Q -ywhatever
cd $HERE
bk resync $Q project copy
bk resolve $Q -d -l copy
echo OK

echo $N Rename a file and takepatch, forcing an edit ................$NL
cd project
sccsmv A Z
bk commit $S -f -y'A->Z'
cd ..
resync $Q project copy
cd copy
BK_IGNORELOCK=YES get -e $Q A
date >> A
resolve 2>../ERR
if [ $? != 1 ]
then	echo Resolve did not exit 1; exit 1
fi
cat<<EOF | cmp -s - ../ERR
Warning: A is modified, will not overwrite it.
resolve: found 1 renames in pass 1
===================== ERROR ========================
There are modified files in the repository which are also in the patch.
BitKeeper is aborting this patch until you check in those files.
You need to check in the edited files and run takepatch on the file
in the PENDING directory.  Alternatively, you can rerun pull or resync
that will work too, it just gets another patch.
====================================================
EOF
if [ $? != 0 ]
then	echo Bad error message from resolve
	cat ../ERR
	exit 1
fi
if [ -d RESYNC ]
then	echo Failed to remove RESYNC directory
	exit 1
fi
if [ ! -d PENDING ]
then	echo Failed to leave PENDING dir
	exit 1
fi
echo OK
echo $N Clean the edit and try the first pass of resolve ............$NL
bk unedit $Q A
takepatch $Q -f PENDING/*
resolve $L $Q -234
if [ -f RESYNC/SCCS/s.Z -o ! -f RESYNC/BitKeeper/RENAMES/SCCS/s.1 ]
then	echo Failed to move renamed s.file to RENAMES; exit 1
fi
if [ -f RESYNC/SCCS/m.Z -o ! -f RESYNC/BitKeeper/RENAMES/SCCS/m.1 ]
then	echo Failed to move renamed m.file to RENAMES; exit 1
fi
echo OK
echo $N Run resolve to completion and make sure it moves A to Z .....$NL
resolve $Q $L
if [ -f SCCS/s.A ]
then	echo failed to move A; exit 1
fi
if [ ! -f SCCS/s.Z ]
then	echo failed to create Z; exit 1
fi
echo OK
echo $N Undo that last cset .........................................$NL
bk undo -fqsr+
if [ ! -f SCCS/s.A ]
then	echo failed to bring back A; exit 1
fi
if [ -f SCCS/s.Z ]
then	echo failed to delete Z; exit 1
fi
echo OK
echo $N Do some work in Z/A and resync ..............................$NL
cd $HERE/project
get $Q -e Z
echo same data >> Z
ci $Q -y'change as Z'
bk commit $S -f -y'change as Z'
cd $HERE/copy
get $Q -e A
echo same data >> A
ci $Q -y'change as A'
bk commit $S -f -y'change as A'
resync $Q $HERE/project $HERE/copy
if [ ! -f RESYNC/SCCS/r.Z ]
then	echo failed to create conflict for Z; exit 1
fi
echo OK
echo $N Run pass 1 of resolve and make sure m/r files move ..........$NL
resolve $L $Q -234 
if [ -f RESYNC/SCCS/s.Z -o ! -f RESYNC/BitKeeper/RENAMES/SCCS/s.1 ]
then	echo Failed to move renamed s.file to RENAMES; exit 1
fi
if [ -f RESYNC/SCCS/m.Z -o ! -f RESYNC/BitKeeper/RENAMES/SCCS/m.1 ]
then	echo Failed to move renamed m.file to RENAMES; exit 1
fi
if [ -f RESYNC/SCCS/r.Z -o ! -f RESYNC/BitKeeper/RENAMES/SCCS/r.1 ]
then	echo Failed to move renamed r.file to RENAMES; exit 1
fi
echo OK
echo $N Run pass 2 of resolve and make sure r file moves back .......$NL
resolve $L $Q -134 
if [ ! -f RESYNC/SCCS/s.Z ]
then	echo Failed to move renamed s.file from RENAMES; exit 1
fi
if [ ! -f RESYNC/SCCS/r.Z ]
then	echo Failed to move renamed r.file from RENAMES; exit 1
fi
echo OK
echo $N Run resolve in no conflict mode and make sure it fails ......$NL
resolve $L $Q -c 2>ERR
if [ $? = 0 ]
then	echo Failed to return an error
fi
echo OK
# XXX - need a test where the only conflict is the ChangeSet file and that
# gets automerged.

# Start testing conflicts.
echo $N Run resolve in automerge mode and make sure it merges .......$NL
resolve $L $Q -a
if [ $? != 0 ]
then	echo failed; exit 1
fi
echo OK
