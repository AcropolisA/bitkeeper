# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Copyright (c) 2002 Wayne Scott
# %K%

echo $N Test resolving file missing a newline .......................$NL
no_logging proj
echo line 1 > file
bk new $Q file || exit 1
bk commit $Q -ystart || exit 1
cd $HERE
bk clone $Q proj copy
cd proj
bk edit $Q file
echo $NX new line without NL $NXL >> file
cp file ../file.bak
bk delta $Q -ynonl file || exit 1
bk commit $Q -ynew_remote || exit 1
cd $HERE/copy
bk edit $Q file
echo new line with NL >> file
bk delta $Q -ynl file || exit 1
bk commit $Q -ynew_local || exit 1
bk pull $Q 2> OUT && {
	echo should not pass
	exit 1
}
grep -q 'Conflicts during automerge of file' OUT || {
	echo pull should have had conflict
	bk cat file
	cat OUT
	exit 1
}
echo ur | bk resolve $Q -t 2>OUT || {
	echo resolve should work
	exit 1
}
bk get $Q file || exit 1
cmp -s file ../file.bak || {
	echo file did not match remote
	exit 1
}
echo OK

echo $N Test exiting out a resolve early deleting files .............$NL
bk unpull -f $Q || exit 1
bk edit $Q file || exit 1
bk pull $Q 2> OUT && {
	echo should not pass
	exit 1
}
grep -q 'Conflicts during automerge of file' OUT || {
	echo pull should have had conflict
	exit 1
}
echo q | bk resolve $Q -t 2>OUT && {
	echo resolve should have failed
	exit 1
}
test -w file || {
	echo file should be writable
	exit 1
}
test -f SCCS/p.file || {
	echo file should be locked
	exit 1
}
echo OK

echo $N Test permission problems in resolve .........................$NL
cd $HERE/proj
mkdir dir1
echo ff > dir1/ff
mkdir dir2
echo gg > dir2/gg
echo "space me" > "dir2/space file"
bk new $Q dir1/ff dir2/gg "dir2/space file" || exit 1
bk commit $Q -ystart || exit 1
mkdir dir3
chmod -w dir3
bk -r check -ac || exit 1
cd ..
bk clone $Q proj copy2 || exit 1
cd copy2
bk edit $Q dir1/ff dir2/gg || exit 1
echo ff2 >> dir1/ff
echo gg2 >> dir2/gg
bk delta $Q -yappend dir1/ff dir2/gg || exit 1
mkdir dir3
mkdir dir3/dir33
echo hh > dir3/dir33/hh
bk new $Q dir3/dir33/hh || exit 1
bk commit $Q -yappend
bk push > OUT 2>&1
status=$?
chmod -R +w $HERE
test $status != 0 || {
	echo push shouldn\'t have worked
	cat OUT
	exit 1
}
grep 'No write permission: dir3' OUT > /dev/null || {
	echo wrong error message
	cat OUT
	exit 1
}
cd $HERE/proj
bk abort -f
bk -r check -acf || exit 1
echo OK

echo $N What if you don\'t have permisisons to delete a file..........$NL
chmod -w dir2/SCCS
cd $HERE/copy2
bk mv dir2/gg dir3/gg || exit 1
bk commit -ymv $Q || exit 1
bk push > OUT 2>&1
status=$?
chmod -R +w $HERE
test $status != 0 || {
	echo push shouldn\'t have worked
	cat OUT
	exit 1
}
grep 'No write permission: dir2' OUT > /dev/null || {
	echo wrong error message
	cat OUT
	exit 1
}
cd $HERE/proj
bk abort -f
bk -r check -acf || exit 1
echo OK

echon Test listing of files in conflict ...........................
cd $HERE
bk clone $Q proj copy3 || exit 1
for d in proj copy3; do
	cd $HERE/$d
	for f in file dir1/ff dir2/gg "dir2/space file" ; do
		bk edit $Q "$f"
		echo $d >> $f
		bk delta $Q -y"$d side" "$f" || exit 1
	done
	bk commit -y"$d" $Q || exit 1
done
cd $HERE/copy3
bk pull $Q 2> OUT && {
	echo pull should have had conflict
	exit 1
}
# List files in conflict
bk undos << EOF | sort > CMP1
file
dir1/ff
dir2/gg
dir2/space file
EOF
bk conflicts | sort > CMP2
cmp -s CMP1 CMP2
if [ $? -ne 0 ]; then echo Failed.; diff CMP[12]; exit 1; fi
# test ordering of prs options: sfile gfile REMOTE LOCAL GCA
cd RESYNC > /dev/null
bk sfiles -U "$@" | bk prs -hnr+ \
-d'$if(:RREV:){:DPN:|:PN:|:LREV:|:RREV:|:GREV:|:RREV:|:PN:|:LREV:|:GREV:|:DPN:}' - > INPUT
while IFS='|' read GF1 SF1 LR1 RR1 GR1 RR2 SF2 LR2 GR2 GF2
do	test "$GF1" = "$GF2" || { echo Failed gfile; exit 1; }
	test "$SF1" = "$SF2" || { echo Failed sfile; exit 1; }
	test "$LR1" = "$LR2" || { echo Failed local rev; exit 1; }
	test "$RR1" = "$RR2" || { echo Failed remote rev; exit 1; }
	test "$GR1" = "$GR2" || { echo Failed gca rev; exit 1; }
done < INPUT
cd .. > /dev/null
echo OK

echon Testing output of conflicts command .........................
bk undos << EOF | sort > CMP1
file                 1 conflicts by bk 
dir1/ff              1 conflicts by bk 
dir2/gg              1 conflicts by bk 
EOF
bk conflicts -l | sort > CMP2
if [ $? -ne 0 ]; then echo Failed.; diff CMP[12]; exit 1; fi
echo OK

echon Testing skip command ........................................
bk conflicts | sed -e1d -e3d > CMP1
bk resolve $Q << EOF > OUT 2>&1
ul
S
ul
EOF
bk conflicts > CMP2
cmp -s CMP1 CMP2
if [ $? -ne 0 ]; then echo Failed.; diff CMP[12]; exit 1; fi
echo OK

echon Testing locking of RESYNC dir ...............................
touch RESYNC/BitKeeper/tmp/resolve_lock
bk undos << EOF > CMP1
Could not get lock on RESYNC directory.
EOF
bk resolve -q 2>&1 | head -1 > CMP2
cmp -s CMP1 CMP2
if [ $? -ne 0 ]; then echo Failed.; diff CMP[12]; exit 1; fi
echo OK

echo $N Do a \'rr\' when given a create/gfile conflict ................$NL
cd $HERE
rm -rf copy2
bk clone $Q proj copy2 || exit 1
cd proj
bk abort -f
echo hh > hh
bk new $Q hh
bk commit $Q -ynewhh || exit 1
cd $HERE/copy2
echo hj > hh
(echo rr; echo y) | bk pull $Q 2> ERRS || exit 1
echo OK

echo $N Check vr when remote is on a branch .........................$NL
cd $HERE/proj
echo VERSION 1 > foo
bk new $Q foo
bk commit $Q -yfoo
cd ..
bk clone $Q proj vrcopy
cd proj
bk edit $Q foo
echo VERSION 2 > foo
bk delta $Q -y2 foo
bk commit $Q -yfoo
cd ../vrcopy
bk edit $Q foo
bk delta $Q -y2 foo  
bk commit $Q -yfoo
cd ../proj
bk pull $Q ../vrcopy  
cd ../vrcopy
bk edit $Q foo
echo VERSION 3 > foo
bk delta $Q -y2 foo
bk commit $Q -yfoo
cd ../proj
bk pull $Q -R ../vrcopy
bk resolve -t <<EOF > VR 2>&1
vr
q
EOF
# When failing, gave VERSION 2
grep -q "VERSION 3" VR || {
	echo Fail
	echo Expecting to contain the string "'VERSION 3'" and resolve gave
	cat VR
	exit 1
}
echo OK

echo $N Check pass1 to see if dups when no dup.......................$NL
cd $HERE
export CLOCK_DRIFT=1
no_logging p1d
mkdir src
touch src/foo
bk new $Q src/foo
# 3 long names
list="alkjlskdjflksjfdjdfskjdflsjfljfd
	aladflskdjflskjdikjsdfdlsjdadd
	polbnlknsdlkafljalfjallskdjskj"
# make 162 files with long names
for a in $list; do
	for b in $list; do
		for c in $list; do
			file=''
			dir=AB/$a/$b/$c
			mkdir -p $dir
			for d in $list; do
				file="$file $dir/a$d $dir/b$e$d"
			done
			touch $file
			bk new $Q $file
		done
	done
done
bk commit $Q -y'a whole lot of files'
cd ..
bk clone $Q p1d p1dtmp
cd p1dtmp
bk mv src/foo .foo
bk mv AB A
bk commit $Q -y'a whole lot of moving'
cd ../p1d
bk pull -qR ../p1dtmp
bk resolve $Q -234 2> ERR || {
	echo Fail
	cat ERR
	exit 1
}
echo OK

echo $N Make sure resolve reruns when there are conflicts ...........$NL
cd $HERE/proj
bk abort -f
cd $HERE
bk clone $Q proj conflict
for i in proj conflict
do
	cd $HERE/$i
	bk edit $Q foo
	echo $i >> foo
	bk delta $Q -y$i foo
	bk commit $Q -y$i 
done
cd $HERE/conflict
( echo '?'
  echo q
) | BK_FORCE_RESOLVE_RERUN=YES bk pull > OUT 2>&1
grep -q 'starting manual resolve process.' OUT || {
	echo Did not restart resolve
	cat OUT
	exit 1
}
echo OK
