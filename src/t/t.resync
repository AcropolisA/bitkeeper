# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Copyright (c) 1999 Andrew Chang?
# %K%

# XXX still need to test propagation of:
# descriptive text
# permissions
# LODs
# per file information (flags, etc.)

if [ X$PLATFORM = X"WIN32" ]
then
        binary_data="`bk bin`/bk.exe"
        binary_data2="`bk bin`/diff.exe"
else
        binary_data="/bin/ls"
        binary_data2="/bin/rm"
fi

echo $N Create initial repository ...................................$NL
no_logging project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -d BitKeeper/tmp ]; then echo failed to make BitKeeper/tmp; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
echo OK
echo $N Create some data ............................................$NL
mkdir src
cd src
echo foo > foo.c
echo bar > bar.c
echo h > h.h
bk ci $Q -i foo.c bar.c h.h
if [ ! -f SCCS/s.foo.c ]; then echo failed to create history; exit 1; fi
echo OK
echo $N Check pending ...............................................$NL
P=`bk pending | wc -l`
if [ $P -ne 15 ]; then echo wrong pending result $P; bk pending; exit 1; fi
echo OK
echo $N Create a change set .........................................$NL
bk commit $S -a -y"This is a \"Change Set\""
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo failed to clear pending list; bk pending; exit 1; fi
echo OK
cores
echo $N Create a copy of the project with clone .....................$NL
cd $HERE
bk clone $Q project clone
if [ ! -d clone ]; then echo failed to make top level directory; exit 1; fi
cd clone
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -d BitKeeper/tmp ]; then echo failed to make BitKeeper/tmp; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
if [ ! -f BitKeeper/log/parent ]; then echo failed to record parent; exit 1; fi
P=`ls -l SCCS/s.ChangeSet`
case "$P" in
-r--r--r--*) echo OK
	;;
*)
	echo failed
	exit 1
	;;
esac
cd $HERE
bk clone $Q project copy
echo $N Should not be able to resync unrelated repositories .........$NL
cd $HERE
no_logging project2
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
echo "don't stand in the doorway, don't block up the hall" > times
bk ci $Q -i -ydylan times
bk commit $S -a -yCset2
cd ..
bk resync $Q -at project project2 2>resync.out
if [ $? -eq 0 ]; then echo failed; cat resync.out; exit 1; fi
if [ -d project2/src ]; then echo failed; exit 1; fi
echo OK
cores
echo $N Check circular rename .......................................$NL
cd $HERE/project/src
echo "File 1" > a.c
echo "File 2" > b.c
echo "File 3" > c.c
# XXX - used to be bk repo || sleep 2
while ! bk lock -s; do true; done
bk ci $Q -i a.c b.c c.c
rm -f a.c b.c c.c
bk commit $S -yabc
cd $HERE/copy
bk pull -t $Q $HERE/project
cd $HERE
tar cf chkpoint.tar copy
cd $HERE/project/src
# do circular renames (clockwise rotation)
# b.c = File 1
# c.c = File 2
# a.c = File 3
bk sccsmv SCCS/s.c.c SCCS/s.d.c
bk sccsmv SCCS/s.b.c SCCS/s.c.c
bk sccsmv SCCS/s.a.c SCCS/s.b.c
bk sccsmv SCCS/s.d.c SCCS/s.a.c
bk commit $S -yclockwise
cd $HERE/copy
bk pull -t $Q $HERE/project
cd $HERE/copy/src
bk get $Q a.c b.c c.c
echo "File 3" > X
bk undos X > ref.c
cmp -s ref.c a.c
if [ $? -ne 0 ]; then echo "failed a"; exit 1; fi
echo "File 1" > X
bk undos X > ref.c
cmp -s ref.c b.c
if [ $? -ne 0 ]; then echo "failed b"; exit 1; fi
echo "File 2" > X
bk undos X > ref.c
cmp -s ref.c c.c
if [ $? -ne 0 ]; then echo "failed c"; exit 1; fi
echo OK
cores
echo $N Check conflict within a patch ...............................$NL
cd $HERE/project/src
# d.c = File 2
# c.c = File 4
bk sccsmv c.c d.c
echo "File 4" > c.c
bk ci $Q -i c.c
bk commit $S -y'Add d.c'
cd  $HERE/copy/src
bk pull -t $Q $HERE/project
if [ $? -ne 0 ]; then	echo pull failed; exit 1; fi
bk get $Q a.c b.c c.c d.c
echo "File 3" > X
bk undos X > ref.c
cmp -s ref.c a.c
if [ $? -ne 0 ]; then echo "failed a.c"; cat a.c; exit 1; fi
echo "File 1" > X
bk undos X > ref.c
cmp -s ref.c b.c
if [ $? -ne 0 ]; then echo "failed b.c"; cat b.c; exit 1; fi
echo "File 4" > X
bk undos X > ref.c
cmp -s ref.c c.c
if [ $? -ne 0 ]; then echo "failed c.c"; cat c.c; exit 1; fi
echo "File 2" > X
bk undos X > ref.c
cmp -s ref.c d.c
if [ $? -ne 0 ]; then echo "failed d.c"; cat d.c; exit 1; fi
echo OK
cores
echo $N Check conflict within a patch + circular rename..............$NL
# XXX - what conflict?
cd  $HERE
rm -rf $HERE/copy
tar xf chkpoint.tar
bk resync $Q $HERE/project $HERE/copy
cd  $HERE/copy/src
bk resolve -t $L $Q
bk get $Q a.c b.c c.c d.c
echo "File 3" > X
bk undos X > ref.c
cmp -s ref.c a.c
if [ $? -ne 0 ]; then echo "failed a.c"; cat a.c; exit 1; fi
echo "File 1" > X
bk undos X > ref.c
cmp -s ref.c b.c
if [ $? -ne 0 ]; then echo "failed b.c"; cat b.c; exit 1; fi
echo "File 4" > X
bk undos X > ref.c
cmp -s ref.c c.c
if [ $? -ne 0 ]; then echo "failed c.c"; cat c.c; exit 1; fi
echo "File 2" > X
bk undos X > ref.c
cmp -s ref.c d.c
if [ $? -ne 0 ]; then echo "failed d.c"; cat d.c; exit 1; fi
echo OK
cores
echo $N Check circular rename in two work spaces ....................$NL
cd  $HERE
rm -rf $HERE/copy
tar xf chkpoint.tar
# $HERE/project already has circular rename w/ clockwise rotation
# a.c = File 3
# b.c = File 1
# c.c = File 4
# d.c = File 2
cd $HERE/project/src
if [ "`bk get -qp a.c`" != "File 3" ]
then	echo a.c is not File 3; exit 1
fi
if [ "`bk get -qp b.c`" != "File 1" ]
then	echo b.c is not File 1; exit 1
fi
if [ "`bk get -qp c.c`" != "File 4" ]
then	echo c.c is not File 4; exit 1
fi
if [ "`bk get -qp d.c`" != "File 2" ]
then	echo d.c is not File 2; exit 1
fi

# For $HERE/copy, we do a circular renames w/ counter clockwise rotation
cd  $HERE/copy/src
# a.c = File 2
# b.c = File 3
# c.c = File 1
bk sccsmv a.c tmp
bk sccsmv b.c a.c
bk sccsmv c.c b.c
bk sccsmv tmp c.c
if [ "`bk get -qp a.c`" != "File 2" ]
then	echo a.c is not File 2; exit 1
fi
if [ "`bk get -qp b.c`" != "File 3" ]
then	echo b.c is not File 3; exit 1
fi
if [ "`bk get -qp c.c`" != "File 1" ]
then	echo c.c is not File 1; exit 1
fi
bk commit $S -y'counter clockwise'
bk resync $Q $HERE/project $HERE/copy
cp -rp $HERE/copy $HERE/SAVE
cd  $HERE/copy
# This is completely dependent on the ordering of file processing in resolve.
# So what we do is run the first step of the rename processing and then
# go move them into the order we want: File 1, File 2, File 3, File 4
bk resolve $L $Q -234 -t
cd RESYNC/BitKeeper/RENAMES
bk co $Q
for n in 1 2 3 4
do	set `cat $n`
	mv SCCS/s.$n SCCS/s.FILE$2
	if [ -f SCCS/r.$n ]; then mv SCCS/r.$n SCCS/r.FILE$2; fi
	if [ -f SCCS/m.$n ]; then mv SCCS/m.$n SCCS/m.FILE$2; fi
	rm -f $n
done
for n in 1 2 3 4
do	mv SCCS/s.FILE$n SCCS/s.$n
	if [ -f SCCS/r.FILE$n ]; then mv SCCS/r.FILE$n SCCS/r.$n; fi
	if [ -f SCCS/m.FILE$n ]; then mv SCCS/m.FILE$n SCCS/m.$n; fi
	rm -f $n
done
cd  $HERE/copy
# This is completely dependent on the ordering of file processing in resolve
# If this doesn't work, check that the files are processed in this order:
# File 1, File 2, File 3, File 4
bk resolve $L $Q -t -yMerge << EOF 2> resolve.out
r
r
r
src/d.c
u
EOF
if [ $? != 0 ]; then echo failed; cat resolve.out; exit 1; fi
cd  $HERE/copy/src
if [ "`bk get -qp a.c`" != "File 3" ]
then	echo a.c is not File 3; exit 1
fi
if [ "`bk get -qp b.c`" != "File 1" ]
then	echo b.c is not File 1; exit 1
fi
if [ "`bk get -qp c.c`" != "File 4" ]
then	echo c.c is not File 4; exit 1
fi
if [ "`bk get -qp d.c`" != "File 2" ]
then	echo d.c is not File 2; exit 1
fi
echo OK
cores
echo $N Check circular rename in two work spaces - alternate ........$NL
cd  $HERE
rm -rf $HERE/copy
tar xf chkpoint.tar
# $HERE/project already has circular rename w/ clockwise rotation
# a.c = File 3
# b.c = File 1
# c.c = File 4
# d.c = File 2

# For $HERE/copy, we do a circular renames w/ counter clockwise rotation
cd  $HERE/copy/src
# a.c = File 2
# b.c = File 3
# c.c = File 1
bk sccsmv a.c tmp
bk sccsmv b.c a.c
bk sccsmv c.c b.c
bk sccsmv tmp c.c
if [ "`bk get -qp a.c`" != "File 2" ]
then	echo a.c is not File 2; exit 1
fi
if [ "`bk get -qp b.c`" != "File 3" ]
then	echo b.c is not File 3; exit 1
fi
if [ "`bk get -qp c.c`" != "File 1" ]
then	echo c.c is not File 1; exit 1
fi
bk commit $S -y'counter clockwise'
bk resync $Q $HERE/project $HERE/copy
cp -rp $HERE/copy $HERE/SAVE
cd  $HERE/copy
# This is completely dependent on the ordering of file processing in resolve.
# So what we do is run the first step of the rename processing and then
# go move them into the order we want: File 1, File 2, File 3, File 4
bk resolve $L $Q -234 -t
cd RESYNC/BitKeeper/RENAMES
bk co $Q
for n in 1 2 3 4
do	set `cat $n`
	mv SCCS/s.$n SCCS/s.FILE$2
	if [ -f SCCS/r.$n ]; then mv SCCS/r.$n SCCS/r.FILE$2; fi
	if [ -f SCCS/m.$n ]; then mv SCCS/m.$n SCCS/m.FILE$2; fi
	rm -f $n
done
for n in 1 2 3 4
do	mv SCCS/s.FILE$n SCCS/s.$n
	if [ -f SCCS/r.FILE$n ]; then mv SCCS/r.FILE$n SCCS/r.$n; fi
	if [ -f SCCS/m.FILE$n ]; then mv SCCS/m.FILE$n SCCS/m.$n; fi
	rm -f $n
done

cd  $HERE/copy
bk resolve -1 $L $Q -t -yMerge << EOF 2> resolve.out
?
m
src/junk
?
l
?
l
u
EOF
if [ $? != 0 ]; then echo failed; head -100 resolve.out; exit 1; fi
cd  $HERE/copy/src
if [ "`bk get -qp a.c`" != "File 2" ]
then	echo a.c is not File 2; exit 1
fi
if [ "`bk get -qp b.c`" != "File 3" ]
then	echo b.c is not File 3; exit 1
fi
if [ "`bk get -qp junk`" != "File 1" ]
then	echo c.c is not File 1; exit 1
fi
if [ "`bk get -qp c.c`" != "File 4" ]
then	echo d.c is not File 4; exit 1
fi
echo OK
cores

echo $N Check name conflict caused by rename ........................$NL
cd $HERE/project/src
echo "this is file gca" > g.c
bk ci $Q -i g.c
bk commit $S -yrename
cd  $HERE
rm -rf $HERE/copy
tar xf chkpoint.tar
bk resync $Q $HERE/project $HERE/copy
bk resolve -t $L $Q $HERE/copy
cd $HERE/copy/src
if [ ! -f SCCS/s.g.c ]; then echo failed, no g.c; fi
cd $HERE/project/src
bk sccsmv g.c r.c
bk commit $S -yrename
cd $HERE/copy/src
bk sccsmv g.c l.c
echo "this is file p" > p.c
bk ci $Q -i p.c
bk sccsmv p.c r.c
bk commit $S -yrename
bk resync $Q $HERE/project $HERE/copy
bk resolve $L $Q -t -yMerge << EOF 2> resolve.out
r
EOF
if [ $? -eq 0 ]; then echo failed; cat resolve.out; exit 1; fi
echo OK

echo $N resync w/ pending rename in target tree .....................$NL
cd  $HERE
rm -rf $HERE/copy
tar xf chkpoint.tar
bk clean $HERE/copy/src
cd $HERE/copy/src
bk get $Q -p a.c >ref.c
bk mv a.c e.c
bk resync $Q $HERE/project $HERE/copy  > resync.out 2>&1
grep -q "has uncommitted changes" resync.out
if [ $? -ne 0 ]; then echo failed; else echo OK; fi;
rm -f resync.out
cores

echo $N resync w/ pending rename in source tree .....................$NL
cd $HERE/project/src
bk get $Q -e a.c
bk sccsmv a.c f.c
cd  $HERE
rm -rf $HERE/copy
tar xf chkpoint.tar
bk clean $HERE/copy/src
cd $HERE/copy/src
bk resync $Q $HERE/project $HERE/copy
bk resolve -t $L $Q $L
bk admin -z $HERE/project/src/SCCS/s.f.c $HERE/copy/src/SCCS/s.a.c
diff $HERE/project/src/SCCS/s.f.c $HERE/copy/src/SCCS/s.a.c
if [ $? -ne 0 ]; then echo failed on f.c; exit 1; fi;
bk admin -z $HERE/project/src/SCCS/s.b.c $HERE/copy/src/SCCS/s.b.c
diff $HERE/project/src/SCCS/s.b.c $HERE/copy/src/SCCS/s.b.c
if [ $? -ne 0 ]; then echo failed on b.c; exit 1; fi;
bk admin -z $HERE/project/src/SCCS/s.c.c $HERE/copy/src/SCCS/s.c.c
diff $HERE/project/src/SCCS/s.c.c $HERE/copy/src/SCCS/s.c.c
if [ $? -ne 0 ]; then echo failed on c.c; exit 1; fi;
echo OK
cores

echo $N Key conflict in a single workspace ..........................$NL
# this test is time dependent
# this colud fail on a very fast machine
echo "12" > $HERE/project/src/aa.c
bk ci $Q -i $HERE/project/src/aa.c
bk sccsmv $HERE/project/src/aa.c  $HERE/project/src/bb.c
echo "21" > $HERE/project/src/aa.c
bk ci $Q -i $HERE/project/src/aa.c
KEY1=`bk prs -hr+ -d:KEY: $HERE/project/src/bb.c`
KEY2=`bk prs -hr+ -d:KEY: $HERE/project/src/aa.c`
if [ "${KEY1}"X = "${KEY2}"X ]; then echo failed: duplicate key; exit 1; fi
echo OK
rm -f  $HERE/project/src/SCCS/s.aa.c  $HERE/project/src/SCCS/s.bb.c
echo $N Key conflict in two workspace ...............................$NL
# this test is time dependent
# this colud fail on a very fast machine
echo "12" > $HERE/project/src/dup.c
echo "21" > $HERE/copy/src/dup.c
bk ci $Q -i $HERE/project/src/dup.c $HERE/copy/src/dup.c
KEY1=`bk prs -hr1.0 -d:KEY: $HERE/project/src/dup.c`
KEY2=`bk prs -hr1.0 -d:KEY: $HERE/copy/src/dup.c`
if [ "${KEY1}"X = "${KEY2}"X ]; then echo failed: duplicate key; exit 1; fi
echo OK
cores
rm -f $HERE/project/src/SCCS/s.dup.c $HERE/copy/src/SCCS/s.dup.c
echo $N Check resync with binary file ...............................$NL
cd  $HERE
rm -rf $HERE/copy
tar xf chkpoint.tar
cd $HERE/project/src
cp $binary_data data
bk admin $Q -idata -Ebinary bdata
bk get $Q -r1.1 -Gbdata bdata
cmp -s bdata $binary_data
if [ $? -ne 0 ]; then echo failed test 1; cmp bdata $binary_data; exit 1; fi
bk commit $S -Sbinary1 -ybinary1
bk get $Q -e bdata
cp $binary_data2 bdata
bk ci $Q -y bdata
bk commit $S -Sbinary2 -ybinary2
bk resync $Q $HERE/project $HERE/copy
cd  $HERE/copy/src
bk resolve -t $L $Q
test -d RESYNC && {
	echo failed to finish resolve
	exit 1
}
bk get $Q bdata
cmp -s bdata $binary_data2
if [ $? -ne 0 ]; then echo failed; fi
bk clone $Q -rbinary1 $HERE/copy $HERE/copy2
cd $HERE/copy2/src
bk get $Q bdata
cmp -s bdata $binary_data
if [ $? -ne 0 ]; then echo failed; fi
(cd $HERE/copy && bk cset -mbinary2) | (cd $HERE/copy2 && bk takepatch)
bk resolve -t $L $Q $HERE/copy2
bk get $Q bdata
cmp -s bdata $binary_data2
if [ $? -ne 0 ]; then echo failed test 4; cmp bdata $binary_data2; exit 1; fi
echo OK
cores
echo $N Check resolve w/ merge and delete event .....................$NL
cd $HERE/project/src
cat > merge.c << EOF
111
222
333
EOF
mkdir sub
echo "To be deleted" > sub/delete.c
bk ci $Q -i merge.c sub/delete.c
bk commit $S -y"abc"
cd $HERE/project/src
bk resync $Q $HERE/project $HERE/copy
bk resolve -t $L $Q $HERE/copy
if [ ! -f $HERE/copy/src/sub/SCCS/s.delete.c ]; then echo failed; exit 1; fi
bk rm sub/delete.c
#if [ ! -f "$HERE/project/BitKeeper/deleted/SCCS/s..del-delete.c" ]
ls $HERE/project/BitKeeper/deleted/SCCS | grep -q "^s..del-delete.c"
if [ $? -ne 0 ]; then echo failed; exit 1; fi
bk co $Q -l merge.c
sed -e"s/111/111-new/" merge.c > merge.tmp
mv merge.tmp merge.c
bk ci $Q -y merge.c
bk commit $S -y"abc"
cd $HERE/copy/src
bk co $Q -l merge.c
sed -e "s/333/333-newer/"  merge.c > merge.tmp
mv merge.tmp merge.c
bk ci $Q -y merge.c
bk commit $S -y"abc"
bk resync $Q $HERE/project $HERE/copy
bk resolve $L $Q -a -t $HERE/copy
ls $HERE/copy/BitKeeper/deleted/SCCS | grep -q "^s..del-delete.c"
if [ $? -ne 0 ]
then	echo failed to delete delete.c;
	pwd
	bk _find .| grep "delete" 
	exit 1
fi
if [ -d $HERE/copy/src/sub ]; then echo failed rmdir; exit 1; fi
bk co $Q merge.c
cat > X <<EOF
111-new
222
333-newer
EOF
bk undos X > merge.ref
cmp -s merge.c merge.ref
if [ $? -ne 0 ]; then echo failed; diff -u merge.c merge.ref; exit 1; fi
echo OK
cores
echo $N Merge back up should have no conflicts ......................$NL
cd $HERE
bk ci $Q -yrename project/src/f.c
bk resync $Q copy project
bk resolve -t project >resolve.out 2>&1
if [ $? -ne 0 ]
then echo failed
     cat resolve.out
fi
echo OK
cores
rm -f resolve.out

echo $N Test propagation of a symbol on new changeset ...............$NL
cd $HERE/project/src
date > symbol_test
bk new $Q symbol_test
bk commit $S -y"symbol test" -S'symbol test'
bk resync -t $Q -a $HERE/project $HERE/copy
cd $HERE/copy
if [ ! -f src/SCCS/s.symbol_test ]; then echo failed to send file; exit 1; fi
grep -q 'Ssymbol test' SCCS/s.ChangeSet
if [ $? != 0 ]; then echo failed; exit 1; fi
echo OK
cores

echo $N Test propagation of a stand alone symbol "(meta delta)" .......$NL
cd $HERE/project
date > dummy
bk new $Q dummy
bk commit $S -y"symbol test2"
bk admin $Q -S'later symbol' SCCS/s.ChangeSet
bk resync -t $Q $HERE/project $HERE/copy
grep -q 'S later symbol' $HERE/copy/PENDING/* || {
	echo symbol not part of the patch
	cat $HERE/copy/PENDING/*
	exit 1
}
cp $HERE/copy/PENDING/* $HERE
bk resolve -t -a $Q $HERE/copy
cd $HERE/copy
grep -q 'Slater symbol' SCCS/s.ChangeSet
if [ $? != 0 ]; then echo failed to send symbol; exit 1; fi
echo OK

echo $N Test propagation of a symbol added later and unrelated data..$NL
cd $HERE/project
bk admin $Q -S'additional symbol:1.1' SCCS/s.ChangeSet
bk co $Q -l dummy
date > dummy
bk ci $Q -m'additional' dummy
bk commit $S -y'additional symbol test 2'
bk resync -t $Q -a $HERE/project $HERE/copy
cd $HERE/copy
grep -q 'Sadditional symbol' SCCS/s.ChangeSet
if [ $? != 0 ]; then echo failed; else echo OK; fi

echo $N Test propagation of a symbol added later by itself ..........$NL
cd $HERE/project
bk admin $Q -S'YAsymbol:1.5' ChangeSet
bk resync -t $Q -a $HERE/project $HERE/copy
cd $HERE/copy
grep -q 'YAsymbol' SCCS/s.ChangeSet
if [ $? != 0 ]; then echo failed; else echo OK; fi
cores

# TEST: Check for parallel work winds up losing a file
# This is a test for the ChangeSet file weave...
echo "----------- Andrew's anomaly (file disappears) -----------"
cd $HERE
rm -fr project copy
echo $N Create initial repository ...................................$NL
no_logging project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
mkdir src
cd src
cat << EOF > aaa.c
1
2
3
EOF
cp aaa.c bbb.c
cp aaa.c ccc.c
bk ci $Q -i aaa.c bbb.c ccc.c
bk commit $S -a -yCset
echo OK
echo $N Create a copy of the project ................................$NL
cd $HERE
bk resync $Q project copy
echo OK
echo $N Commit parallel work ........................................$NL
cd $HERE/project/src
for i in aaa.c bbb.c
do
        bk co $Q -l $i
        echo "this is $i" >> $i
        bk ci $Q -y $i
done
bk commit $S -yab << EOF
y
EOF
cd $HERE/copy/src
for i in bbb.c ccc.c
do
        bk co $Q -l $i
        sed -e"s/1/111/" $i > $i.T
        mv $i.T $i
        bk ci $Q -y $i
done
bk commit $S -ybc
echo OK
echo $N Resync project to copy, check for file presence in cset .....$NL
cd $HERE
bk resync $Q project copy 
cd $HERE/copy
bk resolve $L $Q -t << EOF > resolve.out 2>&1
m
C
comment for merge
.
u
EOF
if [ $? != 0 ]; then echo failed; exit 1; fi
if [ -d RESYNC ]
then	echo failed to finish resolve; exit 1
fi
# There should be anything pending
bk pending | grep -q "aaa.c"
if [ $? -eq 0 ]; then echo "fail: disappeared from ChangeSet"; exit 1; fi
echo OK
echo $N Make sure that we update gfiles appropriately ...............$NL
cd $HERE/copy/src
bk co $Q
cd $HERE/project/src
bk edit -q aaa.c
echo "NEW NEW NEW" >> aaa.c
bk ci -q -yaaa.c aaa.c
bk commit -q -yaaa.c
cd $HERE
bk resync -t -a $Q project copy
cd copy/src
if [ ! -f aaa.c ]; then echo Failed to get aaa.c; exit 1; fi
bk co -qp aaa.c > aaa.p
diff aaa.p aaa.c
if [ $? -ne 0 ]
then	echo Failed to update aaa.c
	exit 1
fi
rm aaa.p aaa.c
echo OK
echo $N Check resolve w/ auto merge and overlap change ..............$NL
cd $HERE/project/src
cat > overlap.c << EOF
111
222
333
EOF
bk ci $Q -i overlap.c
bk commit $S -y"abc"
bk resync $Q $HERE/project $HERE/copy
cd $HERE; tar cf copy.tar copy; cd $HERE/project/src
bk resolve -t $L $Q $HERE/copy
bk co $Q -l overlap.c
sed -e"s/222/222-left/" overlap.c > overlap.tmp
mv overlap.tmp overlap.c
bk ci $Q -y overlap.c
bk commit $S -y"abc"
bk co $Q -l overlap.c
cd $HERE/copy/src
bk co $Q -l overlap.c
sed -e "s/222/222-right/"  overlap.c > overlap.tmp
mv overlap.tmp overlap.c
bk ci $Q -y overlap.c
bk commit $S -y"abc"
bk resync $Q $HERE/project $HERE/copy
cd $HERE; tar cf copy.tar copy; cd $HERE/project/src
bk resolve -t $L $Q -a $HERE/copy 2> resolve.out
grep -q "unresolved conflicts, nothing is applied" resolve.out
if [ $? -ne 0 ]; then echo failed; cat resolve.out; exit 1; fi
echo OK
