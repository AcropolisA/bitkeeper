#!/bin/sh

# Copyright (c) 1999 Andrew Chang?
# %K%

echo $N Create initial repository ..............................$NL
HERE=`${CWD}`
echo "logging: /dev/null" > $HERE/c
echo "logging_ok: t" >>$HERE/c
bk setup -f -n'BitKeeper Test repository' -c$HERE/c project
if [ ! -d project ]; then echo failed to make top level directory; exit 1; fi
cd project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
echo OK
echo $N Create some data .......................................$NL
mkdir src
cd src
echo foo > foo.c
echo bar > bar.c
echo h > h.h
bk ci $Q -i foo.c bar.c h.h
if [ ! -f SCCS/s.foo.c ]; then echo failed to create history; exit 1; fi
echo OK
echo $N Check pending ..........................................$NL
P=`bk pending | wc -l`
if [ $P -ne 21 ]; then echo wrong pending result $P; bk pending; exit 1; fi
echo OK
echo $N Create a change set ....................................$NL
bk commit $S -f -yCset
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo failed to clear pending list; bk pending; exit 1; fi
echo OK
echo $N Create a copy of the project ...........................$NL
cd $HERE
bk resync $Q project copy
bk resolve $Q copy
if [ ! -d copy ]; then echo failed to make top level directory; exit 1; fi
cd copy
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
echo OK
echo $N Check circular rename ..................................$NL
cd $HERE/project/src
for i in a b c
do
	echo "this is $i.c" > $i.c 
	bk ci $Q -i $i.c
	${RM} -f $i.c
done
bk commit $S -yabc
cd $HERE
bk resync $Q -r1.3 $HERE/project $HERE/copy 
bk resolve $Q $HERE/copy
tar cf chkpoint.tar copy
cd $HERE/project/src
#do circular renames (clockwise rotation)
bk mv SCCS/s.c.c SCCS/s.d.c
bk mv SCCS/s.b.c SCCS/s.c.c
bk mv SCCS/s.a.c SCCS/s.b.c
bk mv SCCS/s.d.c SCCS/s.a.c
bk commit $S -yrename
bk resync -r1.4 $Q $HERE/project $HERE/copy
cd $HERE/copy
bk resolve $Q
cd $HERE/copy/src
bk get $Q a.c b.c c.c
${ECHO} "this is c.c" > ref.c 
cmp -s ref.c a.c
if [ $? -ne 0 ]; then echo "failed a"; exit 1; fi
${ECHO} "this is a.c" > ref.c 
cmp -s ref.c b.c
if [ $? -ne 0 ]; then echo "failed b"; exit 1; fi
${ECHO} "this is b.c" > ref.c 
cmp -s ref.c c.c
if [ $? -ne 0 ]; then echo "failed c"; exit 1; fi
echo OK
echo $N Check conflict within a patch ..........................$NL
cd $HERE/project/src
get $Q -e c.c
echo "this is the old c.c" > c.c 
ci $Q -y c.c
bk mv c.c d.c
echo "this is the new c.c" > c.c 
bk ci $Q -i c.c
bk commit $S -yrename
cd  $HERE
bk resync -c -r1.5 $Q $HERE/project $HERE/copy
cd  $HERE/copy/src
bk resolve $Q
bk get $Q a.c b.c c.c d.c
${ECHO} "this is c.c" > ref.c 
cmp -s ref.c a.c
if [ $? -ne 0 ]; then echo "failed"; exit 1; fi
${ECHO} "this is a.c" > ref.c 
cmp -s ref.c b.c
if [ $? -ne 0 ]; then echo "failed"; exit 1; fi
${ECHO} "this is the new c.c" > ref.c 
cmp -s ref.c c.c
if [ $? -ne 0 ]; then echo "failed"; exit 1; fi
${ECHO} "this is the old c.c" > ref.c 
cmp -s ref.c d.c
if [ $? -ne 0 ]; then echo "failed"; exit 1; fi
echo OK
echo $N Check conflict within a patch + circular rename.........$NL
cd  $HERE
rm -rf $HERE/copy
tar xf chkpoint.tar
bk resync -c -r1.4..1.5 $Q $HERE/project $HERE/copy
cd  $HERE/copy/src
bk resolve $Q
bk get $Q a.c b.c c.c d.c
$ECHO "this is c.c" > ref.c 
cmp -s ref.c a.c
if [ $? -ne 0 ]; then echo "failed"; exit 1; fi
${ECHO} "this is a.c" > ref.c 
cmp -s ref.c b.c
if [ $? -ne 0 ]; then echo "failed"; exit 1; fi
${ECHO} "this is the new c.c" > ref.c 
cmp -s ref.c c.c
if [ $? -ne 0 ]; then echo "failed"; exit 1; fi
${ECHO} "this is the old c.c" > ref.c 
cmp -s ref.c d.c
if [ $? -ne 0 ]; then echo "failed"; exit 1; fi
echo OK
echo $N Check circular rename in two work space ................$NL
cd  $HERE
rm -rf $HERE/copy
tar xf chkpoint.tar
cd  $HERE/copy/src
# $HERE/project have circular rename w/ clockwise rotation
# For $HERE/copy, we do a circular renames w/ counter clockwise rotation
bk mv SCCS/s.a.c SCCS/s.d.c
bk mv SCCS/s.b.c SCCS/s.a.c
bk mv SCCS/s.c.c SCCS/s.b.c
bk mv SCCS/s.d.c SCCS/s.c.c
bk commit $S -yrename
cd  $HERE
bk resync $Q -r1.4 $HERE/project $HERE/copy
cd  $HERE/copy/src
bk resolve $Q -f - << EOF > /dev/null
l
m
C
l
m
C
l
m
C
EOF
bk get $Q
${ECHO} "this is b.c" > ref.c 
cmp -s ref.c a.c
if [ $? -ne 0 ]; then echo "failed"; exit 1; fi
${ECHO} "this is c.c" > ref.c 
cmp -s ref.c b.c
if [ $? -ne 0 ]; then echo "failed"; exit 1; fi
${ECHO} "this is a.c" > ref.c 
cmp -s ref.c c.c
if [ $? -ne 0 ]; then echo "failed"; exit 1; fi
echo OK
echo $N Check conflict caused by merge .........................$NL
cd  $HERE
rm -rf $HERE/copy
tar xf chkpoint.tar
cd  $HERE/copy/src
# $HERE/project have circular rename w/ clockwise rotation
# For $HERE/copy, we do a circular renames w/ counter clockwise rotation
bk mv SCCS/s.a.c SCCS/s.d.c
bk mv SCCS/s.b.c SCCS/s.a.c
bk mv SCCS/s.c.c SCCS/s.b.c
bk mv SCCS/s.d.c SCCS/s.c.c
bk commit $S -yrename
cd  $HERE
bk resync -r1.4 $Q $HERE/project $HERE/copy
cd  $HERE/copy/src
bk resolve $Q -f - << EOF > /dev/null 2>&1
l
m
C
r
m
C
l
m
C
EOF
if [ $? -ne 1 ]; then echo failed; exit 1; fi
echo OK
echo $N Check name conflict caused by rename....................$NL
cd $HERE/project/src
echo "this is file gca" > g.c
ci $Q -i g.c
bk commit $S -yrename
cd  $HERE
rm -rf $HERE/copy
tar xf chkpoint.tar
bk resync $Q $HERE/project $HERE/copy
bk resolve $Q $HERE/copy
cd $HERE/copy/src
if [ ! -f SCCS/s.g.c ]; then echo failed, no g.c; fi
cd $HERE/project/src
bk mv g.c r.c
bk commit $S -yrename
cd $HERE/copy/src
bk mv g.c l.c
echo "this is file p" > p.c
ci $Q -i p.c
bk mv p.c r.c
bk commit $S -yrename
bk resync $Q $HERE/project $HERE/copy
bk resolve $Q -f - << EOF  > /dev/null 2>&1
r
m
C
EOF
if [ $? -eq 0 ]; then echo failed - fail to detect conflict; else echo OK; fi

echo $N Check resync w/ pending rename in target tree ..........$NL
cd  $HERE
rm -rf $HERE/copy
tar xf chkpoint.tar
clean $HERE/copy/src
cd $HERE/copy/src
get $Q -p a.c >ref.c
bk mv a.c e.c
bk resync $Q $HERE/project $HERE/copy 2> /dev/null
bk resolve $Q -f - << EOF > /dev/null 2>&1
l
m
C
EOF
get $Q e.c
cmp -s e.c ref.c
if [ $? -ne 0 ]; then echo failed; else echo OK; fi;

echo $N Check resync w/ pending rename in source tree ..........$NL
cd $HERE/project/src
get $Q -e a.c
bk mv a.c f.c
cd  $HERE
rm -rf $HERE/copy
tar xf chkpoint.tar
clean $HERE/copy/src
cd $HERE/copy/src
bk resync $Q $HERE/project $HERE/copy
bk resolve $Q
bk admin -z $HERE/project/src/SCCS/s.f.c $HERE/copy/src/SCCS/s.a.c
diff $HERE/project/src/SCCS/s.f.c $HERE/copy/src/SCCS/s.a.c
if [ $? -ne 0 ]; then echo failed on f.c; exit 1; fi;
bk admin -z $HERE/project/src/SCCS/s.b.c $HERE/copy/src/SCCS/s.b.c
diff $HERE/project/src/SCCS/s.b.c $HERE/copy/src/SCCS/s.b.c
if [ $? -ne 0 ]; then echo failed on b.c; exit 1; fi;
bk admin -z $HERE/project/src/SCCS/s.c.c $HERE/copy/src/SCCS/s.c.c
diff $HERE/project/src/SCCS/s.c.c $HERE/copy/src/SCCS/s.c.c
if [ $? -ne 0 ]; then echo failed on c.c; exit 1; fi;
echo OK

echo $N Key conflict in a single workspace .....................$NL
# this test is time dependent
# this colud fail on a very fast machine
echo "12" > $HERE/project/src/aa.c
bk ci $Q -i $HERE/project/src/aa.c 
bk mv $HERE/project/src/aa.c  $HERE/project/src/bb.c 
echo "21" > $HERE/project/src/aa.c
bk ci $Q -i $HERE/project/src/aa.c 
KEY1=`bk prs -hr+ -d:LONGKEY: $HERE/project/src/bb.c`
KEY2=`bk prs -hr+ -d:LONGKEY: $HERE/project/src/aa.c`
if [ "${KEY1}"X = "${KEY2}"X ]; then echo failed: duplicate key; exit 1; fi
echo OK
rm -f  $HERE/project/src/SCCS/s.aa.c  $HERE/project/src/SCCS/s.bb.c
echo $N Key conflict in two workspace ..........................$NL
# this test is time dependent
# this colud fail on a very fast machine
echo "12" > $HERE/project/src/dup.c
echo "21" > $HERE/copy/src/dup.c
bk ci $Q -i $HERE/project/src/dup.c $HERE/copy/src/dup.c
KEY1=`bk prs -hr1.0 -d:LONGKEY: $HERE/project/src/dup.c`
KEY2=`bk prs -hr1.0 -d:LONGKEY: $HERE/copy/src/dup.c`
if [ "${KEY1}"X = "${KEY2}"X ]; then echo failed: duplicate key; exit 1; fi
echo OK
rm -f $HERE/project/src/SCCS/s.dup.c $HERE/copy/src/SCCS/s.dup.c
echo $N Check resync with binary file...........................$NL
cd  $HERE
rm -rf $HERE/copy
tar xf chkpoint.tar
cd $HERE/project/src
cp $binary_data data
bk admin $Q -idata -Ebinary bdata
bk get $Q -r1.1 bdata
cmp -s bdata $binary_data
if [ $? -ne 0 ]; then echo failed; fi
bk commit $S -ybinary1
bk get $Q -e bdata
cp $binary_data2 bdata
bk ci $Q -y bdata
bk commit $S -ybinary2
bk resync $Q $HERE/project $HERE/copy
cd  $HERE/copy/src
bk resolve $Q 
bk get $Q bdata
cmp -s bdata $binary_data2
if [ $? -ne 0 ]; then echo failed; fi
bk resync $Q -r..1.8 $HERE/copy $HERE/copy2
bk resolve $Q $HERE/copy2 
cd $HERE/copy2/src 
bk get $Q bdata
cmp -s bdata $binary_data
if [ $? -ne 0 ]; then echo failed; fi
bk resync $Q -r1.9 $Q $HERE/copy $HERE/copy2
bk resolve $Q $HERE/copy2 
bk get $Q bdata
cmp -s bdata $binary_data2
if [ $? -ne 0 ]; then echo failed; else echo OK; fi
echo $N Check resync with skiped ChangeSet delta to new tree....$NL
cd $HERE
rm -rf  $HERE/copy2 
bk resync $Q -r1.5 $HERE/copy $HERE/copy2  > resync.out 2>&1
grep -q "resync from version 1.0 forward" resync.out
if [ $? -ne 0 ]; then echo failed; else echo OK; fi
echo $N Check resolve w/ merge and delete event.................$NL
cd $HERE/project/src
cat > merge.c << EOF
111
222
333
EOF
echo "To be deleted" > delete.c
bk ci $Q -i merge.c delete.c
bk commit $S -y"abc"
bk resync $Q $HERE/project $HERE/copy 
bk resolve $Q $HERE/copy
bk rm delete.c
bk co $Q -l merge.c
sed -e"s/111/111-new/" merge.c > merge.tmp
mv merge.tmp merge.c
bk ci $Q -y merge.c
bk commit $S -y"abc"
cd $HERE/copy/src
bk co $Q -l merge.c
sed -e "s/333/333-new/"  merge.c > merge.tmp
mv merge.tmp merge.c
# make sure time stamp is different
sleep 1
bk ci $Q -y merge.c
bk commit $S -y"abc"
bk resync $Q $HERE/project $HERE/copy 
bk resolve $Q -f - $HERE/copy <<EOF  > /dev/null 2>&1
m
C
EOF
if [ ! -f "SCCS/s..del-delete.c" ]; then echo faild; exit 1; fi
bk co $Q merge.c
${CAT} > merge.ref <<EOF
111-new
222
333-new
EOF
cmp -s merge.c merge.ref
if [ $? -ne 0 ]; then echo failed; diff -u merge.c merge.ref; exit 1; fi
echo OK

# TEST: Check for parallel work winds up losing a file
echo "----------- Andrew's anomaly (file disappears) -----------"
cd $HERE
rm -fr project copy
echo $N Create initial repository ..............................$NL
echo "logging: /dev/null" > $HERE/c
bk setup -f -n'BitKeeper Test repository' -c$HERE/c project
if [ ! -d project ]; then echo failed to make top level directory; exit 1; fi
cd project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
mkdir src
cd src
cat << EOF > aaa.c
1
2
3
EOF
cp aaa.c bbb.c
cp aaa.c ccc.c
bk ci $Q -i aaa.c bbb.c ccc.c
bk commit $S -f -yCset > /dev/null 2>&1
echo OK
echo $N Create a copy of the project ...........................$NL
cd $HERE
bk resync $Q project copy > /dev/null 2>&1
bk resolve $Q copy > /dev/null 2>&1
echo OK
echo $N Commit parallel work ...................................$NL
cd $HERE/project/src
for i in aaa.c bbb.c
do
        bk co $Q -l $i
        echo "this is $i" >> $i
        bk ci $Q -y $i
done
bk commit $S -yab << EOF > /dev/null 2>&1
y
EOF
# make sure the time stamp is different
sleep 1             
cd $HERE/copy/src
for i in bbb.c ccc.c
do
        bk co $Q -l $i
        sed -e"s/1/111/" $i > $i.T
        mv $i.T $i
        bk ci $Q -y $i
done
bk commit $S -ybc << EOF > /dev/null 2>&1
y
EOF
echo OK
echo $N Resync project to copy, check for no disappear .........$NL
cd $HERE
bk resync $Q project copy > /dev/null 2>&1
cd $HERE/copy
bk resolve $Q -f - << EOF > /dev/null 2>&1
m
C
EOF
bk pending | grep -q "aaa.c"
if [ $? -eq 0 ]; then echo "fail: disappeared"; exit 1; fi
echo OK


#echo XXX - need to have little tests which check each of
#echo symbols
#echo descriptive text
#echo permissions
#echo LODs
#echo per file information
