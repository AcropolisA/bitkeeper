# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Copyright (c) 1999 Larry McVoy
# %K%

# The optional datefudge line is excluded from $BASE2
BASE=40
BASE2=`expr $BASE + 70`
cat > SAVE <<EOF
Hi there, this is file foo.
Hi there, this is file foo.
Hi there, this is file foo.
Hi there, this is file foo.
Hi there, this is file foo.
Hi there, this is file foo.
Hi there, this is file foo.
Hi there, this is file foo.
Hi there, this is file foo.
EOF
no_logging project
echo $N Creating an empty file ......................................$NL
bk admin $Q -n empty
if [ $? -ne 0 ]; then echo Failed - exit code.; exit 1; fi
if [ ! -f SCCS/s.empty ]; then echo Failed.; exit 1; fi
set `wc -w SCCS/s.empty`
if [ $1 -ne $BASE ]; then echo Failed - wrong size $1 wanted $BASE.; exit 1; fi
echo OK
echo $N Creating the same file '(should fail)' ........................$NL
bk admin $Q -n empty 2> ERR
if [ $? -eq 0 ]; then echo Bad exit code 0.; exit 1; fi
echo OK
rm -f ERR
echo $N Creating a file from foo ....................................$NL
cp $HERE/SAVE foo
bk admin $Q -ifoo foo
if [ ! -f SCCS/s.foo ]; then echo Failed.; exit 1; fi
if [ ! -f foo ]; then echo Failed - gfile was removed.; exit 1; fi
set `grep -v "^.cF" SCCS/s.foo | wc -w`
if [ $1 -ne $BASE2 ]; then echo Failed - wrong size.; exit 1; fi
echo OK
echo $N Creating an empty file from /dev/null .......................$NL
bk admin $Q -i${DEV_NULL} empty2
if [ ! -f SCCS/s.empty2 ]; then echo Failed.; exit 1; fi
set `grep -v "^.cF" SCCS/s.empty2 | wc -w`
# Accomodate Sun's stupid symlink
if [ -h /dev/null ]
then	FUDGE=17
else	FUDGE=16
fi
if [ $1 -ne `expr $BASE + $FUDGE` ]; then echo Failed - wrong size.; exit 1; fi
echo OK
echo $N Creating a file from stdin ..................................$NL
bk admin $Q -i stdin < $HERE/SAVE
if [ ! -f SCCS/s.stdin ]; then echo Failed.; exit 1; fi
set `grep -v "^.cF" SCCS/s.stdin | wc -w`
if [ $1 -ne $BASE2 ]; then echo Failed - wrong size.; exit 1; fi
echo OK
cd $HERE; rm -rf project; mkdir project; cd project
echo $N Creating an empty file with rel 3.1 .........................$NL
bk admin $Q -r3.1 -n empty
if [ $? -ne 0 ]; then echo Failed - exit code.; exit 1; fi
if [ ! -f SCCS/s.empty ]; then echo Failed.; exit 1; fi
grep -q 'd D 3.1 ' SCCS/s.empty
if [ $? -ne 0 ]; then echo Failed - exit code.; exit 1; fi
echo OK

cd $HERE; rm -rf project; mkdir project; cd project
echo $N Creating an empty file with rel 1.2.3.4 .....................$NL
bk admin $Q -r1.2.3.4 -n empty
if [ $? -ne 0 ]; then echo Failed - exit code.; exit 1; fi
if [ ! -f SCCS/s.empty ]; then echo Failed.; exit 1; fi
grep -q 'd D 1.2.3.4 ' SCCS/s.empty
if [ $? -ne 0 ]; then echo Failed - exit code.; exit 1; fi
echo OK

cd $HERE; rm -rf project; mkdir project; cd project
echo $N Attempting bad create with rel 1.2.3 ........................$NL
bk admin $Q -r1.2.3 -n empty 2> ERR
if [ $? -eq 0 ]; then echo Failed - exit code.; exit 1; fi
echo OK

cd $HERE; rm -rf project; mkdir project; cd project
echo $N Attempting bad create with rel 1.2.3.4.9999 .................$NL
bk admin $Q -r1.2.3.4.9999 -n empty 2> ERR
if [ $? -eq 0 ]; then echo Failed - exit code.; exit 1; fi
echo OK

cd $HERE; rm -rf project; no_logging project
echo This is the description. > $HERE/D
echo $N Creating a file with description ............................$NL
bk admin $Q -n -t$HERE/D foo
if [ ! -f SCCS/s.foo ]; then echo Failed.; exit 1; fi
# If the second clock ticked over, we didn't need the fudge.
set `grep -v '^.cF' SCCS/s.foo | wc -w`
if [ $1 -ne `expr $BASE + 25` ]; then echo Failed - wrong size $1.; exit 1; fi
grep -q "`cat $HERE/D`" SCCS/s.foo
if [ $? -ne 0 ]; then echo Failed - exit code.; exit 1; fi
echo OK
echo $N Removing description ........................................$NL
bk admin $Q -n -t$HERE/D bar
bk admin $Q -t foo
bk admin $Q -T bar
set `grep -v "^.cF" SCCS/s.foo | wc -w`
if [ $1 -ne `expr $BASE + 38` ]; then echo Failed - wrong size $1 ; exit 1; fi
set `grep -v "^.cF" SCCS/s.bar | wc -w`
if [ $1 -ne `expr $BASE + 38` ]; then echo Failed - wrong size $1 ; exit 1; fi
echo OK
echo $N And putting it back .........................................$NL
bk admin $Q -t$HERE/D bar
set `grep -v "^.cF" SCCS/s.bar | wc -w`
if [ $1 -ne `expr $BASE + 63` ]; then echo Failed - wrong size $1.; exit 1; fi
echo OK
echo $N One last text test ..........................................$NL
bk admin $Q -n -t junk 2>ERR
if [ $? -eq 0 ]; then echo Failed.; exit 1; fi
echo OK

cd $HERE; rm -rf project; no_logging project
cp $HERE/SAVE foo
echo $N Creating a file with a comment ..............................$NL
bk admin $Q -n -y'THIS IS THE COMMENT' foo
grep -q "c THIS IS THE COMMENT" SCCS/s.foo
if [ $? -ne 0 ]; then echo Failed.; exit 1; fi
echo OK

cd $HERE; rm -rf project; mkdir project; cd project
echo $N File w/ comment, text, release ..............................$NL
bk admin $Q -n -t$HERE/D -r1.2 -y'THIS IS THE COMMENT' foo
grep -q "c THIS IS THE COMMENT" SCCS/s.foo
if [ $? -ne 0 ]; then echo Bad comment.; exit 1; fi
grep -q "`cat $HERE/D`" SCCS/s.foo
if [ $? -ne 0 ]; then echo Failed - exit code.; exit 1; fi
echo OK
echo $N Making sure that admin -r1.2 -z fails .......................$NL
bk admin $Q -r1.2 -z foo 2>ERR
if [ $? -eq 0 ]; then echo Failed - exit code.; exit 1; fi
echo OK
echo $N Adding a symbol to rev 1.2 with -S ..........................$NL
bk admin $Q -SSLOW:1.2 foo
grep -q '^.cSSLOW$' SCCS/s.foo
if [ $? -ne 0 ]; then echo Failed to add symbol.; exit 1; fi
grep -q '^.d R 1.2' SCCS/s.foo
if [ $? -ne 0 ]; then echo Failed to add symbol in meta delta.; exit 1; fi
echo OK
echo $N Adding a symbol to rev 1.2 ..................................$NL
bk admin $Q -SSYMBOL:1.2 foo
grep -q '^.cSSYMBOL$' SCCS/s.foo
if [ $? -ne 0 ]; then echo Failed.; exit 1; fi
echo OK
echo $N Check for symbol presence after delta .......................$NL
bk co $Q -l foo
bk ci $Q -fy foo
grep -q '^.cSSYMBOL$' SCCS/s.foo
if [ $? -ne 0 ]; then echo Lost symbol.; exit 1; fi
echo OK
echo $N Add same symbol to rev 1.3 ..................................$NL
bk admin $Q -SSYMBOL:1.3 foo
X=`grep -c '^.cSSYMBOL$' SCCS/s.foo`
if [ $X -ne 2 ]; then echo failed.; exit 1; fi
echo OK
echo $N Adding a symbol to rev 1.3 with -S ..........................$NL
bk admin $Q -SSLOW:1.3 foo
X=`grep -c '^.cSSLOW$' SCCS/s.foo`
if [ $X -ne 2 ]; then echo Failed.; exit 1; fi
echo OK
echo $N Adding a symbol to TOT ......................................$NL
bk admin $Q -STOT: foo
grep -q '^.cSTOT$' SCCS/s.foo
if [ $? -ne 0 ]; then echo Failed.; exit 1; fi
echo OK
echo $N Changing TOT to rev 1.2 .....................................$NL
bk admin $Q -STOT:1.2 foo
X=`grep -c '^.cSTOT$' SCCS/s.foo`
if [ $X -ne 2 ]; then echo Failed.; exit 1; fi
echo OK
echo $N Putting TOT back to TOT .....................................$NL
bk admin $Q -STOT: foo
X=`grep -c '^.cSTOT$' SCCS/s.foo`
if [ $X -ne 3 ]; then echo Failed.; exit 1; fi
echo OK
echo $N Trying symbol \'the symbol\' ..................................$NL
bk admin $Q -S'the symbol':1.2 foo
grep -q '^.cSthe symbol$' SCCS/s.foo
if [ $? -ne 0 ]; then echo Failed to add symbol properly.; exit 1; fi
bk admin -h foo 2> ERR
grep -q "checks out OK" ERR
if [ $? -ne 0 ]; then echo Failed.; exit 1; fi
echo OK
echo $N Make sure symbols get right rev .............................$NL
for i in 1 2 3
do	echo $i > syms
	if [ $i -eq 1 ]
	then	bk ci $Q -i syms; bk co $Q -l syms
	else	bk delta $Q -ly syms
	fi
done
for i in 1 2 3
do	bk admin $Q -SSYM${i}:1.$i syms
done
for i in 1 2 3
do	X=`bk get -spr1.$i syms`
	if [ $X -ne $i ]; then echo Failed on 1.$i; exit 1; fi
done
echo OK
echo $N Make sure symbols can be updated ............................$NL
n=1
for i in 1 2 3 2 1
do	bk admin $Q -SSYM:1.$i syms
	X=`grep -c '^.cSSYM$' SCCS/s.syms`
	if [ $X -ne $n ]; then echo Failed.; exit 1; fi
	n=`expr $n + 1`
	X=`bk get -spr1.$i syms`
	if [ $X -ne $i ]
	then echo Failed to get right contents in 1.$i; exit 1
	fi
done
echo OK
echo $N Make sure symbols go in once on same rev ....................$NL
echo foo > once
bk ci -iSonce $Q once
grep -q '^.cSonce$' SCCS/s.once
if [ $? -ne 0 ]; then echo Failed to add symbol.; exit 1; fi
bk admin $Q -Stwice once 2>${DEV_NULL}
grep -q '^.cStwice$' SCCS/s.once
if [ $? -ne 0 ]; then echo Failed to add symbol.; exit 1; fi
bk admin $Q -Sonce once 2>${DEV_NULL}
X=`grep -c '^.cSonce$' SCCS/s.once`
if [ $X -ne 1 ]; then echo added symbol twice.; exit 1; fi
echo OK

# "admin -h A foo" used to fail
echo $N Checking argument processing ................................$NL
date > Z
bk ci $Q -i Z
bk admin $Q -h Z foo
if [ $? -ne 0 ]; then echo Failed.; exit 1; fi
echo OK

# test a graph which has a branch merged into a branch
echo $N Check that range connect on a branch works ..................$NL

cd $HERE; rm -rf project; no_logging project
touch foo
bk ci $Q -i foo
bk co $Q -l foo
bk ci $Q -f -y1.2 foo
bk _get $Q -l -r1.1 foo
bk ci $Q -f -y1.1.1.1 foo
bk _get $Q -l -r1.1.1 foo
bk ci $Q -f -y1.1.1.2 foo
bk _get $Q -l -r1.1.1.1 foo
bk ci $Q -f -y1.1.2.1 foo
bk _get $Q -l -r1.1.1 -M1.1.2 foo
bk ci $Q -f -y1.1.1.3 foo
bk co $Q -l -M1.1.1 foo
bk ci $Q -f -y1.3 foo
bk prs -M -hd:I: -r..1.1.1.3 foo | grep -q '^1\.1$'
if [ $? -ne 0 ]; then echo Failed.; exit 1; fi
echo OK
