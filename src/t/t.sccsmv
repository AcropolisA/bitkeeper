# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Copyright (c) 1999 Larry McVoy
# %K%

no_logging project
echo $N Test sccsmv w/ p locked file ................................$NL
mkdir A B D E
echo "This is file 1" > A/file1
echo "This is file 2" > B/file2
echo "This is file 3" > A/file3
echo "This is file 4" > A/file4
echo "This is file 4" > B/file4
echo "This is file 5" > D/file5
bk ci $Q -i -l A/file1 B/file2 A/file3 A/file4 B/file4 D/file5
for i in 2 3 4
do
	echo "This is file 1, rev 1.$i" > A/file1
	echo "This is file 2, rev 1.$i" > B/file2
	echo "This is file 3, rev 1.$i" > A/file3
	echo "This is file 4, rev 1.$i" > A/file4
	echo "This is file 4, rev 1.$i" > B/file4
	echo "This is file 5, rev 1.$i" > D/file5
	bk ci $Q -yrev1.$i -l A/file1 B/file2 A/file3 A/file4 B/file4 D/file5
done
bk sfiles -l A B | bk clean -
bk co $Q -l A/file1
bk mv A/file1 B/file1
# The file should have been moved, but not checked in.
if [ ! -f B/file1 ]; then echo failed; exit 1; fi
if [ ! -f B/SCCS/s.file1 ]; then echo failed; exit 1; fi
if [ ! -f B/SCCS/p.file1 ]; then echo failed; exit 1; fi
if [ ! -f A/SCCS/s.file3 ]; then echo failed; exit 1; fi
# XXX - I think this is right but am not sure.
DPATH=`bk prs -hr1.5 -d:DPN: B/file1`
if [ ${DPATH}X != "B/file1"X ]; then echo failed; exit 1; fi
# Now check it in so later tests aren't confused.
bk ci $Q -yrename B/file1
bk -r check -a || { echo check exits $?; exit 1; }
echo OK
echo $N Test sccsmv w/ unlocked file ................................$NL
bk mv B/file2 C/file3
if [ -f C/file3 ]; then echo failed; exit 1; fi
if [ ! -f C/SCCS/s.file3 ]; then echo failed; exit 1; fi
if [ -f C/SCCS/p.file3 ]; then echo failed; exit 1; fi
DPATH=`bk prs -hr+ -d:DPN: C/file3`
if [ ${DPATH}X != "C/file3"X ]; then echo failed; exit 1; fi
DPATH=`bk prs -hr1.1 -d:DPN: C/file3`
if [ ${DPATH}X != "B/file2"X ]; then echo failed; exit 1; fi
bk -r check -a || exit 1
echo OK
echo $N Test sccsmv to directory ....................................$NL
bk mv B/file1 B/file4 C
if [ ! -f C/SCCS/s.file1 ]; then echo failed; exit 1; fi
if [ ! -f C/SCCS/s.file4 ]; then echo failed; exit 1; fi
if [ -d B ]; then echo failed; exit 1; fi
mkdir B
bk mv C/file1 C/file4 B
if [ ! -d C ]; then echo failed; exit 1; fi
bk -r check -a || exit 1
echo OK
echo $N Test bk mvdir to directory that does not exist ..............$NL
mkdir B/B1
date > B/B1/fileB1
bk new $Q B/B1/fileB1
bk mvdir B "BB BB/CCCC/DDDD"
if [ ! -f "BB BB/CCCC/DDDD/SCCS/s.file4" ]
then	echo failed to move file; exit 1
fi
if [ ! -f "BB BB/CCCC/DDDD/B1/SCCS/s.fileB1" ]
then	echo failed to move fileB1; exit 1
fi
bk -r check -a || exit 1
echo OK
echo $N And move it back ............................................$NL
bk mvdir "BB BB/CCCC/DDDD" B || { echo error; exit 1; }
if [ ! -f B/B1/SCCS/s.fileB1 ]
then	echo failed to move fileB1; exit 1
fi
echo OK
echo $N Test sccsrm w/ p locked file ................................$NL
bk get $Q -e B/file1
bk sccsrm B/file1
if [ -f B/SCCS/p..del-file1 ]; then echo failed 1; exit 1; fi
#if [ ! -f B/SCCS/s..del-file1 ]; then echo failed 2; exit 1; fi
ls B/SCCS | grep -q "^s..del-file1"
if [ $? -ne 0 ]; then echo failed 2; exit 1; fi
SFILE=`ls B/SCCS | grep "^s..del-file1"`
REV=`bk prs -hr+ -d:I: B/SCCS/$SFILE`
if [ ${REV}X != "1.10"X ]; then echo failed 3 $REV; exit 1; fi
echo OK
echo $N Test sccsrm w non p-locked file .............................$NL
bk sccsrm C/file3
if [ -f C/SCCS/p..del-file3 ]; then echo failed; exit 1; fi
#if [ ! -f C/SCCS/s..del-file3 ]; then echo failed; exit 1; fi
ls C/SCCS | grep -q "^s..del-file3"
if [ $? -ne 0 ]; then echo failed; exit 1; fi
SFILE=`ls C/SCCS | grep "^s..del-file3"`
GFILE=`bk prs -hr+ -d:GFILE: C/SCCS/$SFILE`
echo $GFILE | grep -q "^C/.del-file3"
if [ $? -ne 0 ]; then echo failed; exit 1; fi
echo OK
bk -r check -ac
echo $N Check implied file lists for rm-ed files ....................$NL
cd C
GFILE=`basename $GFILE`
bk co $Q
if [ -f $GFILE ]; then echo Failed - file was gotten; exit 1; fi
echo OK
echo $N Explicitly get a removed file ...............................$NL
bk co $Q $GFILE
if [ ! -f $GFILE ]; then echo Failed to get file; exit 1; fi
echo OK
echo $N Clean all including rm-ed file ..............................$NL
bk clean
if [ -f $GFILE ]; then echo Failed to clean file; exit 1; fi
echo OK
cd ..
echo $N Test sccsrm w/ -d option ....................................$NL
# this directory should be created by "bk setup"
mkdir -p BitKeeper/deleted/SCCS
bk clean A
bk rm A/file3
DDIR=BitKeeper/deleted
SFILE=`ls $DDIR/SCCS | grep "^s..del-file3"`
if [ ! -f $DDIR/SCCS/$SFILE ]; then echo failed; exit 1; fi
ls ${DDIR}/SCCS | grep -q "^p..del-file3"
if [ $? -eq 0 ]; then  echo failed; exit 1; fi
DPATH=`bk prs -hr+ -d:DPN: ${DDIR}/SCCS/$SFILE`
SFILE2=`bk _g2sccs $DPATH`
if [ ${SFILE2}X != "${DDIR}/SCCS/$SFILE"X ]; then echo failed; exit 1; fi
echo OK
echo $N Test sccsrm w/ -d \& p locked file ...........................$NL
bk get $Q -e A/file4
REV=`bk prs -hr+ -d:I: A/file4`
bk rm A/file4
SFILE=`ls $DDIR/SCCS | grep "^s..del-file4"`
if [ ! -f $DDIR/SCCS/$SFILE ]; then echo failed; exit 1; fi
ls ${DDIR}/SCCS | grep -q "^p..del-file3"
if [ $? -eq 0 ]; then  echo failed; exit 1; fi
REV=`bk prs -hr+ -d:I: ${DDIR}/SCCS/$SFILE`
if [ ${REV}X != "1.5"X ]; then echo failed; exit 1; fi
DPATH=`bk prs -hr+ -d:DPN: ${DDIR}/SCCS/$SFILE`
SFILE2=`bk _g2sccs $DPATH`
if [ ${SFILE2}X != "${DDIR}/SCCS/$SFILE"X ]; then echo failed; exit 1; fi
echo OK
echo $N Test sccsrm \& empty directory ...............................$NL
cd D
bk sccsrm -d file5 || { echo failed.; exit 1; }
if [ -d SCCS ]; then echo fail to remove empty SCCS; exit 1; fi
echo OK
cd ..
echo $N Test bk unrm ................................................$NL
bk unrm A/file3 > /dev/null
if [ ! -f A/SCCS/s.file3 ]; then echo failed; exit; fi
bk rm A/file3
echo OK
echo $N Test sccsmv to directory that does not exist ................$NL
date > C/file6
bk new $Q C/file6
bk mv C CCCC
if [ ! -f CCCC/SCCS/s.file6 ]
then	echo failed to move file; exit 1
fi
ls  CCCC/SCCS | grep -q "^s..del-file3"
if [ $? -ne 0 ]
then	echo failed to move deleted file; exit 1
fi
echo OK
echo $N Edit G, rm G, should create rm delta ........................$NL
date > G
bk new $Q G
cp SCCS/s.G S.G
bk edit $Q G
rm -f G
bk rm G 2> $DEV_NULL
cmp -s S.G SCCS/s..del-G
if [ $? = 0 ]; then echo Failed to add rm delta; exit 1; fi
if [ -f p.G ]; then echo Failed to rm p.G; exit 1; fi
echo OK
echo $N Test bk rmdir ...............................................$NL
date > B/B1/fileB2
bk rmdir B | grep "extra" > /dev/null
if [ $? -ne 0 ]; then echo failed; exit 1; fi
bk delta $Q -i -l B/B1/fileB2
echo new > B/B1/fileB2
bk rmdir B | grep "edited" > /dev/null
if [ $? -ne 0 ]; then echo failed; exit 1; fi
bk delta $Q -y B/B1/fileB2
bk rmdir B
if [ $? -ne 0 ]; then echo failed; exit 1; fi
if [ -d B ]; then echo failed; exit 1; fi
bk -r check -a
if [ $? -ne 0 ]; then echo failed; exit 1; fi
echo OK
echo $N Test bk rm on non bitkeeper file ............................$NL
echo hi > non_bk_file 
bk rm non_nk_file 2> rm.out
grep -q "not a BitKeeper flle, ignored" rm.out
if [ $? -ne 0 ]; then echo failed; exit 1; fi
echo OK
echo $N Test check -ag ..............................................$NL
echo y | bk commit $Q -ycset
rm -f CCCC/SCCS/s.file6
bk -r check -a 2>  ck.out
grep -q "not found"  ck.out
if [ $? -ne 0 ]; then echo failed; exit 1; fi
bk -r check -ag | bk gone -q -
bk -r check -a
if [ $? -ne 0 ]; then echo failed; exit 1; fi
echo OK
echo $N Test clones of an editted moved file ........................$NL
cd $HERE
rm -rf project
no_logging project
date > d
bk delta -i $Q d
bk commit -q -ywhatever
bk edit $Q d
date >> d
bk mv d newd
cd $HERE
# is there a better way to make clone silent when the
# check pass finds errors?
if [ "X$Q" = "X-q" ]; then
	O=' 2> /dev/null'
else
	O=
fi
eval bk clone $Q project copy $O
if [ $? -ne 0 ]; then echo failed; exit 1; fi
echo OK

echo $N Test pulls into a project with an editted moved file ........$NL
cd $HERE
rm -rf project copy
no_logging project
date > d
bk delta -i $Q d
bk commit $Q -ywhatever
cd $HERE
bk clone $Q project copy
cd project
bk edit $Q d
echo dd > d
bk delta $Q -yd d
echo ff > qqq
bk new $Q qqq
bk commit $Q -ywhat2 
cd $HERE/copy
echo ff > f
bk new $Q f
bk edit $Q f
date >> f
bk mv f newf
bk pull $Q 2> OUT
if [ $? -ne 0 ]; then
	if [ "X$Q" = "X" ]; then cat OUT; fi
	echo 'failed (bug 2001-07-09-001)'
else
    if [ ! -f SCCS/s.qqq ]; then
	    echo failed
	    exit 1
    fi
    echo OK
fi
