# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2001 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Copyright (c) 2001 Wayne Scott
# %Z%%K%

# still need to check fdiff output.

D3="-Aall -a1,2,3 -d"

commercial project

# Tests for smerge
echo $N Create initial files ........................................$NL
cat > gca <<EOF
   won't change
   won't change either
   gca1
   gca2
   gca3
   gca4
   gca5
   gca6
   gca7
   gca8
   gca9
   gca10
   won't change
   won't change
EOF
bk new $Q gca || exit 1
bk edit $Q gca || exit 1
cat > gca <<EOF
   won't change
   won't change either
   right
   right
   right
   right
   right
   right
   right
   right
   right
   right
   won't change
   won't change
EOF
bk delta $Q -yremote gca || exit 1
bk _get -e $Q -r1.1 gca || exit 1
cat > gca <<EOF
   won't change
   won't change either
   gca1
   left
   left
   gca4
   gca5
   left
   left
   gca8
   left with a very very long line, I mean a line that is much much much longer that the standard 128 byte buffer that Wayne likes to use and makes Larry want to scream!
   gca10
   won't change
   won't change
EOF
cp gca V1.1.1.1
bk delta $Q -ylocal gca || exit 1
echo OK

echo $N Check default smerge output .................................$NL
bk smerge -l1.2 -r1.1.1.1 gca > out
bk smerge $D3 -l1.2 -r1.1.1.1 gca > out.open
checkfiles out out.open
sed 's/^\\//' > out2 <<EOF
   won't change
   won't change either
\<<<<<<< gca gca 1.1
   gca1
   gca2
   gca3
   gca4
   gca5
   gca6
   gca7
   gca8
   gca9
   gca10
\<<<<<<< local gca 1.2
   right
   right
   right
   right
   right
   right
   right
   right
   right
   right
\<<<<<<< remote gca 1.1.1.1
   gca1
   left
   left
   gca4
   gca5
   left
   left
   gca8
   left with a very very long line, I mean a line that is much much much longer that the standard 128 byte buffer that Wayne likes to use and makes Larry want to scream!
   gca10
>>>>>>>
   won't change
   won't change
EOF
checkfiles out out2
rm -f gca
echo OK

echo $N Check gca smerge output .....................................$NL
#also edit file
bk edit $Q gca || exit 1
bk smerge -g -l1.2 -r1.1.1.1 gca > out
if [ $? -ne 1 ]; then echo failed; exit 1; fi
bk smerge $D3 -g -l1.2 -r1.1.1.1 gca > out.open
checkfiles out out.open
sed 's/^\\//' > out2 <<EOF
   won't change
   won't change either
\<<<<<<< local gca 1.1 vs 1.2
-   gca1
-   gca2
-   gca3
-   gca4
-   gca5
-   gca6
-   gca7
-   gca8
-   gca9
-   gca10
+   right
+   right
+   right
+   right
+   right
+   right
+   right
+   right
+   right
+   right
\<<<<<<< remote gca 1.1 vs 1.1.1.1
    gca1
-   gca2
-   gca3
+   left
+   left
    gca4
    gca5
-   gca6
-   gca7
+   left
+   left
    gca8
-   gca9
+   left with a very very long line, I mean a line that is much much much longer that the standard 128 byte buffer that Wayne likes to use and makes Larry want to scream!
    gca10
\>>>>>>>
   won't change
   won't change
EOF
checkfiles out out2
echo OK

echo $N Check 2WAY smerge output ....................................$NL
bk smerge -2 -l1.2 -r1.1.1.1 gca > out
if [ $? -ne 1 ]; then echo failed; exit 1; fi
bk smerge $D3 -2 -l1.2 -r1.1.1.1 gca > out.open
checkfiles out out.open
sed 's/^\\//' >want <<EOF
   won't change
   won't change either
\<<<<<<< local gca 1.2
   right
   right
   right
   right
   right
   right
   right
   right
   right
   right
\<<<<<<< remote gca 1.1.1.1
   gca1
   left
   left
   gca4
   gca5
   left
   left
   gca8
   left with a very very long line, I mean a line that is much much much longer that the standard 128 byte buffer that Wayne likes to use and makes Larry want to scream!
   gca10
\>>>>>>>
   won't change
   won't change
EOF
cmpfiles want out
echo OK

echo $N Check new-only smerge output ................................$NL
bk smerge -n -l1.2 -r1.1.1.1 gca > out
if [ $? -ne 1 ]; then echo failed; exit 1; fi
bk smerge $D3 -n -l1.2 -r1.1.1.1 gca > out.open
checkfiles out out.open
sed 's/^\\//' > want <<EOF
   won't change
   won't change either
\<<<<<<< local gca 1.1 vs 1.2
+   right
+   right
+   right
+   right
+   right
+   right
+   right
+   right
+   right
+   right
\<<<<<<< remote gca 1.1 vs 1.1.1.1
    gca1
+   left
+   left
    gca4
    gca5
+   left
+   left
    gca8
+   left with a very very long line, I mean a line that is much much much longer that the standard 128 byte buffer that Wayne likes to use and makes Larry want to scream!
    gca10
\>>>>>>>
   won't change
   won't change
EOF
cmpfiles want out
echo OK

echo $N Setup a set GCA baseline ....................................$NL
bk clean gca || exit 1
bk _get $Q -e -M1.1.1.1 -r1.2 gca || exit 1
cat > gca <<EOF
   won't change
   won't change either
   gca1
   left
   left
   right
   right
   left
   left
   right
   left
   gca10
   won't change
   won't change
EOF
bk delta $Q -y1.3 gca || exit 1
bk _get $Q -e -r1.2 -M1.1.1.1 gca || exit 1
cat > gca <<EOF
   won't change
   won't change either
   gca1
   right
   right
   right
   right
   left
   left
   right
   left
   right
   won't change
   won't change
EOF
bk delta $Q -y1.1.1.2 gca || exit 1
bk smerge -g -Aall -l1.2.1.1 -r1.3 gca > out
# exit 1
sed 's/^\\//' > out2 <<EOF
   won't change
   won't change either
\<<<<<<< local gca 1.1.1.1+1.2 vs 1.2.1.1
-   left
-   left
-   left
-   left
-   left with a very very long line, I mean a line that is much much much longer that the standard 128 byte buffer that Wayne likes to use and makes Larry want to scream!
-   right
-   right
-   right
-   right
+   gca1
    right
    right
    right
    right
+   left
+   left
    right
+   left
    right
\<<<<<<< remote gca 1.1.1.1+1.2 vs 1.3
+   gca1
    left
    left
-   left
-   left
-   left with a very very long line, I mean a line that is much much much longer that the standard 128 byte buffer that Wayne likes to use and makes Larry want to scream!
-   right
-   right
-   right
-   right
-   right
-   right
-   right
    right
    right
+   left
+   left
    right
+   left
+   gca10
\>>>>>>>
   won't change
   won't change
EOF
checkfiles out out2
echo OK

echo $N Check handling of bad versions ..............................$NL
bk smerge -n -l1.2 -r1.1.1.3 gca > out 2> err
if [ $? -ne 2 ]; then echo failed; exit 1; fi
grep -q 'ERROR: couldn.t find 1.1.1.3' err || exit 1
echo OK

echo $N Trying adding annotations ...................................$NL
bk smerge -gIm -l1.2 -r1.1.1.1 gca > out
if [ $? -ne 1 ]; then echo failed; exit 1; fi
bk smerge $D3 -gIm -l1.2 -r1.1.1.1 gca > out.open
checkfiles out out.open
sed 's/^\\//' > new <<EOF
1.1                   |    won't change
1.1                   |    won't change either
\<<<<<<< local gca 1.1 vs 1.2
-1.1-d1.2              |    gca1
-1.1-d1.2              |    gca2
-1.1-d1.2              |    gca3
-1.1-d1.2              |    gca4
-1.1-d1.2              |    gca5
-1.1-d1.2              |    gca6
-1.1-d1.2              |    gca7
-1.1-d1.2              |    gca8
-1.1-d1.2              |    gca9
-1.1-d1.2              |    gca10
+1.2                   |    right
+1.2                   |    right
+1.2                   |    right
+1.2                   |    right
+1.2                   |    right
+1.2                   |    right
+1.2                   |    right
+1.2                   |    right
+1.2                   |    right
+1.2                   |    right
\<<<<<<< remote gca 1.1 vs 1.1.1.1
 1.1                   |    gca1
-1.1-d1.1.1.1          |    gca2
-1.1-d1.1.1.1          |    gca3
+1.1.1.1               |    left
+1.1.1.1               |    left
 1.1                   |    gca4
 1.1                   |    gca5
-1.1-d1.1.1.1          |    gca6
-1.1-d1.1.1.1          |    gca7
+1.1.1.1               |    left
+1.1.1.1               |    left
 1.1                   |    gca8
-1.1-d1.1.1.1          |    gca9
+1.1.1.1               |    left with a very very long line, I mean a line that is much much much longer that the standard 128 byte buffer that Wayne likes to use and makes Larry want to scream!
 1.1                   |    gca10
\>>>>>>>
1.1                   |    won't change
1.1                   |    won't change
EOF
cmp -s out new
if [ $? -ne 0 ]; then echo failed; sdiff out new; exit 1; fi
echo OK

echo $N Test automerging ............................................$NL
bk unedit $Q gca || exit 1
bk _get -e $Q -r1.1 gca || exit 1
cat > gca <<EOF
   won't change much
   won't change either
   right1
   gca2
   gca3
   gca4
   right4.5
   gca5
   gca6
   gca7
   gca8
   gca9
   gca10
   won't change
   won't change
EOF
bk delta $Q -ylocal2 gca || exit 1
bk smerge -l1.1.2.1 -r1.1.1.1 gca > out
if [ $? -ne 0 ]; then echo failed; cat out; exit 1; fi
bk smerge $D3 -l1.1.2.1 -r1.1.1.1 gca > out.open
checkfiles out out.open
cat > out2 <<EOF
   won't change much
   won't change either
   right1
   left
   left
   gca4
   right4.5
   gca5
   left
   left
   gca8
   left with a very very long line, I mean a line that is much much much longer that the standard 128 byte buffer that Wayne likes to use and makes Larry want to scream!
   gca10
   won't change
   won't change
EOF
checkfiles out out2
echo OK

echo $N Verify that content merge was needed ........................$NL
bk smerge -gA3 -l1.1.2.1 -r1.1.1.1 gca > out
if [ $? -ne 1 ]; then echo failed; exit 1; fi
bk smerge $D3 -gA3 -l1.1.2.1 -r1.1.1.1 gca > out.open
checkfiles out out.open
sed 's/^\\//' > want <<EOF
   won't change much
   won't change either
\<<<<<<< local gca 1.1 vs 1.1.2.1
-   gca1
+   right1
    gca2
    gca3
\<<<<<<< remote gca 1.1 vs 1.1.1.1
    gca1
-   gca2
-   gca3
+   left
+   left
\>>>>>>>
   gca4
   right4.5
   gca5
   left
   left
   gca8
   left with a very very long line, I mean a line that is much much much longer that the standard 128 byte buffer that Wayne likes to use and makes Larry want to scream!
   gca10
   won't change
   won't change
EOF
cmpfiles want out
echo OK

#echo $N "Check versions with excludes (and identical versions)........$NL"
#bk smerge -g gca 1.1.2.1-1.1.2.1 1.1.1.1 > out
#diff -u out V1.1.1.1 > DIFF.OUT
#if [ $? -ne 0 ]; then echo failed; cat DIFF.OUT; exit 1; fi
#echo OK

echo $N "Check version argument parsing...............................$NL"
# too many versions
bk smerge -l1.1.2.1 -r1.1.1.1 gca 1 2> err && exit 1
# too few versions
bk smerge -l1.1.2.1 gca 2> err && exit 1
# bad string
#bk smerge -l1.1.2.1 -r1.1.b gca 2> err
#grep -q 'ERROR: Unable to parse version' err || exit 1
echo OK

echo $N "Check files that don't end with a newline ...................$NL"
echo $NX line without NL $NXL > bar
bk new $Q bar || exit 1
bk edit $Q bar || exit 1
echo a > bar
echo $NX line without NL $NXL >> bar
bk delta $Q -yremote bar || exit 1
bk _get -e $Q -r1.1 bar || exit 1
echo b > bar
echo $NX line without NL $NXL >> bar
cp bar bar.want
bk delta $Q -ylocal bar || exit 1
bk smerge -l1.1 -r1.1.1.1 bar > bar.out
cmp -s bar.out bar.want || { echo Failed to get correct merge; exit 1; }
bk smerge $D3 -l1.1 -r1.1.1.1 bar > bar.out.open
checkfiles bar.out bar.out.open
echo OK

echo $N Demonstrate the added_oneside hueristic .....................$NL
# Base file has some lines ending in a line which will appear again.
cat <<EOF > foo
A
B
C
last line of block matches
EOF
bk new $Q foo
bk edit $Q foo
# two edits: delete block, add something else which ends in the same line
cat $DEV_NULL > foo
bk ci $Q -l -m'foo' foo
cat <<EOF > foo
D
E
last line of block matches
EOF
bk ci $Q -m'foo' foo
# On a parallel branch ..
bk _get $Q -e -r1.1 foo
# Just edit somewhere in the middle of the original block
cat <<EOF > foo
A
B2
C
last line of block matches
EOF
bk ci $Q -m'foo' foo
# Collide the mess..
bk smerge -g -l1.3 -r1.1.1.1 foo > OUT
sed 's/^\\//' > WANT << EOF
D
E
last line of block matches
\<<<<<<< local foo 1.1 vs 1.3
-A
-B
-C
-last line of block matches
\<<<<<<< remote foo 1.1 vs 1.1.1.1
 A
-B
+B2
 C
 last line of block matches
\>>>>>>>
EOF
cmpfiles WANT OUT
echo OK

echo $N show bug with common trailing lines .........................$NL
bk smerge -g -A7 -l1.3 -r1.1.1.1 foo > OUT
sed 's/^\\//' > WANT <<EOF
\<<<<<<< local foo 1.1 vs 1.3
-A
-B
-C
+D
+E
\<<<<<<< remote foo 1.1 vs 1.1.1.1
 A
-B
+B2
 C
\>>>>>>>
last line of block matches
EOF
cmpfiles WANT OUT
echo OK

# Test a fmtool fdiff output with :-Im -f
echo $N verify an fdiff output format ...............................$NL
cat <<EOF > fdiffm
a
b
c
EOF
bk new $Q fdiffm
bk edit $Q fdiffm
cat <<EOF > fdiffm
main
b
c
main end
EOF
bk delta $Q -ynone fdiffm
bk _get $Q -e -r1.1
cat <<EOF > fdiffm
branch
b
c
branch end
EOF
bk delta $Q -ynone fdiffm
bk smerge -Im -f -l1.1 -r1.1.1.1 fdiffm > fdiffm_R
bk smerge $D3 -Im -f -l1.1 -r1.1.1.1 fdiffm > fdiffm_RD3
cat <<EOF > fdiffm_D
M
 1.1.1.1               | branch
L
 1.1                   | a
s
R
-1.1-d1.1.1.1          | a
+1.1.1.1               | branch
E
 1.1                   | b
 1.1                   | c
M
 1.1.1.1               | branch end
L
s
R
+1.1.1.1               | branch end
E
EOF
cmp -s fdiffm_R fdiffm_D || {
	echo failed
	echo difference between actual and desired:
	diff fdiffm_R fdiffm_D
	exit 1
}
cmp -s fdiffm_RD3 fdiffm_D || {
	echo failed
	echo difference between actual and desired in diff3:
	diff fdiffm_RD3 fdiffm_D
	exit 1
}
echo OK

# Test a fmtool fdiff output with :-Im -f
echo $N verify an fdiff output format with no newline at the end.....$NL
cd "$HERE/project"
cat <<EOF > nonl.txt
gca start
1
2
3
end
EOF
bk new $Q nonl.txt
bk edit $Q nonl.txt
cat <<EOF > nonl.txt
local start
1
2
3
end
EOF
bk delta $Q -ylocal nonl.txt
bk _get $Q -e -r1.1 nonl.txt
cat <<EOF > nonl.txt
remote start
1
2
3
EOF
echo $NX "end"$NXL >> nonl.txt
bk delta $Q -yremote nonl.txt
bk smerge -Im -f -l1.1.1.1 -r1.2 nonl.txt > nonl_R
cat <<EOF >nonl_D
L
-1.1-d1.1.1.1          | gca start
h 0-3
+1.1.1.1               | remote start
h 0-6
s
R
-1.1-d1.2              | gca start
h 0-3
s
+1.2                   | local start
h 0-5
E
 1.1                   | 1
 1.1                   | 2
 1.1                   | 3
M
 1.1.1.1               | end
L
-1.1-d1.1.1.1          | end
h 3-4
+1.1.1.1               | end
R
 1.1                   | end
s
E
EOF
checkfiles nonl_R nonl_D
sed 's/^\\//' <<EOF >nonl_D
\<<<<<<< local nonl.txt 1.1 vs 1.1.1.1
-gca start
+remote start
\<<<<<<< remote nonl.txt 1.1 vs 1.2
-gca start
+local start
\>>>>>>>
1
2
3
EOF
bk smerge -g -l1.1.1.1 -r1.2 nonl.txt > GOT
cp nonl_D WANT
echo $NX "end"$NXL >>WANT
checkfiles GOT WANT
bk smerge -g -Aall -l1.1.1.1 -r1.2 nonl.txt > GOT
cp nonl_D WANT
sed 's/^\\//' <<EOF >>WANT
\<<<<<<< local nonl.txt 1.1 vs 1.1.1.1
-end
+end
\>>>>>>>
EOF
checkfiles GOT WANT
echo OK

echo $N failures involving a disappearing newline in a merge ........$NL
cd "$HERE"
rm -rf project
commercial project
# Make something which ends without a newline.
printf "a\nb\nc" > foo
bk new $Q foo
bk commit $Q -yfoo foo
cd ..
bk clone $Q project copy
# put something after it.  First change will remove the 'c' line
# and replace it with 'c\n'.  Second change will append a block.
# Third change will remove the first change, restoring the sequence
# number for 'c', but since a token appears after it, will show up
# as 'c\n'.  Same token, different lenghth
cd project
bk edit $Q foo
printf "a\nb\nc\nd\n" > foo
bk delta $Q -yfoo foo
REV=`bk log -r+ -nd:I: foo`
bk edit $Q foo
printf "a\nb\nc\nd\ne\n" > foo
bk delta $Q -yfoo foo
bk edit $Q -x$REV foo
bk delta $Q -yfoo foo
bk commit $Q -yfoo foo
# create a conflict area that includes the 'c' token
cd ../copy
bk edit $Q foo
printf "a\nq\nk\nm\nv\n" > foo
bk delta $Q -yfoo foo
bk commit $Q -yfoo
printf "ul\n.\n" | bk pull $Q 2> ERR || {
	echo failed
	cat ERR
	exit 1
}
echo OK
