# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

if [ X$PLATFORM = X"WIN32" ]
then
        # It is unlikely in that ssh/rsh to localhost will work on NT.
        # We let the user tell us otherwise.
        if [ -z "$DO_REMOTE" ]; then DO_REMOTE=NO; fi
else
	if [ -z "$DO_REMOTE" ]; then DO_REMOTE=YES; fi
fi

# Tests for tag propogation in new/old protocols.
echo $N Create initial repository ...................................$NL
no_logging project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
mkdir src
cd src
echo foo > 'F!O#O$ B%A^R&RR(R)RR'
echo bar > bar.c
echo h > h.h
bk ci $Q -i 'F!O#O$ B%A^R&RR(R)RR' bar.c h.h
if [ ! -f SCCS/s.'F!O#O$ B%A^R&RR(R)RR' ]; then echo failed to create history; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 15 ]; then echo wrong pending result $P; bk pending; exit 1; fi
bk commit $S -a -yCset
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo failed to clear pending list; bk pending; exit 1; fi
echo OK
cores
echo $N Add old style tags ..........................................$NL
cd $HERE
cp -rp project tags
cd tags
_BK_NO_TAG_GRAPH=YES bk tag $Q OLD
grep -q '^.cS l' SCCS/s.ChangeSet && {
	echo added a leaf
	cat SCCS/s.ChangeSet
	exit 1
}
grep -q '^.cS[0-9]' SCCS/s.ChangeSet && {
	echo added a tag graph node
	cat SCCS/s.ChangeSet
	exit 1
}
bk admin -hhhq || exit 1
echo OK
echo $N Add new style tags ..........................................$NL
bk tag $Q NEW
grep -q '^.cS0' SCCS/s.ChangeSet || {
	echo did not add tag pointing to the root node
	cat SCCS/s.ChangeSet
	exit 1
}
bk tag $Q 'NEW TAG'
grep -q '^.cS0' SCCS/s.ChangeSet || {
	echo lost tag pointing to the root node
	cat SCCS/s.ChangeSet
	exit 1
}
grep -q '^.cS5 l' SCCS/s.ChangeSet || {
	echo Did not add tag pointing to previous tag
	cat SCCS/s.ChangeSet
	exit 1
}
cp SCCS/s.ChangeSet SAVE
bk admin -z ChangeSet
cmp -s SCCS/s.ChangeSet SAVE || {
	echo admin -z stomped on tags
	diff SCCS/s.ChangeSet SAVE
	exit 1
}
bk admin -hhhq || exit 1
echo OK
echo $N Clone repository ............................................$NL
cd $HERE
bk clone $Q $HERE/project $HERE/copy || { echo failed; exit 1; }
bk clone $Q $HERE/project $HERE/copy2 || { echo failed; exit 1; }
bk clone $Q $HERE/project $HERE/copy3 || { echo failed; exit 1; }
[ -f copy/src/SCCS/s.'F!O#O$ B%A^R&RR(R)RR' ] || { echo failed; exit 1; }
[ -f copy/BitKeeper/log/parent ] || { echo no parent; exit 1; }
parent=`cat copy/BitKeeper/log/parent`
host=`bk gethost`
[ x$parent = x${host}:$HERE/project ] || { echo wrong parent $parent; exit 1; }
cd $HERE/project; checkLocks; cd $HERE/copy; checkLocks
echo OK
echo $N Create a changeset in compat mode with a tag ................$NL
cd $HERE/project/src
bk get $Q -e 'F!O#O$ B%A^R&RR(R)RR'
echo delta two >> 'F!O#O$ B%A^R&RR(R)RR'
bk delta $Q -ywhatever 'F!O#O$ B%A^R&RR(R)RR'
_BK_NO_TAG_GRAPH=YES bk commit $Q -yopull_cset -S'NOT IN TAG GRAPH'
cd ..
grep -q '^.cS[0-9]' SCCS/s.ChangeSet && {
	echo added a tag graph node
	cat SCCS/s.ChangeSet
	exit 1
}
bk admin -hhhq || exit 1
bk admin -z
grep -q '^.cS[0-9]' SCCS/s.ChangeSet && {
	echo added a tag graph node after the admin -z
	cat SCCS/s.ChangeSet
	exit 1
}
echo OK
echo $N Pull a new changeset with an old tag using opull ............$NL
cd $HERE/copy
cp SCCS/s.ChangeSet CSET
bk opull -t $Q || { echo failed; exit 1; }
revs=`bk prs -hd':I:\n' src/'F!O#O$ B%A^R&RR(R)RR' | wc -l`
[ $revs -eq 2 ] || { echo failed; exit 1; }
grep -q '^.cS[0-9]' SCCS/s.ChangeSet && {
	echo added a tag graph node
	bk difftool CSET SCCS/s.ChangeSet
	exit 1
}
bk admin -hhhq || exit 1
echo OK
echo $N Pull a new changeset with an old tag using pull .............$NL
cd $HERE/copy2
bk pull -t $Q || { echo failed; exit 1; }
revs=`bk prs -hd':I:\n' src/'F!O#O$ B%A^R&RR(R)RR' | wc -l`
[ $revs -eq 2 ] || { echo failed; exit 1; }
grep -q 'NOT IN TAG' SCCS/s.ChangeSet || { echo did not propogate tag; exit 1; }
bk admin -hhhq || exit 1
echo OK

echo $N Resolve a tag conflict, pick remote, see if it sticks .......$NL
cd $HERE
rm -rf project copy
no_logging project
echo hi > foo
bk new $Q foo
bk commit -yDsub1 $Q
cd $HERE
bk clone $Q project copy
cd $HERE/project
echo hi > bar
bk new $Q bar
bk commit -yDsub2 -STAG $Q
REMOTE=`bk prs -hrTAG -d:KEY: ChangeSet`
cd $HERE/copy
echo hi > snafu
bk new $Q snafu
bk commit -yDsub3 -STAG $Q
LOCAL=`bk prs -hrTAG -d:KEY: ChangeSet`
cp SCCS/s.ChangeSet CSET
bk resync $Q
(
echo ""
echo "x"
echo r
) | bk resolve -t $Q 2>OUT
KEY=`bk prs -hrTAG -d:KEY: ChangeSet`
if [ "$KEY" = "$LOCAL" ]
then	echo Whoops, used local instead of remote
	echo "REMOTE:	$REMOTE"
	echo "LOCAL:	$LOCAL"
	bk prs -d':I: :KEY:\n' ChangeSet
	cat OUT
	exit 1
fi
if [ "$KEY" != "$REMOTE" ]
then	echo Whoops, it is not remote and is not local
	echo "REMOTE:	$REMOTE"
	echo "LOCAL:	$LOCAL"
	echo "KEY:	$KEY"
	bk prs -d':I: :KEY:\n' ChangeSet
	exit 1
fi
echo OK

echo $N Undo after the unchoosen rev, merge should be gone ..........$NL
bk undo $Q -fa1.2.1.1
KEY=`bk prs -hrTAG -d:KEY: ChangeSet`
if [ "$KEY" != "$LOCAL" ]
then	echo Whoops, key is not restored
	echo "LOCAL:	$LOCAL"
	bk prs -d':I: :KEY:\n' ChangeSet
	exit 1
fi
echo OK

echo $N Pull again, choose local, see if it sticks ..................$NL
bk resync $Q
(
echo l
) | bk resolve -t $Q 2>OUT
KEY=`bk prs -hrTAG -d:KEY: ChangeSet`
if [ "$KEY" = "$REMOTE" ]
then	echo Whoops, used remote instead of local
	echo "REMOTE:	$REMOTE"
	echo "LOCAL:	$LOCAL"
	bk prs -d':I: :KEY:\n' ChangeSet
	exit 1
fi
if [ "$KEY" != "$LOCAL" ]
then	echo Whoops, it is not local and is not remote
	echo "REMOTE:	$REMOTE"
	echo "LOCAL:	$LOCAL"
	echo "KEY:	$KEY"
	bk prs -d':I: :KEY:\n' ChangeSet
	exit 1
fi
echo OK

# We depend on tags added after the cset is created to have a 0 cksum so
# we can distinguish them from a cset.
# XXX - what if the cset is legitmately == 0?  I suppose we get the count
# wrong at that point.
echo $N Make sure that tag chksum == 0 ..............................$NL
cd $HERE/project
bk tag $Q project
CHKSUM=`bk prs -had'$if(:DT:=R){:DSUM:}' ChangeSet`
if [ "$CHKSUM" -ne 0 ]
then	echo failed, CHKSUM = $CHKSUM
	bk prs -ad':I: :DT: :DSUM: :KEY:\n' ChangeSet
	exit 1
fi
echo OK

echo $N Create a tag only conflict, push, check error message .......$NL
cd $HERE/copy
bk tag $Q copy
bk push 2>OUT
if [ $? -eq 0 ]
then	echo failed to exit non zero;
	cat OUT
	exit 1
fi
grep -q '1 tags only in' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK

test -d /usr/libexec/bitkeeper-1.2 || exit 0

echo $N Create a 1.x style tree and copies of it ....................$NL
cd $HERE
rm -rf c* p* t*
SAVE=$PATH
PATH=/usr/libexec/bitkeeper-1.2:$PATH
no_logging old
PATH=$SAVE
cd $HERE
bk clone $Q old new
tar cf TAR new old
cd new
bk admin -qhhh ChangeSet || { bk admin -hhh ChangeSet; exit 1; }
P=50000
bk bkd -d -p$P -P$HERE/pid 2>/dev/null
while [ $? -eq 2 ]
do      P=`expr $P + 1`
	bk bkd -d -p$P -P$HERE/pid 2>/dev/null
done
echo OK

echo $N Create a new changeset with an old tag, 1.x pull it, works ..$NL
cd $HERE/new
ls > LS
bk new $Q LS
_BK_NO_TAG_GRAPH=YES bk commit $Q -ycset1 -S'OLD STYLE'
grep -q 'cS0' SCCS/s.ChangeSet && { echo added new tag; exit 1; }
cd $HERE/old
/usr/libexec/bitkeeper-1.2/bk pull -t $Q bk://localhost:$P || exit 1
grep -q 'OLD STYLE' SCCS/s.ChangeSet || { echo no tag; exit 1; }
grep -q '^.cV4' SCCS/s.ChangeSet && { echo propogated version; exit 1; }
echo OK

echo $N Create a new changeset with an new tag, 1.x pull it, no tag .$NL
cd $HERE/new
ls > XYZ
bk new $Q XYZ
bk commit $Q -ycset1 -S'NEW TAG'
grep -q 'cS0' SCCS/s.ChangeSet || { echo No tag graph found; exit 1; }
KEY=`bk prs -hr+ -d:KEY: ChangeSet`
cd $HERE/old
/usr/libexec/bitkeeper-1.2/bk pull -t $Q bk://localhost:$P || exit 1
grep -q 'NEW TAG' SCCS/s.ChangeSet && { echo tag was sent; exit 1; }
grep -q '^.cV4' SCCS/s.ChangeSet && { echo propogated version; exit 1; }
GOT=`bk prs -hr+ -d:KEY: ChangeSet`
if [ X"$KEY" != X"$GOT" ]
then	echo "KEY $KEY"
	echo "GOT $GOT"
	exit 1
fi
echo OK

echo $N Create a new changeset with an old tag, opull it, works .....$NL
cd $HERE
rm -rf new old
tar xf TAR
kill -9 `cat $HERE/pid`
cd new
P=50000
bk bkd -d -p$P -P$HERE/pid 2>/dev/null
while [ $? -eq 2 ]
do      P=`expr $P + 1`
	bk bkd -d -p$P -P$HERE/pid 2>/dev/null
done
cd $HERE/new
ls > LS
bk new $Q LS
_BK_NO_TAG_GRAPH=YES bk commit $Q -ycset1 -S'OLD STYLE'
grep -q 'cS0' SCCS/s.ChangeSet && { echo added new tag; exit 1; }
cd $HERE/old
bk idcache -q
bk opull -t $Q bk://localhost:$P || exit 1
grep -q 'OLD STYLE' SCCS/s.ChangeSet || { echo no tag; exit 1; }
# The following test is if and only if we maintain the old file version #.
# grep -q '^.cV4' SCCS/s.ChangeSet && { echo propogated version; exit 1; }
echo OK

echo $N Create a new changeset with an new tag, opull it, no tag ....$NL
cd $HERE/new
ls > XYZ
bk new $Q XYZ
bk commit $Q -ycset1 -S'NEW TAG'
grep -q 'cS0' SCCS/s.ChangeSet || { echo No tag graph found; exit 1; }
KEY=`bk prs -hr+ -d:KEY: ChangeSet`
cd $HERE/old
bk opull -t $Q bk://localhost:$P || exit 1
grep -q 'NEW TAG' SCCS/s.ChangeSet && { echo tag was sent; exit 1; }
# The following test is if and only if we maintain the old file version #.
# grep -q '^.cV4' SCCS/s.ChangeSet && { echo propogated version; exit 1; }
GOT=`bk prs -hr+ -d:KEY: ChangeSet`
if [ X"$KEY" != X"$GOT" ]
then	echo "KEY $KEY"
	echo "GOT $GOT"
	exit 1
fi
echo OK

echo $N Test 1.x push from old to new with old style tag ............$NL
cd $HERE
rm -rf new old
tar xf TAR
kill -9 `cat $HERE/pid`
cd new
P=50000
bk bkd -d -p$P -P$HERE/pid 2>/dev/null
while [ $? -eq 2 ]
do      P=`expr $P + 1`
	bk bkd -d -p$P -P$HERE/pid 2>/dev/null
done
cd $HERE/old
ls > LS
/usr/libexec/bitkeeper-1.2/bk new $Q LS
/usr/libexec/bitkeeper-1.2/bk commit $Q -ycset1 -S'OLD STYLE'
KEY=`bk prs -hr+ -d:KEY: ChangeSet`
/usr/libexec/bitkeeper-1.2/bk push -t $Q bk://localhost:$P || exit 1
cd $HERE/new
grep -q 'OLD STYLE' SCCS/s.ChangeSet || { echo no tag; exit 1; }
GOT=`bk prs -hr+ -d:KEY: ChangeSet`
if [ X"$KEY" != X"$GOT" ]
then	echo "KEY $KEY"
	echo "GOT $GOT"
	exit 1
fi
echo OK

echo $N Test 2.x opush from old to old server with old tag ..........$NL
cd $HERE
rm -rf new old
tar xf TAR
mv new older
kill -9 `cat $HERE/pid`
cd older
P=50000
/usr/libexec/bitkeeper-1.2/bk bkd -d -p$P -P$HERE/pid 2>/dev/null
while [ $? -eq 2 ]
do      P=`expr $P + 1`
	/usr/libexec/bitkeeper-1.2/bk bkd -d -p$P -P$HERE/pid 2>/dev/null
done
cd $HERE/old
ls > LS
/usr/libexec/bitkeeper-1.2/bk new $Q LS
/usr/libexec/bitkeeper-1.2/bk commit $Q -ycset1 -S'OLD STYLE'
KEY=`/usr/libexec/bitkeeper-1.2/bk prs -hr+ -d:KEY: ChangeSet`
bk idcache -q
bk opush -t $Q bk://localhost:$P || exit 1
cd $HERE/older
grep -q 'OLD STYLE' SCCS/s.ChangeSet || { echo no tag; exit 1; }
GOT=`bk prs -hr+ -d:KEY: ChangeSet`
if [ X"$KEY" != X"$GOT" ]
then	echo "KEY $KEY"
	echo "GOT $GOT"
	exit 1
fi
echo OK

echo $N Test 2.x opush from new to old server with old tag ..........$NL
cd $HERE
rm -rf new old
tar xf TAR
kill -9 `cat $HERE/pid`
cd old
P=50000
/usr/libexec/bitkeeper-1.2/bk bkd -d -p$P -P$HERE/pid 2>/dev/null
while [ $? -eq 2 ]
do      P=`expr $P + 1`
	/usr/libexec/bitkeeper-1.2/bk bkd -d -p$P -P$HERE/pid 2>/dev/null
done
cd $HERE/new
bk idcache -q
ls > LS
bk new $Q LS
bk commit $Q -ycset1
_BK_NO_TAG_GRAPH=YES bk tag -q 'OLD OLD'
KEY=`bk prs -hr+ -d:KEY: ChangeSet`
bk opush -t $Q bk://localhost:$P 2>OUT || exit 1
cat OUT
cores
cd $HERE/old
grep -q 'NEW NEW' SCCS/s.ChangeSet && { echo sent new tag; exit 1; }
#xterm -n OLD -geom +1+1 -e vi SCCS/s.ChangeSet &
grep -q 'OLD OLD' SCCS/s.ChangeSet || { echo did not send old tag; exit 1; }
GOT=`bk prs -hr+ -d:KEY: ChangeSet`
if [ X"$KEY" != X"$GOT" ]
then	echo "KEY $KEY"
	echo "GOT $GOT"
	exit 1
fi
grep -q '^.cV4' SCCS/s.LS && { echo propogated version in LS; exit 1; }
grep -q '^.cV4' SCCS/s.ChangeSet && { echo propogated version in Cset; exit 1; }
echo OK

echo $N Test 2.x opush from new to old with both new and old tag ....$NL
cd $HERE
rm -rf new old
tar xf TAR
kill -9 `cat $HERE/pid`
cd old
P=50000
/usr/libexec/bitkeeper-1.2/bk bkd -d -p$P -P$HERE/pid 2>/dev/null
while [ $? -eq 2 ]
do      P=`expr $P + 1`
	/usr/libexec/bitkeeper-1.2/bk bkd -d -p$P -P$HERE/pid 2>/dev/null
done
cd $HERE/new
bk idcache -q
ls > LS
bk new $Q LS
bk commit $Q -ycset1 -S'NEW NEW'
bk commit $Q -ycset1 -SNEWBIE
_BK_NO_TAG_GRAPH=YES bk tag -q 'OLD OLD'
_BK_NO_TAG_GRAPH=YES bk tag -q 'OLDY'
KEY=`bk prs -hr+ -d:KEY: ChangeSet`
BK_GETLINE=YES bk opush -t $Q bk://localhost:$P 2>OUT || exit 1
grep -q 'not sending new tags in compat mode' OUT || {
	echo failed to warn about compat mode tags
	cat OUT
	exit 1
}
cores
cd $HERE/old
grep -q 'NEW NEW' SCCS/s.ChangeSet && { echo sent new tag; exit 1; }
grep -q 'NEWBIE' SCCS/s.ChangeSet && { echo sent new tag; exit 1; }
grep -q 'OLD OLD' SCCS/s.ChangeSet || { echo did not send old tag; exit 1; }
grep -q 'OLDY' SCCS/s.ChangeSet || { echo did not send old tag; exit 1; }
GOT=`bk prs -hr+ -d:KEY: ChangeSet`
if [ X"$KEY" != X"$GOT" ]
then	echo "KEY $KEY"
	echo "GOT $GOT"
	exit 1
fi
grep -q '^.cV4' SCCS/s.LS && { echo propogated version in LS; exit 1; }
grep -q '^.cV4' SCCS/s.ChangeSet && { echo propogated version in Cset; exit 1; }
echo OK

kill -9 `cat $HERE/pid`

#echo $N Create the same tag in a new place ..........................$NL
#cd $HERE/copy/src
#bk get $Q -e 'F!O#O$ B%A^R&RR(R)RR'
#echo delta two >> 'F!O#O$ B%A^R&RR(R)RR'
#bk delta $Q -yopush_cset 'F!O#O$ B%A^R&RR(R)RR'
#bk commit $Q -yopush_cset -STAG2
#echo OK
