# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

if [ X$PLATFORM = X"WIN32" ]
then
        # It is unlikely in that ssh/rsh to localhost will work on NT.
        # We let the user tell us otherwise.
        if [ -z "$DO_REMOTE" ]; then DO_REMOTE=NO; fi
else
	if [ -z "$DO_REMOTE" ]; then DO_REMOTE=YES; fi
fi

# Tests for tag propogation in new/old protocols.
echo $N Create initial repository ...................................$NL
no_logging project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
mkdir src
cd src
echo foo > 'F!O#O$ B%A^R&RR(R)RR'
echo bar > bar.c
echo h > h.h
bk ci $Q -i 'F!O#O$ B%A^R&RR(R)RR' bar.c h.h
if [ ! -f SCCS/s.'F!O#O$ B%A^R&RR(R)RR' ]; then echo failed to create history; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 15 ]; then echo wrong pending result $P; bk pending; exit 1; fi
bk commit $S -a -yCset
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo failed to clear pending list; bk pending; exit 1; fi
echo OK
cores
echo $N Clone repository ............................................$NL
cd $HERE
bk clone $Q $HERE/project $HERE/copy || { echo failed; exit 1; }
bk clone $Q $HERE/project $HERE/copy2 || { echo failed; exit 1; }
[ -f copy/src/SCCS/s.'F!O#O$ B%A^R&RR(R)RR' ] || { echo failed; exit 1; }
[ -f copy/BitKeeper/log/parent ] || { echo no parent; exit 1; }
parent=`cat copy/BitKeeper/log/parent`
host=`bk gethost`
[ x$parent = x${host}:$HERE/project ] || { echo wrong parent $parent; exit 1; }
cd $HERE/project; checkLocks; cd $HERE/copy; checkLocks
echo OK
echo $N Pull a new changeset with a tag using opull .................$NL
cd $HERE/project/src
bk get $Q -e 'F!O#O$ B%A^R&RR(R)RR'
echo delta two >> 'F!O#O$ B%A^R&RR(R)RR'
bk delta $Q -ywhatever 'F!O#O$ B%A^R&RR(R)RR'
bk commit $Q -yopull_cset -STAG1
cd $HERE/copy
bk opull -t $Q || { echo failed; exit 1; }
revs=`bk prs -hd':I:\n' src/'F!O#O$ B%A^R&RR(R)RR' | wc -l`
[ $revs -eq 2 ] || { echo failed; exit 1; }
grep -q TAG1 SCCS/s.ChangeSet && { echo propogated tag; exit 1; }
cd $HERE/project; checkLocks; cd $HERE/copy; checkLocks
echo OK
echo $N Pull a new changeset with a tag using pull ..................$NL
cd $HERE/copy2
bk pull -t $Q || { echo failed; exit 1; }
revs=`bk prs -hd':I:\n' src/'F!O#O$ B%A^R&RR(R)RR' | wc -l`
[ $revs -eq 2 ] || { echo failed; exit 1; }
grep -q TAG1 SCCS/s.ChangeSet || { echo did not propogate tag; exit 1; }
cd $HERE/project; checkLocks; cd $HERE/copy; checkLocks
echo OK
echo $N Push a new changeset created with a tag using opush .........$NL
cd $HERE
tar cf P.tar project
cd $HERE/copy/src
bk get $Q -e 'F!O#O$ B%A^R&RR(R)RR'
echo delta two >> 'F!O#O$ B%A^R&RR(R)RR'
bk delta $Q -yopush_cset 'F!O#O$ B%A^R&RR(R)RR'
bk commit $Q -yopush_cset -STAG2
_BK_FORCE_COMPAT=YES bk opush -t > OUT 2>&1
grep -q 'will not accept tags in compatibility mode' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK

echo $N Resolve a tag conflict, pick remote, see if it sticks .......$NL
cd $HERE
rm -rf project copy
no_logging project
echo hi > foo
bk new $Q foo
bk commit -yDsub1 $Q
cd $HERE
bk clone $Q project copy
cd $HERE/project
echo hi > bar
bk new $Q bar
bk commit -yDsub2 -STAG $Q
REMOTE=`bk prs -hrTAG -d:KEY: ChangeSet`
cd $HERE/copy
echo hi > snafu
bk new $Q snafu
bk commit -yDsub3 -STAG $Q
LOCAL=`bk prs -hrTAG -d:KEY: ChangeSet`
cp SCCS/s.ChangeSet CSET
bk resync $Q
(
echo r
) | bk resolve -t $Q 2>OUT
KEY=`bk prs -hrTAG -d:KEY: ChangeSet`
if [ "$KEY" = "$LOCAL" ]
then	echo Whoops, used local instead of remote
	echo "REMOTE:	$REMOTE"
	echo "LOCAL:	$LOCAL"
	bk prs -d':I: :KEY:\n' ChangeSet
	exit 1
fi
if [ "$KEY" != "$REMOTE" ]
then	echo Whoops, it is not remote and is not local
	echo "REMOTE:	$REMOTE"
	echo "LOCAL:	$LOCAL"
	echo "KEY:	$KEY"
	bk prs -d':I: :KEY:\n' ChangeSet
	exit 1
fi
echo OK

echo $N Undo after the unchoosen rev, merge should be gone ..........$NL
bk undo $Q -fa1.2.1.1
KEY=`bk prs -hrTAG -d:KEY: ChangeSet`
if [ "$KEY" != "$LOCAL" ]
then	echo Whoops, key is not restored
	echo "LOCAL:	$LOCAL"
	bk prs -d':I: :KEY:\n' ChangeSet
	exit 1
fi
echo OK

echo $N Pull again, choose local, see if it sticks ..................$NL
bk resync $Q
(
echo l
) | bk resolve -t $Q 2>OUT
KEY=`bk prs -hrTAG -d:KEY: ChangeSet`
if [ "$KEY" = "$REMOTE" ]
then	echo Whoops, used remote instead of local
	echo "REMOTE:	$REMOTE"
	echo "LOCAL:	$LOCAL"
	bk prs -d':I: :KEY:\n' ChangeSet
	exit 1
fi
if [ "$KEY" != "$LOCAL" ]
then	echo Whoops, it is not local and is not remote
	echo "REMOTE:	$REMOTE"
	echo "LOCAL:	$LOCAL"
	echo "KEY:	$KEY"
	bk prs -d':I: :KEY:\n' ChangeSet
	exit 1
fi
echo OK

# We depend on tags added after the cset is created to have a 0 cksum so
# we can distinguish them from a cset.
# XXX - what if the cset is legitmately == 0?  I suppose we get the count
# wrong at that point.
echo $N Make sure that tag chksum == 0 ..............................$NL
cd $HERE/project
bk tag $Q project
CHKSUM=`bk prs -had'$if(:DT:=R){:DSUM:}' ChangeSet`
if [ "$CHKSUM" -ne 0 ]
then	echo failed, CHKSUM = $CHKSUM
	bk prs -ad':I: :DT: :DSUM: :KEY:\n' ChangeSet
	exit 1
fi
echo OK

echo $N Create a tag only conflict, push, check error message .......$NL
cd $HERE/copy
bk tag $Q copy
bk push 2>OUT
if [ $? -eq 0 ]
then	echo failed to exit non zero;
	cat OUT
	exit 1
fi
grep -q '1 tags only in' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK

test -d /usr/libexec/bitkeeper-1.2 && {
    echo $N Create a bk 1.2.9 tree, update w/ current, pull w/ old ......$NL
    cd $HERE
    rm -rf project copy
    SAVE=$PATH
    PATH=/usr/libexec/bitkeeper-1.2:$PATH
    no_logging project
    PATH=$SAVE
    P=50000
    bk bkd -d -p$P -P$HERE/pid 2>/dev/null
    while [ $? -eq 2 ]
    do      P=`expr $P + 1`
	    bk bkd -d -p$P -P$HERE/pid 2>/dev/null
    done
    cd ..
    bk clone $Q bk://localhost:$P copy
    cd project
    ls > LS
    bk new $Q LS
    bk idcache -q
    bk commit $Q -ycset1 -STAG1
    grep -q '^.cV4' SCCS/s.ChangeSet || {
    	echo bad version in the Changeset, maybe we have bumped it again
	exit 1
    }
    cd $HERE/copy
    /usr/libexec/bitkeeper-1.2/bk pull -t $Q bk://localhost:$P || exit 1
    grep -q TAG1 SCCS/s.ChangeSet && { echo propogated tag; exit 1; }
    grep -q '^.cV4' SCCS/s.ChangeSet && { echo propogated version; exit 1; }
    echo OK

    echo $N Push a new changeset created using 1.2.9 ....................$NL
    ls > AAA
    /usr/libexec/bitkeeper-1.2/bk new $Q AAA
    /usr/libexec/bitkeeper-1.2/bk commit $Q -yAAA
    /usr/libexec/bitkeeper-1.2/bk push -t $Q || exit 1
    cd $HERE/project
    grep -q 'c AAA' SCCS/s.ChangeSet || { echo failed to push; exit 1; }
    echo OK

    echo $N Tag a cset and push with 1.2.9 client, should fail ..........$NL
    cd $HERE/copy
    ls > BBB
    /usr/libexec/bitkeeper-1.2/bk new $Q BBB
    /usr/libexec/bitkeeper-1.2/bk commit $Q -ycset1 -STAG2
    /usr/libexec/bitkeeper-1.2/bk push -t bk://localhost:$P > OUT 2>&1
    grep -q 'will not accept tags in compatibility mode' OUT || {
	    echo bad error message
	    cat OUT
	    exit 1
    }
    cd $HERE/project
    grep -q TAG2 SCCS/s.ChangeSet && { echo propogated tag; exit 1; }
    echo OK
    
    echo $N Create a new changeset, then try old code, should fail ......$NL
    cd $HERE/copy
    ls > LS2
    bk new $Q LS2
    bk idcache -q
    bk commit $Q -yNEW
    /usr/libexec/bitkeeper-1.2/bk push -t > OUT 2>&1
    grep -q 'will not accept tags in compatibility mode' OUT || {
	    echo bad error message
	    cat OUT
	    exit 1
    }
    cd $HERE/project
    grep -q TAG2 SCCS/s.ChangeSet && { echo propogated tag; exit 1; }
    echo OK
    kill -9 `cat $HERE/pid`
}
exit 0
#echo $N Create the same tag in a new place ..........................$NL
#cd $HERE/copy/src
#bk get $Q -e 'F!O#O$ B%A^R&RR(R)RR'
#echo delta two >> 'F!O#O$ B%A^R&RR(R)RR'
#bk delta $Q -yopush_cset 'F!O#O$ B%A^R&RR(R)RR'
#bk commit $Q -yopush_cset -STAG2
#echo OK
