# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Tests for tag propogation in new/old protocols.
echo $N Create initial repository ...................................$NL
no_logging project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
mkdir src
cd src
echo foo > 'F!O#O$ B%A^R&RR(R)RR'
echo bar > bar.c
echo h > h.h
bk ci $Q -i 'F!O#O$ B%A^R&RR(R)RR' bar.c h.h
if [ ! -f SCCS/s.'F!O#O$ B%A^R&RR(R)RR' ]; then echo failed to create history; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 15 ]; then echo wrong pending result $P; bk pending; exit 1; fi
bk commit $S -a -yCset
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo failed to clear pending list; bk pending; exit 1; fi
echo OK
cores

echo $N Tags may not start with a digit .............................$NL
bk tag $Q 1234 && {
	echo Should have failed
	exit 1
}
echo OK

echo $N "Tags may not start with a  =  ...............................$NL"
bk tag $Q =1234 && {
	echo Should have failed
	exit 1
}
echo OK

echo $N "Tags may not start with a  .  ...............................$NL"
bk tag $Q .1234 && {
	echo Should have failed
	exit 1
}
echo OK

echo $N "Tags may not start with a  -  ...............................$NL"
bk tag $Q -- -1234 && {
	echo Should have failed
	exit 1
}
echo OK

echo $N "Tags may not be just a  +  ..................................$NL"
bk tag $Q + && {
	echo Should have failed
	exit 1
}
echo OK

for s in .. ., ,. ,,
do
echo $N "Tags may not contain a  $s  .................................$NL"
bk tag $Q foo${s}bar && {
	echo Should have failed
	exit 1
}
echo OK
done

echo $N "Tags may not contain a  |  ..................................$NL"
bk tag $Q 'foo|bar' && {
	echo Should have failed
	exit 1
}
echo OK

test $PLATFORM != "WIN32" && {
echo $N "Tags may not contain a newline ..............................$NL"
bk tag $Q 'foo
bar' && {
	echo Should have failed
	exit 1
}
echo OK
}

echo $N Add old style tags ..........................................$NL
cd $HERE
cp -rp project tags
cd tags
_BK_NO_TAG_GRAPH=YES bk tag $Q OLD
grep -q '^.cS l' SCCS/s.ChangeSet && {
	echo added a leaf
	cat SCCS/s.ChangeSet
	exit 1
}
grep -q '^.cS[0-9]' SCCS/s.ChangeSet && {
	echo added a tag graph node
	cat SCCS/s.ChangeSet
	exit 1
}
bk admin -hhhq || exit 1
echo OK

echo $N Add new style tags ..........................................$NL
bk tag $Q NEW
grep -q '^.cS0' SCCS/s.ChangeSet || {
	echo did not add tag pointing to the root node
	egrep '^.cS|^.d ' SCCS/s.ChangeSet
	exit 1
}
grep -q '^.cS0 l' SCCS/s.ChangeSet || {
	echo did not add leaf flag
	egrep '^.cS|^.d ' SCCS/s.ChangeSet
	exit 1
}
bk tag $Q 'NEW TAG'
grep -q '^.cS0' SCCS/s.ChangeSet || {
	echo lost tag pointing to the root node
	egrep '^.cS|^.d ' SCCS/s.ChangeSet
	exit 1
}
grep -q '^.cS0 l' SCCS/s.ChangeSet && {
	echo Root tag is still marked as leaf
	egrep '^.cS|^.d ' SCCS/s.ChangeSet
	exit 1
}
grep -q '^.cS5 l' SCCS/s.ChangeSet || {
	echo Did not add tag pointing to previous tag
	egrep '^.cS|^.d ' SCCS/s.ChangeSet
	exit 1
}
cp SCCS/s.ChangeSet SAVE
bk admin -z ChangeSet
cmp -s SCCS/s.ChangeSet SAVE || {
	echo admin -z stomped on tags
	diff SCCS/s.ChangeSet SAVE
	exit 1
}
bk admin -hhhq || exit 1
echo OK

echo $N Add same tag to a new cset as part of the cset ..............$NL
ls > RST
bk new $Q RST
bk commit $Q -SNEW -yNEW2 || exit 1
bk admin -hhhq || exit 1
echo OK

echo $N Clone repository ............................................$NL
cd $HERE
if [ X$PLATFORM = X"WIN32" ]; then SLASH="//"; else SLASH="/"; fi
bk clone $Q $HERE/project $HERE/copy || { echo failed; exit 1; }
bk clone $Q $HERE/project $HERE/copy2 || { echo failed; exit 1; }
bk clone $Q $HERE/project $HERE/copy3 || { echo failed; exit 1; }
[ -f copy/src/SCCS/s.'F!O#O$ B%A^R&RR(R)RR' ] || { echo failed; exit 1; }
[ -f copy/BitKeeper/log/parent ] || { echo no parent; exit 1; }
parent=`cat copy/BitKeeper/log/parent`
host=`bk gethost`
[ x$parent = xfile:$SLASH$HERE/project ] || \
					{ echo wrong parent $parent; exit 1; }
cd $HERE/project; checkLocks; cd $HERE/copy; checkLocks
echo OK

echo $N Create a changeset in compat mode with a tag ................$NL
cd $HERE/project/src
bk get $Q -e 'F!O#O$ B%A^R&RR(R)RR'
echo delta two >> 'F!O#O$ B%A^R&RR(R)RR'
bk delta $Q -ywhatever 'F!O#O$ B%A^R&RR(R)RR'
_BK_NO_TAG_GRAPH=YES bk commit $Q -yopull_cset -S'NOT IN TAG GRAPH'
cd ..
grep -q '^.cS[0-9]' SCCS/s.ChangeSet && {
	echo added a tag graph node
	cat SCCS/s.ChangeSet
	exit 1
}
bk admin -hhhq || exit 1
bk admin -z
grep -q '^.cS[0-9]' SCCS/s.ChangeSet && {
	echo added a tag graph node after the admin -z
	cat SCCS/s.ChangeSet
	exit 1
}
echo OK

echo $N Pull a new changeset with an old tag using pull .............$NL
cd $HERE/copy2
bk pull -t $Q || { echo failed; exit 1; }
revs=`bk prs -hd':I:\n' src/'F!O#O$ B%A^R&RR(R)RR' | wc -l`
[ $revs -eq 2 ] || { echo failed; exit 1; }
grep -q 'NOT IN TAG' SCCS/s.ChangeSet || { echo did not propogate tag; exit 1; }
bk admin -hhhq || exit 1
echo OK

echo $N Resolve a tag conflict, pick remote, see if it sticks .......$NL
cd $HERE
rm -rf project copy
no_logging project
echo hi > foo
bk new $Q foo
bk commit -yDsub1 $Q
cd $HERE
bk clone $Q project copy
cd $HERE/project
echo hi > bar
bk new $Q bar
bk commit -yDsub2 -STAG $Q
REMOTE=`bk prs -hrTAG -d:KEY: ChangeSet`
cd $HERE/copy
echo hi > snafu
bk new $Q snafu
bk commit -yDsub3 -STAG $Q
LOCAL=`bk prs -hrTAG -d:KEY: ChangeSet`
cp SCCS/s.ChangeSet CSET
bk pull $Q -R
(
echo ""
echo "x"
echo r
) | bk resolve -l -t $Q 2>OUT
test -d RESYNC && {
	echo resolve failed
	cat OUT
	egrep '^.cS|^.d ' RESYNC/SCCS/s.ChangeSet
	exit 1
}
KEY=`bk prs -hrTAG -d:KEY: ChangeSet`
if [ "$KEY" = "$LOCAL" ]
then	echo Whoops, used local instead of remote
	echo "REMOTE:	$REMOTE"
	echo "LOCAL:	$LOCAL"
	bk prs -d':I: :KEY:\n' ChangeSet
	cat OUT
	exit 1
fi
if [ "$KEY" != "$REMOTE" ]
then	echo Whoops, it is not remote and is not local
	echo "REMOTE:	$REMOTE"
	echo "LOCAL:	$LOCAL"
	echo "KEY:	$KEY"
	bk prs -d':I: :KEY:\n' ChangeSet
	exit 1
fi
echo OK

echo $N Undo after the unchoosen rev, merge should be gone ..........$NL
bk undo $Q -fa1.2.1.1
KEY=`bk prs -hrTAG -d:KEY: ChangeSet`
if [ "$KEY" != "$LOCAL" ]
then	echo Whoops, key is not restored
	echo "LOCAL:	$LOCAL"
	bk prs -d':I: :KEY:\n' ChangeSet
	exit 1
fi
echo OK

echo $N Pull again, choose local, see if it sticks ..................$NL
bk pull $Q -R
bk resolve -t $Q 2>OUT 1>&2 <<EOF
l
EOF
KEY=`bk prs -hrTAG -d:KEY: ChangeSet`
if [ "$KEY" = "$REMOTE" ]
then	echo Whoops, used remote instead of local
	echo "REMOTE:	$REMOTE"
	echo "LOCAL:	$LOCAL"
	bk prs -d':I: :KEY:\n' ChangeSet
	exit 1
fi
if [ "$KEY" != "$LOCAL" ]
then	echo Whoops, it is not local and is not remote
	echo "REMOTE:	$REMOTE"
	echo "LOCAL:	$LOCAL"
	echo "KEY:	$KEY"
	bk prs -d':I: :KEY:\n' ChangeSet
	exit 1
fi
echo OK

# We depend on tags added after the cset is created to have a 0 cksum so
# we can distinguish them from a cset.
# XXX - what if the cset is legitmately == 0?  I suppose we get the count
# wrong at that point.
echo $N Make sure that tag chksum == 0 ..............................$NL
cd $HERE/project
bk tag $Q project
CHKSUM=`bk prs -nhad'$if(:DT:=T){:DSUM:}' ChangeSet`
if [ "$CHKSUM" -ne 0 ]
then	echo failed, CHKSUM = $CHKSUM
	bk prs -ad':I: :DT: :DSUM: :KEY:\n' ChangeSet
	exit 1
fi
echo OK

echo $N Create a tag only conflict, push, check error message .......$NL
cd $HERE/copy
bk tag $Q copy
bk push >OUT 2>&1
if [ $? -eq 0 ]
then	echo failed to exit non zero;
	cat OUT
	exit 1
fi
grep -q '1 tags only in' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK

echo $N Test propogation of the first tag ...........................$NL
cd $HERE
rm -rf tagpush tagchild
no_logging tagpush
ls > file
bk new $Q file
bk commit $Q -ywhatever
bk clone $Q $HERE/tagpush $HERE/tagchild
bk tag $Q TAG
cd $HERE/tagchild
bk pull $Q || {
	echo pull failed
	exit 1
}
grep -q 'd R 1.2 ' SCCS/s.ChangeSet || {
	echo failed to send removed delta
	exit 1
}
grep -q 'STAG' SCCS/s.ChangeSet || {
	echo failed to send tag
	exit 1
}
grep -q 'S0 l' SCCS/s.ChangeSet || {
	echo failed to mark tag in tag graph correctly
	exit 1
}
echo OK

echo $N Test propogation of a tag added with a commit ...............$NL
cd $HERE/tagpush
bk edit $Q file
bk delta -ywww $Q file
bk commit $Q -ywhatever -STAG_NO_2
cd $HERE/tagchild
bk pull $Q || {
	echo pull failed
	exit 1
}
grep -q 'STAG_NO_2' SCCS/s.ChangeSet || {
	echo failed to send tag
	exit 1
}
grep -q 'S4 l' SCCS/s.ChangeSet || {
	echo failed to mark leaf tag in tag graph correctly
	exit 1
}
grep -q 'S0$' SCCS/s.ChangeSet || {
	echo failed to mark root tag in tag graph correctly
	exit 1
}
echo OK

echo $N Make sure we pick up tags from SCCS/t.ChangeSet .............$NL
cd $HERE/tagpush
bk edit $Q file
bk delta -ywww $Q file
echo 't.tag' > SCCS/t.ChangeSet
echo 't.tag2' >> SCCS/t.ChangeSet
echo 'I am a tag with spaces' >> SCCS/t.ChangeSet
bk commit $Q -ywhatever 
test -f SCCS/t.ChangeSet && {
	echo failed to remove t.ChangeSet after commit
	exit 1
}
grep -q '^.cSt.tag' SCCS/s.ChangeSet || {
	echo failed to add tag to ChangeSet file
	exit 1
}
grep -q '^.cSt.tag2' SCCS/s.ChangeSet || {
	echo failed to add tag2 to ChangeSet file
	exit 1
}
grep -q '^.cSI am a tag with spaces' SCCS/s.ChangeSet || {
	echo failed to add I am a tag with spaces to ChangeSet file
	exit 1
}
echo OK

# Test the case where the same tag is on multiple entries on each side.
# It should find the last one on each side.
echo $N Test propogation of a tag added with a commit, pick remote ..$NL
cd $HERE/tagpush
bk edit $Q file
bk delta -ywww $Q file
bk commit $Q -ywhatever -Ssame_tag
cd $HERE/tagchild
bk pull $Q || {
	echo pull failed
	exit 1
}
# Now alternate between sides
for  i in 1 2 3
do	for dir in tagpush tagchild
	do	cd $HERE/$dir
		bk edit $Q file
		bk delta -ywww $Q file
		bk commit $Q -ywhatever -Ssame_tag
	done
done
cd $HERE
tar cf tagchild.TAR tagchild
cd $HERE/tagchild
#  ( echo ""
#   echo x
#   echo p
#   echo t
#   echo q
#   ) | bk pull
echo r | bk pull $Q 2>/dev/null
test -d RESYNC && {
	echo failed to resolve
	exit 1
}
test X`bk prs -hr1.5.1.3 -nd:TAG: ChangeSet` = Xsame_tag || {
	echo Failed to add tag to tip of branch, 1.5.1.3
	bk prs ChangeSet
	exit 1
}
echo OK
#bk revtool

echo $N Test propogation of a tag added with a commit, pick merge ...$NL
cd $HERE
rm -rf tagchild
tar xf tagchild.TAR
cd $HERE/tagchild
echo m | bk pull $Q 2>/dev/null
test -d RESYNC && {
	echo failed to resolve
	exit 1
}
test X`bk prs -hr+ -nd:TAG: ChangeSet` = Xsame_tag || {
	echo Failed to add tag to merge
	bk prs ChangeSet
	exit 1
}
echo OK
#bk revtool

echo $N Tag conflict only, try to choose merge, should fail .........$NL
cd $HERE
cd $HERE/tagpush
bk tag $Q -r1.3 old_tag
cd $HERE/tagchild
bk tag $Q -r1.4 old_tag
( echo ""
  echo x
  echo m
  echo q
) | bk pull $Q 2>OUT 
test -d RESYNC || {
	echo should have failed to resolve
	cat OUT
	exit 1
}
echo OK

echo $N Choose local, should work fine. .............................$NL
( echo ""
  echo x
  echo l
  echo q
) | bk resolve $Q 2>OUT 
test -d RESYNC && {
	echo failed to resolve
	cat OUT
	exit 1
}
echo OK

# These are white box tests, designed to tickle an ex-bug (L1 failed)
echo $N Merge tag where history contains same name on L2 branch .....$NL
cd $HERE
bk clone $Q project mergemain
cd mergemain
bk edit $Q foo
bk delta $Q -yfoo foo
bk commit $Q -Sfoo -yfoo
cd $HERE
bk clone $Q mergemain mergebranch
cd mergemain
bk edit $Q foo
bk delta $Q -yfoo foo
bk commit $Q -Sbar -yfoo
cd $HERE/mergebranch
bk edit $Q foo
bk delta $Q -yfoo foo
bk commit $Q -Sfoo -yfoo
bk pull $Q $HERE/mergemain
echo OK

echo $N Merge tag where history contains same name on L1 branch .....$NL
cd $HERE/mergemain
bk edit $Q foo
bk delta $Q -yfoo foo
bk commit $Q -Sbaz -yfoo
echo q | bk pull $Q $HERE/mergebranch > OUT 2>&1 || {
	echo Failed
	exit 1
}
echo OK

# Create a repository
# clone it
# tag it
# opush the tag

#echo $N Create the same tag in a new place ..........................$NL
#cd $HERE/copy/src
#bk get $Q -e 'F!O#O$ B%A^R&RR(R)RR'
#echo delta two >> 'F!O#O$ B%A^R&RR(R)RR'
#bk delta $Q -yopush_cset 'F!O#O$ B%A^R&RR(R)RR'
#bk commit $Q -yopush_cset -STAG2
#echo OK
