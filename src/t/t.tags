# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

if [ X$PLATFORM = X"WIN32" ]
then
        # It is unlikely in that ssh/rsh to localhost will work on NT.
        # We let the user tell us otherwise.
        if [ -z "$DO_REMOTE" ]; then DO_REMOTE=NO; fi
else
	if [ -z "$DO_REMOTE" ]; then DO_REMOTE=YES; fi
fi

# Tests for tag propogation in new/old protocols.
echo $N Create initial repository ...................................$NL
no_logging project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
mkdir src
cd src
echo foo > 'F!O#O$ B%A^R&RR(R)RR'
echo bar > bar.c
echo h > h.h
bk ci $Q -i 'F!O#O$ B%A^R&RR(R)RR' bar.c h.h
if [ ! -f SCCS/s.'F!O#O$ B%A^R&RR(R)RR' ]; then echo failed to create history; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 15 ]; then echo wrong pending result $P; bk pending; exit 1; fi
bk commit $S -a -yCset
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo failed to clear pending list; bk pending; exit 1; fi
echo OK
cores
echo $N Add old style tags ..........................................$NL
cd $HERE
cp -rp project tags
cd tags
_BK_NO_TAG_GRAPH=YES bk tag $Q OLD
grep -q '^.cS l' SCCS/s.ChangeSet && {
	echo added a leaf
	cat SCCS/s.ChangeSet
	exit 1
}
grep -q '^.cS[0-9]' SCCS/s.ChangeSet && {
	echo added a tag graph node
	cat SCCS/s.ChangeSet
	exit 1
}
bk admin -hhhq || exit 1
echo OK
echo $N Add new style tags ..........................................$NL
bk tag $Q NEW
grep -q '^.cS0' SCCS/s.ChangeSet || {
	echo did not add tag pointing to the root node
	egrep '^.cS|^.d ' SCCS/s.ChangeSet
	exit 1
}
grep -q '^.cS0 l' SCCS/s.ChangeSet || {
	echo did not add leaf flag
	egrep '^.cS|^.d ' SCCS/s.ChangeSet
	exit 1
}
bk tag $Q 'NEW TAG'
grep -q '^.cS0' SCCS/s.ChangeSet || {
	echo lost tag pointing to the root node
	egrep '^.cS|^.d ' SCCS/s.ChangeSet
	exit 1
}
grep -q '^.cS0 l' SCCS/s.ChangeSet && {
	echo Root tag is still marked as leaf
	egrep '^.cS|^.d ' SCCS/s.ChangeSet
	exit 1
}
grep -q '^.cS5 l' SCCS/s.ChangeSet || {
	echo Did not add tag pointing to previous tag
	egrep '^.cS|^.d ' SCCS/s.ChangeSet
	exit 1
}
cp SCCS/s.ChangeSet SAVE
bk admin -z ChangeSet
cmp -s SCCS/s.ChangeSet SAVE || {
	echo admin -z stomped on tags
	diff SCCS/s.ChangeSet SAVE
	exit 1
}
bk admin -hhhq || exit 1
echo OK

echo $N Add same tag to a new cset as part of the cset ..............$NL
ls > RST
bk new $Q RST
bk commit $Q -SNEW -yNEW2 || exit 1
bk admin -hhhq || exit 1
echo OK

echo $N Clone repository ............................................$NL
cd $HERE
bk clone $Q $HERE/project $HERE/copy || { echo failed; exit 1; }
bk clone $Q $HERE/project $HERE/copy2 || { echo failed; exit 1; }
bk clone $Q $HERE/project $HERE/copy3 || { echo failed; exit 1; }
[ -f copy/src/SCCS/s.'F!O#O$ B%A^R&RR(R)RR' ] || { echo failed; exit 1; }
[ -f copy/BitKeeper/log/parent ] || { echo no parent; exit 1; }
parent=`cat copy/BitKeeper/log/parent`
host=`bk gethost`
[ x$parent = x${host}:$HERE/project ] || { echo wrong parent $parent; exit 1; }
cd $HERE/project; checkLocks; cd $HERE/copy; checkLocks
echo OK
echo $N Create a changeset in compat mode with a tag ................$NL
cd $HERE/project/src
bk get $Q -e 'F!O#O$ B%A^R&RR(R)RR'
echo delta two >> 'F!O#O$ B%A^R&RR(R)RR'
bk delta $Q -ywhatever 'F!O#O$ B%A^R&RR(R)RR'
_BK_NO_TAG_GRAPH=YES bk commit $Q -yopull_cset -S'NOT IN TAG GRAPH'
cd ..
grep -q '^.cS[0-9]' SCCS/s.ChangeSet && {
	echo added a tag graph node
	cat SCCS/s.ChangeSet
	exit 1
}
bk admin -hhhq || exit 1
bk admin -z
grep -q '^.cS[0-9]' SCCS/s.ChangeSet && {
	echo added a tag graph node after the admin -z
	cat SCCS/s.ChangeSet
	exit 1
}
echo OK
echo $N Pull a new changeset with an old tag using opull ............$NL
cd $HERE/copy
cp SCCS/s.ChangeSet CSET
bk opull -t $Q || { echo failed; exit 1; }
revs=`bk prs -hd':I:\n' src/'F!O#O$ B%A^R&RR(R)RR' | wc -l`
[ $revs -eq 2 ] || { echo failed; exit 1; }
grep -q '^.cS[0-9]' SCCS/s.ChangeSet && {
	echo added a tag graph node
	bk difftool CSET SCCS/s.ChangeSet
	exit 1
}
bk admin -hhhq || exit 1
echo OK
echo $N Pull a new changeset with an old tag using pull .............$NL
cd $HERE/copy2
bk pull -t $Q || { echo failed; exit 1; }
revs=`bk prs -hd':I:\n' src/'F!O#O$ B%A^R&RR(R)RR' | wc -l`
[ $revs -eq 2 ] || { echo failed; exit 1; }
grep -q 'NOT IN TAG' SCCS/s.ChangeSet || { echo did not propogate tag; exit 1; }
bk admin -hhhq || exit 1
echo OK

echo $N Resolve a tag conflict, pick remote, see if it sticks .......$NL
cd $HERE
rm -rf project copy
no_logging project
echo hi > foo
bk new $Q foo
bk commit -yDsub1 $Q
cd $HERE
bk clone $Q project copy
cd $HERE/project
echo hi > bar
bk new $Q bar
bk commit -yDsub2 -STAG $Q
REMOTE=`bk prs -hrTAG -d:KEY: ChangeSet`
cd $HERE/copy
echo hi > snafu
bk new $Q snafu
bk commit -yDsub3 -STAG $Q
LOCAL=`bk prs -hrTAG -d:KEY: ChangeSet`
cp SCCS/s.ChangeSet CSET
bk resync $Q
(
echo ""
echo "x"
echo r
) | bk resolve -l -t $Q 2>OUT
test -d RESYNC && {
	echo resolve failed
	cat OUT
	egrep '^.cS|^.d ' RESYNC/SCCS/s.ChangeSet
	exit 1
}
KEY=`bk prs -hrTAG -d:KEY: ChangeSet`
if [ "$KEY" = "$LOCAL" ]
then	echo Whoops, used local instead of remote
	echo "REMOTE:	$REMOTE"
	echo "LOCAL:	$LOCAL"
	bk prs -d':I: :KEY:\n' ChangeSet
	cat OUT
	exit 1
fi
if [ "$KEY" != "$REMOTE" ]
then	echo Whoops, it is not remote and is not local
	echo "REMOTE:	$REMOTE"
	echo "LOCAL:	$LOCAL"
	echo "KEY:	$KEY"
	bk prs -d':I: :KEY:\n' ChangeSet
	exit 1
fi
echo OK

echo $N Undo after the unchoosen rev, merge should be gone ..........$NL
bk undo $Q -fa1.2.1.1
KEY=`bk prs -hrTAG -d:KEY: ChangeSet`
if [ "$KEY" != "$LOCAL" ]
then	echo Whoops, key is not restored
	echo "LOCAL:	$LOCAL"
	bk prs -d':I: :KEY:\n' ChangeSet
	exit 1
fi
echo OK

echo $N Pull again, choose local, see if it sticks ..................$NL
bk resync $Q
(
echo l
) | bk resolve -t $Q 2>OUT
KEY=`bk prs -hrTAG -d:KEY: ChangeSet`
if [ "$KEY" = "$REMOTE" ]
then	echo Whoops, used remote instead of local
	echo "REMOTE:	$REMOTE"
	echo "LOCAL:	$LOCAL"
	bk prs -d':I: :KEY:\n' ChangeSet
	exit 1
fi
if [ "$KEY" != "$LOCAL" ]
then	echo Whoops, it is not local and is not remote
	echo "REMOTE:	$REMOTE"
	echo "LOCAL:	$LOCAL"
	echo "KEY:	$KEY"
	bk prs -d':I: :KEY:\n' ChangeSet
	exit 1
fi
echo OK

# We depend on tags added after the cset is created to have a 0 cksum so
# we can distinguish them from a cset.
# XXX - what if the cset is legitmately == 0?  I suppose we get the count
# wrong at that point.
echo $N Make sure that tag chksum == 0 ..............................$NL
cd $HERE/project
bk tag $Q project
CHKSUM=`bk prs -nhad'$if(:DT:=T){:DSUM:}' ChangeSet`
if [ "$CHKSUM" -ne 0 ]
then	echo failed, CHKSUM = $CHKSUM
	bk prs -ad':I: :DT: :DSUM: :KEY:\n' ChangeSet
	exit 1
fi
echo OK

echo $N Create a tag only conflict, push, check error message .......$NL
cd $HERE/copy
bk tag $Q copy
bk push 2>OUT
if [ $? -eq 0 ]
then	echo failed to exit non zero;
	cat OUT
	exit 1
fi
grep -q '1 tags only in' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
echo OK

test -d /usr/libexec/bitkeeper-1.2 || exit 0

echo $N Create a 1.x style tree and copies of it ....................$NL
cd $HERE
rm -rf c* p* t*
SAVE=$PATH
PATH=/usr/libexec/bitkeeper-1.2:$PATH
no_logging old
PATH=$SAVE
cd $HERE
bk clone $Q old new
tar cf TAR new old
cd new
bk admin -qhhh ChangeSet || { bk admin -hhh ChangeSet; exit 1; }
P=50000
bk bkd -d -p$P -P$HERE/pid 2>/dev/null
while [ $? -eq 2 ]
do      P=`expr $P + 1`
	bk bkd -d -p$P -P$HERE/pid 2>/dev/null
done
echo OK

echo $N Create a new changeset with an old tag, 1.x pull it, works ..$NL
cd $HERE/new
ls > LS
bk new $Q LS
_BK_NO_TAG_GRAPH=YES bk commit $Q -ycset1 -S'OLD STYLE'
grep -q 'cS0' SCCS/s.ChangeSet && { echo added new tag; exit 1; }
cd $HERE/old
/usr/libexec/bitkeeper-1.2/bk pull -t $Q bk://localhost:$P || exit 1
grep -q 'OLD STYLE' SCCS/s.ChangeSet || { echo no tag; exit 1; }
grep -q '^.cV4' SCCS/s.ChangeSet && { echo propogated version; exit 1; }
echo OK

echo $N Create a new changeset with an old tag, opull it, works .....$NL
cd $HERE
rm -rf new old
tar xf TAR
kill -9 `cat $HERE/pid`
cd new
P=50000
bk bkd -d -p$P -P$HERE/pid 2>/dev/null
while [ $? -eq 2 ]
do      P=`expr $P + 1`
	bk bkd -d -p$P -P$HERE/pid 2>/dev/null
done
cd $HERE/new
ls > LS
bk new $Q LS
_BK_NO_TAG_GRAPH=YES bk commit $Q -ycset1 -S'OLD STYLE'
grep -q 'cS0' SCCS/s.ChangeSet && { echo added new tag; exit 1; }
cd $HERE/old
bk idcache -q
bk opull -t $Q bk://localhost:$P || exit 1
grep -q 'OLD STYLE' SCCS/s.ChangeSet || { echo no tag; exit 1; }
# The following test is if and only if we maintain the old file version #.
# grep -q '^.cV4' SCCS/s.ChangeSet && { echo propogated version; exit 1; }
echo OK

echo $N Create a new changeset, add a new tag, opull it, no tag .....$NL
cd $HERE/new
ls > XYZ
bk new $Q XYZ
bk commit $Q -ycset1 
bk tag $Q 'NEW TAG'
grep -q 'cS0' SCCS/s.ChangeSet || { echo No tag graph found; exit 1; }
KEY=`bk prs -hr+ -d:KEY: ChangeSet`
cd $HERE/old
bk opull -t $Q bk://localhost:$P || exit 1
grep -q 'NEW TAG' SCCS/s.ChangeSet && { echo tag was sent; exit 1; }
# The following test is if and only if we maintain the old file version #.
# grep -q '^.cV4' SCCS/s.ChangeSet && { echo propogated version; exit 1; }
GOT=`bk prs -hr+ -d:KEY: ChangeSet`
if [ X"$KEY" != X"$GOT" ]
then	echo "KEY $KEY"
	echo "GOT $GOT"
	exit 1
fi
echo OK

echo $N Create a new changeset with an new tag, 1.x pull it, fails...$NL
cd $HERE/new
bk edit $Q XYZ
bk delta $Q -ywww XYZ
bk commit $Q -ycset1 -S'NEW TAG'
grep -q 'cS0' SCCS/s.ChangeSet || { echo No tag graph found; exit 1; }
KEY=`bk prs -hr+ -d:KEY: ChangeSet`
cd $HERE/old
/usr/libexec/bitkeeper-1.2/bk pull -t bk://localhost:$P 2>OUT
S=$?
kill -9 `cat $HERE/pid`
test $S -eq 0 && {
	echo should have failed and did not
	cat OUT
	exit 1
}
echo OK
find /tmp -name 'csort*' -print | xargs /bin/rm -f 2>/dev/null

echo $N Test 1.x push from old to new with old style tag ............$NL
cd $HERE
rm -rf new old
tar xf TAR
cd new
P=50000
bk bkd -d -p$P -P$HERE/pid 2>/dev/null
while [ $? -eq 2 ]
do      P=`expr $P + 1`
	bk bkd -d -p$P -P$HERE/pid 2>/dev/null
done
cd $HERE/old
ls > LS
/usr/libexec/bitkeeper-1.2/bk new $Q LS
/usr/libexec/bitkeeper-1.2/bk commit $Q -ycset1 -S'OLD STYLE'
KEY=`bk prs -hr+ -d:KEY: ChangeSet`
/usr/libexec/bitkeeper-1.2/bk push -t $Q bk://localhost:$P || exit 1
cd $HERE/new
grep -q 'OLD STYLE' SCCS/s.ChangeSet || { echo no tag; exit 1; }
GOT=`bk prs -hr+ -d:KEY: ChangeSet`
if [ X"$KEY" != X"$GOT" ]
then	echo "KEY $KEY"
	echo "GOT $GOT"
	exit 1
fi
echo OK

echo $N Test 2.x opush from old to old server with old tag ..........$NL
cd $HERE
rm -rf new old
tar xf TAR
mv new older
kill -9 `cat $HERE/pid`
cd older
P=50000
/usr/libexec/bitkeeper-1.2/bk bkd -d -p$P -P$HERE/pid 2>/dev/null
while [ $? -eq 2 ]
do      P=`expr $P + 1`
	/usr/libexec/bitkeeper-1.2/bk bkd -d -p$P -P$HERE/pid 2>/dev/null
done
cd $HERE/old
ls > LS
/usr/libexec/bitkeeper-1.2/bk new $Q LS
/usr/libexec/bitkeeper-1.2/bk commit $Q -ycset1 -S'OLD STYLE'
KEY=`/usr/libexec/bitkeeper-1.2/bk prs -hr+ -d:KEY: ChangeSet`
bk idcache -q
bk opush -t $Q bk://localhost:$P || exit 1
cd $HERE/older
grep -q 'OLD STYLE' SCCS/s.ChangeSet || { echo no tag; exit 1; }
GOT=`bk prs -hr+ -d:KEY: ChangeSet`
if [ X"$KEY" != X"$GOT" ]
then	echo "KEY $KEY"
	echo "GOT $GOT"
	exit 1
fi
echo OK

echo $N Test 2.x opush from new to old server with old tag ..........$NL
cd $HERE
rm -rf new old
tar xf TAR
kill -9 `cat $HERE/pid`
cd old
P=50000
/usr/libexec/bitkeeper-1.2/bk bkd -d -p$P -P$HERE/pid 2>/dev/null
while [ $? -eq 2 ]
do      P=`expr $P + 1`
	/usr/libexec/bitkeeper-1.2/bk bkd -d -p$P -P$HERE/pid 2>/dev/null
done
cd $HERE/new
bk idcache -q
ls > LS
bk new $Q LS
bk commit $Q -ycset1
_BK_NO_TAG_GRAPH=YES bk tag -q 'OLD OLD'
KEY=`bk prs -hr+ -d:KEY: ChangeSet`
bk opush -t $Q bk://localhost:$P 2>OUT || exit 1
cat OUT
cores
cd $HERE/old
grep -q 'NEW NEW' SCCS/s.ChangeSet && { echo sent new tag; exit 1; }
#xterm -n OLD -geom +1+1 -e vi SCCS/s.ChangeSet &
grep -q 'OLD OLD' SCCS/s.ChangeSet || { echo did not send old tag; exit 1; }
GOT=`bk prs -hr+ -d:KEY: ChangeSet`
if [ X"$KEY" != X"$GOT" ]
then	echo "KEY $KEY"
	echo "GOT $GOT"
	exit 1
fi
grep -q '^.cV4' SCCS/s.LS && { echo propogated version in LS; exit 1; }
grep -q '^.cV4' SCCS/s.ChangeSet && { echo propogated version in Cset; exit 1; }
echo OK

echo $N Test 2.x opush from new to old with both new and old tag ....$NL
cd $HERE
rm -rf new old
tar xf TAR
kill -9 `cat $HERE/pid`
cd old
P=50000
/usr/libexec/bitkeeper-1.2/bk bkd -d -p$P -P$HERE/pid 2>/dev/null
while [ $? -eq 2 ]
do      P=`expr $P + 1`
	/usr/libexec/bitkeeper-1.2/bk bkd -d -p$P -P$HERE/pid 2>/dev/null
done
cd $HERE/new
bk idcache -q
ls > LS
bk new $Q LS
bk commit $Q -ycset1 
bk tag $Q 'NEW NEW'
bk edit $Q LS
bk delta -ywww $Q LS
bk commit $Q -ycset1 
bk tag $Q NEWBIE
_BK_NO_TAG_GRAPH=YES bk tag -q 'OLD OLD'
_BK_NO_TAG_GRAPH=YES bk tag -q 'OLDY'
KEY=`bk prs -hr+ -d:KEY: ChangeSet`
bk opush -t $Q bk://localhost:$P 2>OUT || exit 1
cores
cd $HERE/old
grep -q 'NEW NEW' SCCS/s.ChangeSet && { echo sent new tag; exit 1; }
grep -q 'NEWBIE' SCCS/s.ChangeSet && { echo sent new tag; exit 1; }
grep -q 'OLD OLD' SCCS/s.ChangeSet || { echo did not send old tag; exit 1; }
grep -q 'OLDY' SCCS/s.ChangeSet || { echo did not send old tag; exit 1; }
GOT=`bk prs -hr+ -d:KEY: ChangeSet`
if [ X"$KEY" != X"$GOT" ]
then	echo "KEY $KEY"
	echo "GOT $GOT"
	exit 1
fi
grep -q '^.cV4' SCCS/s.LS && { echo propogated version in LS; exit 1; }
grep -q '^.cV4' SCCS/s.ChangeSet && { echo propogated version in Cset; exit 1; }
echo OK

kill -9 `cat $HERE/pid`

echo $N Test opush of new tag, should not send tag or R delta .......$NL
cd $HERE
no_logging tagpush
ls > file
bk new $Q file
bk commit $Q -ywhatever
bk clone $Q $HERE/tagpush $HERE/tagchild
bk tag $Q TAG
bk opush $HERE/tagchild 2>OUT
grep -q 'Nothing to push' OUT || {
	echo Tried to push the tag
	exit 1
}
bk edit $Q file
bk delta $Q -ywhatever file
bk commit -ywhatever $Q
bk opush $Q $HERE/tagchild
cd $HERE/tagchild
grep -q 'd R 1.2 ' SCCS/s.ChangeSet && {
	echo propogated tag delta, probably not the tag
	echo Trying to fix it
	bk admin -z
	grep -q 'd R 1.2 ' SCCS/s.ChangeSet
	if [ $? = 0 ]
	then
		echo OK, admin -z did not fix it
	else
		echo OK, admin -z fixed it at least.
	fi
	exit 1
}
echo OK

echo $N Test opull of new tag, should not send tag or R delta .......$NL
cd $HERE
rm -rf tagpush tagchild
no_logging tagpush
ls > file
bk new $Q file
bk commit $Q -ywhatever
bk clone $Q $HERE/tagpush $HERE/tagchild
bk tag $Q TAG
cd $HERE/tagchild
bk opull 2>OUT
grep -q 'Nothing to pull' OUT || {
	echo Tried to pull the tag
	exit 1
}
cd $HERE/tagpush
bk edit $Q file
bk delta $Q -ywhatever file
bk commit -ywhatever $Q
cd $HERE/tagchild
bk opull $Q
grep -q 'd R 1.2 ' SCCS/s.ChangeSet && {
	echo propogated tag delta, probably not the tag
	echo Trying to fix it
	bk admin -z
	grep -q 'd R 1.2 ' SCCS/s.ChangeSet
	if [ $? = 0 ]
	then
		echo OK, admin -z did not fix it
	else
		echo OK, admin -z fixed it at least.
	fi
	exit 1
}
echo OK

echo $N Test propogation of the first tag ...........................$NL
cd $HERE
rm -rf tagpush tagchild
no_logging tagpush
ls > file
bk new $Q file
bk commit $Q -ywhatever
bk clone $Q $HERE/tagpush $HERE/tagchild
bk tag $Q TAG
cd $HERE/tagchild
bk pull $Q || {
	echo pull failed
	exit 1
}
grep -q 'd R 1.2 ' SCCS/s.ChangeSet || {
	echo failed to send removed delta
	exit 1
}
grep -q 'STAG' SCCS/s.ChangeSet || {
	echo failed to send tag
	exit 1
}
grep -q 'S0 l' SCCS/s.ChangeSet || {
	echo failed to mark tag in tag graph correctly
	exit 1
}
echo OK

echo $N Test propogation of a tag added with a commit ...............$NL
cd $HERE/tagpush
bk edit $Q file
bk delta -ywww $Q file
bk commit $Q -ywhatever -STAG_NO_2
cd $HERE/tagchild
bk pull $Q || {
	echo pull failed
	exit 1
}
grep -q 'STAG_NO_2' SCCS/s.ChangeSet || {
	echo failed to send tag
	exit 1
}
grep -q 'S4 l' SCCS/s.ChangeSet || {
	echo failed to mark leaf tag in tag graph correctly
	exit 1
}
grep -q 'S0$' SCCS/s.ChangeSet || {
	echo failed to mark root tag in tag graph correctly
	exit 1
}
echo OK

echo $N Make sure we pick up tags from SCCS/t.ChangeSet .............$NL
cd $HERE/tagpush
bk edit $Q file
bk delta -ywww $Q file
echo 't.tag' > SCCS/t.ChangeSet
echo 't.tag2' >> SCCS/t.ChangeSet
echo 'I am a tag with spaces' >> SCCS/t.ChangeSet
bk commit $Q -ywhatever 
test -f SCCS/t.ChangeSet && {
	echo failed to remove t.ChangeSet after commit
	exit 1
}
grep -q '^.cSt.tag' SCCS/s.ChangeSet || {
	echo failed to add tag to ChangeSet file
	exit 1
}
grep -q '^.cSt.tag2' SCCS/s.ChangeSet || {
	echo failed to add tag2 to ChangeSet file
	exit 1
}
grep -q '^.cSI am a tag with spaces' SCCS/s.ChangeSet || {
	echo failed to add I am a tag with spaces to ChangeSet file
	exit 1
}
echo OK

# Test the case where the same tag is on multiple entries on each side.
# It should find the last one on each side.
echo $N Test propogation of a tag added with a commit, pick remote ..$NL
cd $HERE/tagpush
bk edit $Q file
bk delta -ywww $Q file
bk commit $Q -ywhatever -Ssame_tag
cd $HERE/tagchild
bk pull $Q || {
	echo pull failed
	exit 1
}
# Now alternate between sides
for  i in 1 2 3
do	for dir in tagpush tagchild
	do	cd $HERE/$dir
		bk edit $Q file
		bk delta -ywww $Q file
		bk commit $Q -ywhatever -Ssame_tag
	done
done
cd $HERE
tar cf tagchild.TAR tagchild
cd $HERE/tagchild
#  ( echo ""
#   echo x
#   echo p
#   echo t
#   echo q
#   ) | bk pull
echo r | bk pull $Q 2>/dev/null
test -d RESYNC && {
	echo failed to resolve
	exit 1
}
test X`bk prs -hr1.5.1.3 -nd:TAG: ChangeSet` = Xsame_tag || {
	echo Failed to add tag to tip of branch, 1.5.1.3
	bk prs ChangeSet
	exit 1
}
echo OK
#bk revtool

echo $N Test propogation of a tag added with a commit, pick merge ...$NL
cd $HERE
rm -rf tagchild
tar xf tagchild.TAR
cd $HERE/tagchild
echo m | bk pull $Q 2>/dev/null
test -d RESYNC && {
	echo failed to resolve
	exit 1
}
test X`bk prs -hr+ -nd:TAG: ChangeSet` = Xsame_tag || {
	echo Failed to add tag to merge
	bk prs ChangeSet
	exit 1
}
echo OK
#bk revtool

echo $N Tag conflict only, try to choose merge, should fail .........$NL
cd $HERE
cd $HERE/tagpush
bk tag $Q -r1.3 old_tag
cd $HERE/tagchild
bk tag $Q -r1.4 old_tag
( echo ""
  echo x
  echo m
  echo q
) | bk pull $Q 2>OUT 
test -d RESYNC || {
	echo should have failed to resolve
	cat OUT
	exit 1
}
echo OK

echo $N Choose local, should work fine. .............................$NL
( echo ""
  echo x
  echo l
  echo q
) | bk resolve $Q 2>OUT 
test -d RESYNC && {
	echo failed to resolve
	cat OUT
	exit 1
}
echo OK


# Create a repository
# clone it
# tag it
# opush the tag

#echo $N Create the same tag in a new place ..........................$NL
#cd $HERE/copy/src
#bk get $Q -e 'F!O#O$ B%A^R&RR(R)RR'
#echo delta two >> 'F!O#O$ B%A^R&RR(R)RR'
#bk delta $Q -yopush_cset 'F!O#O$ B%A^R&RR(R)RR'
#bk commit $Q -yopush_cset -STAG2
#echo OK
