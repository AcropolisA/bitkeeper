# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.


# Copyright (c) 2004 adi@bitmover.com
# %K%

echo $N Create initial repository ...................................$NL
commercial project
echo foo > f
BK_USER=adam bk delta -f $Q -i -y'Initial checkin' f
BK_USER=adam bk commit $Q -y'Initial checkin' || fail
bk edit $Q f
BK_USER=second bk delta -f $Q -y'Second checkin' f
BK_USER=second bk commit $Q --tag=second -y'Second checkin' || fail
bk edit $Q f
BK_USER=third bk delta -f $Q -y'Third checkin' f
BK_USER=third bk commit $Q --tag=third -y'Third checkin' || fail
echo OK

echo $N Test basic takepatch ........................................$NL
cd "$HERE"
bk clone $Q -r1.2 project clone1
cd project
bk makepatch $Q -d -r1.2..+ > "$HERE/patch" || fail
cd "$HERE/clone1"
bk lease flush -a
bk takepatch $Q < "$HERE/patch" || fail
test -d RESYNC -a -d PENDING || fail
bk abort -f || fail
echo OK

echo $N Test basic takepatch with copying sfiles to resync ..........$NL
_BK_COPY_SFILE=YES bk takepatch -j3 -q < "$HERE/patch" || fail
test -d RESYNC -a -d PENDING || fail
grep -q "takepatch --Nway = 0 _BK_COPY_SFILE=YES" BitKeeper/log/cmd_log \
    || fail
bk abort -f || fail
echo OK

echo $N Test basic takepatch -a .....................................$NL
bk takepatch $Q -a < "$HERE/patch" || fail
bk changes -aqL > c1 || fail
test -s c1 && {
       echo "unexpected output from changes -L:"
       cat c1
       exit 1
}
bk changes -aqR > c2 || fail
test -s c2 && {
       echo "unexpected output from changes -R:"
       cat c2
       exit 1
}
echo OK

echo $N Do another takepatch, verify no output ......................$NL
cd "$HERE/clone1"
bk takepatch -a < "$HERE/patch" > e1 2>&1 || {
	echo "takepatch exited with $?" >&2
	exit 1;
}
test -s e1 && {
	echo
	echo "Unexpected output from takepatch:"
	cat e1
	exit 1
}
echo OK

echo $N Make a patch with a tag and verify that the tag moved .......$NL
cd "$HERE/project"
bk tag $Q TIP
bk makepatch $Q -r+ > "$HERE/patch"
cd ../clone1
bk takepatch -a < "$HERE/patch" > e1 2>&1 || {
	echo "takepatch exited with $?" >&2
	exit 1;
}
test -s e1 && {
	echo
	echo "Unexpected output from takepatch:"
	cat e1
	exit 1
}
bk changes -aqL > c1 || fail
test -s c1 && {
       echo "unexpected output from changes -L:"
       cat c1
       exit 1
}
bk changes -aqR > c2 || fail
test -s c2 && {
       echo "unexpected output from changes -R:"
       cat c2
       exit 1
}
echo OK

echo $N Check that missing ChangeSet in RESYNC is dealt with ........$NL
echo foo > foo
bk new $Q foo
bk commit $Q -y'Added foo'
bk makepatch -r+ > P
bk stripdel $Q -C -r+ foo
bk takepatch -a < P 2>ERR || {
	echo failed
	cat ERR
	exit 1
}
echo OK

# Test fast pull code paths
# Set up two csets - new files in the first and updates in the second
# This is so I can do a patch which is just the second in a pull and
# see that there is no sfio in the patch in the merge case.

echo $N Set up a patch new, BAM and many deltas .....................$NL
cd "$HERE"
rm -fr project copy
commercial project
touch start-as-sfile send-as-deltas
bk new $Q start-as-sfile send-as-deltas || fail
bk commit $Q --tag=BASE -yfooze || fail
cd ..
bk clone $Q project copy || fail
cd project
echo BAMBAM > BAM
bk new $Q -b BAM || fail
touch newfile
bk new $Q newfile || fail
bk commit $Q --tag=FIRST -y'new BAM and plain file' || fail
bk mv start-as-sfile send-as-sfile
bk edit $Q send-as-sfile send-as-deltas || fail
# 9 is the internal baseline for largest that passes as a patch
for i in 1 2; do
	bk delta $Q -l -f -ymkdeltas send-as-deltas send-as-sfile || fail
done
bk unedit $Q send-as-sfile send-as-deltas || fail
bk commit $Q --tag=SECOND -y'deltas to existing files' || fail
bk makepatch $Q -rBASE..+ -M3 > ../PATCH3 || fail
bk makepatch $Q -B -rBASE..+ -M3 > ../BPATCH3 || fail
bk send $Q -rBASE..+ - > ../SEND || fail
cd ..
tar cf copy.tar copy
echo OK

echo $N Make sure that a patch containing rename works ..............$NL
bk clone $Q -r1.3 project clone-rename
cd project
bk makepatch -r1.3.. > ../PATCH
cd ../clone-rename
bk takepatch -f../PATCH || {
	echo takepatch failed
	exit 1
}
cd ..
rm -rf clone-rename
echo OK

echo $N Takepatch with varying number of -vvv gives known response ..$NL
cd copy
for m in "" -m; do
    for v in "" -v -vv -vvv; do
	test -d RESYNC && bk abort -f
	BK_NOTTY= bk --config=parallel:0 \
	    takepatch $v $m < ../PATCH3 2> LOG$m$v || fail
	perl -pe '1 while s/[^\010]\010//g' < LOG$m$v > LOG$m$v-filt
    done
done
test -s LOG && { echo no m or v not empty; cat LOG; exit 1; }
test -s LOG-m && { echo dash m not empty; cat LOG-m; exit 1; }
PENDING=`find PENDING -type f -print`
#
cat <<EOF > WANT
---------------------------------------------------------------------------
takepatch: saved entire patch in $PENDING
---------------------------------------------------------------------------
takepatch: 2 new changesets, 0 conflicts in 5 files
EOF
cmpfiles WANT LOG-v
#
cat <<EOF > WANT
---------------------------------------------------------------------------
takepatch: saved entire patch in $PENDING
---------------------------------------------------------------------------
takepatch: 2 new changesets, 0 conflicts in 5 files
EOF
cmpfiles WANT LOG-m-v-filt
#
cat <<EOF > WANT
Updating ChangeSet
Updating send-as-deltas
Updating BAM
Updating newfile
Updating send-as-sfile
---------------------------------------------------------------------------
takepatch: saved entire patch in $PENDING
---------------------------------------------------------------------------
takepatch: 2 new changesets, 0 conflicts in 5 files
EOF
cmpfiles WANT LOG-vv
#
cat <<EOF > WANT
Updating ChangeSet
Updating send-as-deltas
Updating BAM
Updating newfile
Updating send-as-sfile
---------------------------------------------------------------------------
takepatch: saved entire patch in $PENDING
---------------------------------------------------------------------------
takepatch: 2 new changesets, 0 conflicts in 5 files
EOF
cmpfiles WANT LOG-m-vv-filt

cat <<EOF > WANT
Updating ChangeSet, renumbering, checking checksums
Updating send-as-deltas
Updating BAM
Updating newfile
Updating send-as-sfile
---------------------------------------------------------------------------
takepatch: saved entire patch in $PENDING
---------------------------------------------------------------------------
takepatch: 2 new changesets, 0 conflicts in 5 files
EOF
cmpfiles WANT LOG-vvv-filt

cat <<EOF > WANT
Updating ChangeSet, renumbering, checking checksums
Updating send-as-deltas
Updating BAM
Updating newfile
Updating send-as-sfile
---------------------------------------------------------------------------
takepatch: saved entire patch in $PENDING
---------------------------------------------------------------------------
takepatch: 2 new changesets, 0 conflicts in 5 files
EOF
cmpfiles WANT LOG-m-vvv-filt
echo OK

echo $N Renamed sfio file has correct m file with it ................$NL
bk _test -f RESYNC/SCCS/m.send-as-sfile || { echo failed; exit 1; }
echo "rename SCCS/s.start-as-sfile|SCCS/s.start-as-sfile|SCCS/s.send-as-sfile" \
    > WANT
cmpsfiles RESYNC/SCCS/m.send-as-sfile WANT
echo OK

echo $N Resolve fails a makepatch - takepatch because no BAM ........$NL
bk resolve -a 2>ERR && fail
grep -q "Failed to locate BAM data for the following deltas" ERR || fail
echo OK

echo $N Resolve of a takepatch of send-generated-patch works ........$NL
bk abort -f
bk takepatch < ../SEND || fail
bk resolve $Q -a || fail
bk get $Q BAM || fail
echo BAMBAM > WANT
cmpfiles BAM WANT
echo OK

echo $N Resolve of a takepatch of makepatch -B -M3 patch works ......$NL
# This example packs both sfio and sfiles in the sfio
cd ..
rm -fr copy
tar xf copy.tar
cd copy || fail
bk takepatch < ../BPATCH3 || fail
bk resolve $Q -a || fail
bk get $Q BAM || fail
echo BAMBAM > WANT
cmpfiles BAM WANT
echo OK

echo $N Pull of newfiles contains SFIO whether local work or not ....$NL
cd ..
rm -fr copy
tar xf copy.tar
cd copy || fail
bk pull $Q -RrFIRST || fail
mv PENDING/* update.patch
rm -fr PENDING RESYNC
touch localfile
bk new $Q localfile || fail
bk commit $Q -ylocal-cset || fail
bk pull $Q -RrFIRST || fail
mv PENDING/* merge.patch
rm -fr PENDING RESYNC
cmpfiles update.patch merge.patch
grep -q SFIO update.patch || fail
echo OK

echo $N Pull of modifications contains SFIO in update case only .....$NL
cd ..
rm -fr copy
tar xf copy.tar
cd copy || fail
bk pull $Q -rFIRST || fail
_BK_NO_FASTPATCH=1 BK_NOTTY= bk pull -R -v > OUT 2> SPINNERCHECK || fail
mv PENDING/* update.patch
rm -fr PENDING RESYNC
bk edit $Q newfile
echo stuff > newfile
bk delta $Q -ycontent newfile || fail
bk commit $Q -ynewcontent || fail
_BK_NO_FASTPATCH=1 bk pull $Q -R || fail
mv PENDING/* merge.patch
rm -fr PENDING RESYNC
grep -q SFIO update.patch || fail
grep -q SFIO merge.patch && fail
echo OK

echo $N Resolve SFIO content when it seems the file rolled back .....$NL
# The patch has 2 csets, the repo has the first one already
# The local repo adds content to 'newfile' so the RESYNC will
# have an SCCS/s.newfile without that change
bk takepatch < ../BPATCH3 2>ERR && {
	echo expect takepatch to fail
	exit 1
}
grep -q "key.* not found in sfile RESYNC/SCCS/s.newfile" ERR || fail
# still a failure
echo "failed (bug -- when adding a change already there)"

echo $N Create a hole in the serials in the table ...................$NL
# 1.1 - 1.2 ------ 1.3 ---------- 1.4 -- 1.5 -- (1.6)
#    \                                         /
#     +--- 1.1.1.1 ----- (1.1.1.2) ---------- +
#
# The parens ones aren't there after the second pull (the -R one)
# The unpull removes the lower line and 1.6, but leaves gaps in the table
# Then a pull -r1.1.1.1(equiv) causes 1.5 to get renumbered out of the
# ser2dsize range, and causes 1.4 to appear in the table twice.
# If there were asserts/tests in place, it would have caught it.
# 
cd "$HERE"
commercial branch
bk clone $Q . ../trunk
cd ../trunk
# For my own
touch 1
bk new $Q 1
bk commit $Q -y1.2
cd ../branch
touch 2 
bk new $Q 2
bk commit $Q --tag=TAG -y1.1.1.1
cd ../trunk
touch 3 
bk new $Q 3
bk commit $Q -y1.3
cd ../branch
touch 4
bk new $Q 4
bk commit $Q -y1.1.1.2
cd ../trunk
touch 5
bk new $Q 5
bk commit $Q -y1.4
touch 6
bk new $Q 6
bk commit $Q -y1.5
bk pull $Q
bk unpull $Q -fs
bk pull -R -rTAG $Q || fail
echo OK

echo $N Fun with Monotonia ..........................................$NL
cd "$HERE"
rm -fr copy
tar xf copy.tar
cd copy
bk admin $Q -fMONOTONIC start-as-sfile
bk edit $Q start-as-sfile
bk delta $Q -fyfoo start-as-sfile
# bk pull $Q 2> FIRSTERR && fail
BK_CONFIG=monotonic:allow bk commit $Q -ymono
BK_CONFIG=monotonic:allow bk undo $Q -sfr+
bk pull $Q 2> ERR && fail
grep -q 'monotonic file .* has dangling' ERR || fail
rm -fr PENDING RESYNC
# the new takepatch fails the same way
_BK_NO_PATCHSFIO=1 bk pull $Q 2> ERR && fail
grep -q 'monotonic file .* has dangling' ERR || fail
echo "failed (bug -- we just don't update danglers well)"

echo $N Check takepatch checking checksum in sccs_delta .............$NL
cd "$HERE"
_commercial_config > c
bk setup -a -f --sccs-compat -cc no-blob || fail
cd no-blob
echo abcde > foo
bk new $Q foo
bk commit $Q -yfoo
bk clone $Q . ../checksum
bk edit $Q foo
echo abbde > foo
bk delta $Q -yfoo foo
bk commit $Q -yfoo
bk _scat foo | sed s/abbde/abcde/ > newfoo
bk _mv newfoo SCCS/s.foo
bk admin -z foo
cd ../checksum
bk pull $Q -R 2> ERR && fail -f ERR 1
grep -q "Bad checksum 00504:00505 in" ERR || fail -f ERR 2
echo OK

sanitize() {
	# filter out the file name from the key
	perl -i.old -pe 's? bk/[^|]*\|([^|]*)\S+\d\b? <$1>?' $1
	rm -f $1.old
}

echo $N Test patch delta exists but with different parent ...........$NL
# commercial project
cd "$HERE"/project
echo zero > collide
bk new $Q collide
bk edit $Q collide
echo one > collide
bk delta $Q -fycollide collide
bk commit $Q -f
bk clone $Q . ../dup-copy
bk clone $Q . ../merge
bk edit $Q collide
echo two > collide
bk delta $Q -fycollide collide
bk edit $Q collide
echo dup > collide
_BK_NO_UNIQ=1 BK_DATE_TIME_ZONE="2037-02-02 02:02:02-02" \
    bk delta $Q -fydup collide
bk commit $Q -f
cd ../dup-copy
bk edit $Q collide
echo dup > collide
_BK_NO_UNIQ=1 BK_DATE_TIME_ZONE="2037-02-02 02:02:02-02" \
    bk delta $Q -fydup collide
bk commit $Q -f
bk pull -qR 2> GOT
sanitize GOT
cat <<EOF > WANT
RESYNC/collide: duplicate delta with different parents
local parent: 1.2
remote parent: <collide> (remote)
local merge: none
remote merge: none ()
Please send the output to support@bitmover.com
==============================================================================
Pull failed: takepatch exited 1.
EOF
cmpfiles WANT GOT
cd ../project
bk pull -qR ../dup-copy 2> GOT
sanitize GOT
cat <<EOF > WANT
RESYNC/collide: duplicate delta with different parents
local parent: 1.3
remote parent: <collide> (1.2)
local merge: none
remote merge: none ()
Please send the output to support@bitmover.com
==============================================================================
Pull failed: takepatch exited 1.
EOF
cmpfiles WANT GOT
echo OK

echo $N Test patch delta exists but with different merge ............$NL
cd "$HERE"/merge
bk _get $Q -e -r1.1 collide
echo merge one > collide
bk delta $Q -fycollide collide
bk edit $Q -M collide
echo some merge > collide
bk delta $Q -fycollide collide
bk commit $Q -f
bk clone $Q . ../merge-copy
bk _get $Q -e -r1.1.1 collide
echo merge base > collide
bk delta $Q -fycollide collide
bk edit $Q -M collide
echo some dup merge > collide
_BK_NO_UNIQ=1 BK_DATE_TIME_ZONE="2037-02-02 02:02:02-02" \
    bk delta $Q -fydup collide
bk commit $Q -f
cd ../merge-copy
bk edit $Q -M1.1.1.1 collide
echo some dup merge > collide
_BK_NO_UNIQ=1 BK_DATE_TIME_ZONE="2037-02-02 02:02:02-02" \
    bk delta $Q -fydup collide
bk commit $Q -f
bk pull -qR 2> GOT
sanitize GOT
cat <<EOF > WANT
RESYNC/collide: duplicate delta with different parents
local parent: 1.3
remote parent: <collide> (1.3)
local merge: 1.1.1.1
remote merge: <collide> (remote)
Please send the output to support@bitmover.com
==============================================================================
Pull failed: takepatch exited 1.
EOF
cmpfiles WANT GOT
cd ../merge
bk pull -qR ../merge-copy 2> GOT
sanitize GOT
cat <<EOF > WANT
RESYNC/collide: duplicate delta with different parents
local parent: 1.3
remote parent: <collide> (1.3)
local merge: 1.1.1.2
remote merge: <collide> (1.1.1.1)
Please send the output to support@bitmover.com
==============================================================================
Pull failed: takepatch exited 1.
EOF
cmpfiles WANT GOT
echo OK

# take a patch which has \r in it
test -f "$TESTDATA/linux-patch-with-cr" && {
echo $N Test taking a patch with carriage returns in it .............$NL
# Old bk would put \r in a file into the 1.1 delta
cd "$HERE/project"
bk takepatch < "$TESTDATA/linux-patch-with-cr" || fail
bk takepatch < "$TESTDATA/linux-patch-with-cr.compat" || fail
echo OK
}

# No test up to here creates a merge, so adding another test
echo $N Test bk undo style patches with empty merge node ............$NL
cd "$HERE"
commercial mergeproject
bk clone $Q . ../mergecopy
touch foo
bk new $Q -l foo
bk commit $Q -f --tag=BASE
cd ../mergecopy
touch bar
bk new $Q -l bar
bk commit $Q -f
bk pull $Q
bk cset -Bfm -rBASE.. > ../patch
cd ../mergeproject
bk takepatch < ../patch
cd RESYNC
bk check ChangeSet || fail -f ERR
echo OK
