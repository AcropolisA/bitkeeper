# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.


# Copyright (c) 2004 adi@bitmover.com
# %K%

echo $N Create initial repository ...................................$NL
commercial project
echo foo > f
BK_USER=adam bk delta -f $Q -i -y'Initial checkin' f
BK_USER=adam bk commit $Q -y'Initial checkin' || exit 1
bk edit $Q f
BK_USER=second bk delta -f $Q -y'Second checkin' f
BK_USER=second bk commit $Q --tag=second -y'Second checkin' || exit 1
bk edit $Q f
BK_USER=third bk delta -f $Q -y'Third checkin' f
BK_USER=third bk commit $Q --tag=third -y'Third checkin' || exit 1
echo OK

echo $N Test basic takepatch ........................................$NL
cd "$HERE"
bk clone $Q -r1.2 project clone1
cd project
bk makepatch $Q -d -r1.2..+ > "$HERE/patch" || exit 1
cd "$HERE/clone1"
bk lease flush -a
bk takepatch $Q < "$HERE/patch" || exit 1
test -d RESYNC -a -d PENDING || exit 1
bk abort -f || exit 1
echo OK

echo $N Test basic takepatch -a .....................................$NL
bk takepatch $Q -a < "$HERE/patch" || exit 1
bk changes -aqL > c1 || exit 1
test -s c1 && {
       echo "unexpected output from changes -L:"
       cat c1
       exit 1
}
bk changes -aqR > c2 || exit 1
test -s c2 && {
       echo "unexpected output from changes -R:"
       cat c2
       exit 1
}
echo OK

echo $N Do another takepatch, verify no output ......................$NL
cd "$HERE/clone1"
bk takepatch -a < "$HERE/patch" > e1 2>&1 || {
	echo "takepatch exited with $?" >&2
	exit 1;
}
test -s e1 && {
	echo
	echo "Unexpected output from takepatch:"
	cat e1
	exit 1
}
echo OK

echo $N Make a patch with a tag and verify that the tag moved .......$NL
cd "$HERE/project"
bk tag $Q TIP
bk makepatch $Q -r+ > "$HERE/patch"
cd ../clone1
bk takepatch -a < "$HERE/patch" > e1 2>&1 || {
	echo "takepatch exited with $?" >&2
	exit 1;
}
test -s e1 && {
	echo
	echo "Unexpected output from takepatch:"
	cat e1
	exit 1
}
bk changes -aqL > c1 || exit 1
test -s c1 && {
       echo "unexpected output from changes -L:"
       cat c1
       exit 1
}
bk changes -aqR > c2 || exit 1
test -s c2 && {
       echo "unexpected output from changes -R:"
       cat c2
       exit 1
}
echo OK

echo $N Check that missing ChangeSet in RESYNC is dealt with ........$NL
echo foo > foo
bk new $Q foo
bk commit $Q -y'Added foo'
bk makepatch -r+ > P
bk stripdel $Q -C -r+ foo
bk takepatch -a < P 2>ERR || {
	echo failed
	cat ERR
	exit 1
}
echo OK

# Test fast pull code paths
# Set up two csets - new files in the first and updates in the second
# This is so I can do a patch which is just the second in a pull and
# see that there is no sfio in the patch in the merge case.

echo $N Set up a patch new, BAM and many deltas .....................$NL
cd "$HERE"
rm -fr project copy
commercial project
touch start-as-sfile send-as-deltas
bk new $Q start-as-sfile send-as-deltas || exit 1
bk commit $Q --tag=BASE -yfooze || exit 1
cd ..
bk clone $Q project copy || exit 1
cd project
echo BAMBAM > BAM
bk new $Q -b BAM || exit 1
touch newfile
bk new $Q newfile || exit 1
bk commit $Q --tag=FIRST -y'new BAM and plain file' || exit 1
bk mv start-as-sfile send-as-sfile
bk edit $Q send-as-sfile send-as-deltas || exit 1
# 9 is the internal baseline for largest that passes as a patch
for i in 1 2; do
	bk delta $Q -l -f -ymkdeltas send-as-deltas send-as-sfile || exit 1
done
bk unedit $Q send-as-sfile send-as-deltas || exit 1
bk commit $Q --tag=SECOND -y'deltas to existing files' || exit 1
bk makepatch $Q -rBASE..+ -M3 > ../PATCH3 || exit 1
bk makepatch $Q -B -rBASE..+ -M3 > ../BPATCH3 || exit 1
bk send $Q -rBASE..+ - > ../SEND || exit 1
cd ..
tar cf copy.tar copy
echo OK

echo $N Make sure that a patch containing rename works ..............$NL
bk clone $Q -r1.3 project clone-rename
cd project
bk makepatch -r1.3.. > ../PATCH
cd ../clone-rename
bk takepatch -f../PATCH || {
	echo takepatch failed
	exit 1
}
cd ..
rm -rf clone-rename
echo OK

echo $N Takepatch with varying number of -vvv gives known response ..$NL
cd copy
for m in "" -m; do
    for v in "" -v -vv -vvv; do
	test -d RESYNC && bk abort -f
	BK_NOTTY= bk takepatch $v $m < ../PATCH3 2> LOG$m$v || exit 1
	perl -pe '1 while s/[^\010]\010//g' < LOG$m$v > LOG$m$v-filt
    done
done
test -s LOG && { echo no m or v not empty; cat LOG; exit 1; }
test -s LOG-m && { echo dash m not empty; cat LOG-m; exit 1; }
PENDING=`find PENDING -type f -print`
#
cat <<EOF > WANT
---------------------------------------------------------------------------
takepatch: saved entire patch in $PENDING
---------------------------------------------------------------------------
takepatch: 2 new changesets, 0 conflicts in 5 files
EOF
cmpfiles WANT LOG-v
#
cat <<EOF > WANT
Receiving patch ... done.
---------------------------------------------------------------------------
takepatch: saved entire patch in $PENDING
---------------------------------------------------------------------------
takepatch: 2 new changesets, 0 conflicts in 5 files
EOF
cmpfiles WANT LOG-m-v-filt
#
cat <<EOF > WANT
---------------------------------------------------------------------------
takepatch: saved entire patch in $PENDING
---------------------------------------------------------------------------
Updating ChangeSet
Updating send-as-deltas
Updating BAM
Updating newfile
Updating send-as-sfile
takepatch: 2 new changesets, 0 conflicts in 5 files
EOF
cmpfiles WANT LOG-vv
#
cat <<EOF > WANT
Receiving patch ... done.
---------------------------------------------------------------------------
takepatch: saved entire patch in $PENDING
---------------------------------------------------------------------------
Updating ChangeSet
Updating send-as-deltas
Updating BAM
Updating newfile
Updating send-as-sfile
takepatch: 2 new changesets, 0 conflicts in 5 files
EOF
cmpfiles WANT LOG-m-vv-filt

cat <<EOF > WANT
---------------------------------------------------------------------------
takepatch: saved entire patch in $PENDING
---------------------------------------------------------------------------
Updating ChangeSet, renumbering, checking checksums
Updating send-as-deltas
Updating BAM
Updating newfile
Updating send-as-sfile
takepatch: 2 new changesets, 0 conflicts in 5 files
EOF
cmpfiles WANT LOG-vvv-filt

cat <<EOF > WANT
Receiving patch ... done.
---------------------------------------------------------------------------
takepatch: saved entire patch in $PENDING
---------------------------------------------------------------------------
Updating ChangeSet, renumbering, checking checksums
Updating send-as-deltas
Updating BAM
Updating newfile
Updating send-as-sfile
takepatch: 2 new changesets, 0 conflicts in 5 files
EOF
cmpfiles WANT LOG-m-vvv-filt
echo OK

echo $N Renamed sfio file has correct m file with it ................$NL
bk _test -f RESYNC/SCCS/m.send-as-sfile || { echo failed; exit 1; }
echo "rename SCCS/s.start-as-sfile|SCCS/s.start-as-sfile|SCCS/s.send-as-sfile" \
    > WANT
cmpsfiles RESYNC/SCCS/m.send-as-sfile WANT
echo OK

echo $N Resolve fails a makepatch - takepatch because no BAM ........$NL
bk resolve -a 2>ERR && exit 1
grep -q "Failed to locate BAM data for the following deltas" ERR || exit 1
echo OK

echo $N Resolve of a takepatch of send-generated-patch works ........$NL
bk abort -f
bk takepatch < ../SEND || exit 1
bk resolve $Q -a || exit 1
bk get $Q BAM || exit 1
echo BAMBAM > WANT
cmpfiles BAM WANT
echo OK

echo $N Resolve of a takepatch of makepatch -B -M3 patch works ......$NL
# This example packs both sfio and sfiles in the sfio
cd ..
rm -fr copy
tar xf copy.tar
cd copy || exit 1
bk takepatch < ../BPATCH3 || exit 1
bk resolve $Q -a || exit 1
bk get $Q BAM || exit 1
echo BAMBAM > WANT
cmpfiles BAM WANT
echo OK

echo $N Pull of newfiles contains SFIO whether local work or not ....$NL
cd ..
rm -fr copy
tar xf copy.tar
cd copy || exit 1
bk pull $Q -RrFIRST || exit 1
mv PENDING/* update.patch
rm -fr PENDING RESYNC
touch localfile
bk new $Q localfile || exit 1
bk commit $Q -ylocal-cset || exit 1
bk pull $Q -RrFIRST || exit 1
mv PENDING/* merge.patch
rm -fr PENDING RESYNC
cmpfiles update.patch merge.patch
grep -q SFIO update.patch || exit 1
echo OK

echo $N Pull of modifications contains SFIO in update case only .....$NL
cd ..
rm -fr copy
tar xf copy.tar
cd copy || exit 1
bk pull $Q -rFIRST || exit 1
_BK_NO_FASTPATCH=1 BK_NOTTY= bk pull -R -v > OUT 2> SPINNERCHECK || exit 1
mv PENDING/* update.patch
rm -fr PENDING RESYNC
bk edit $Q newfile
echo stuff > newfile
bk delta $Q -ycontent newfile || exit 1
bk commit $Q -ynewcontent || exit 1
_BK_NO_FASTPATCH=1 bk pull $Q -R || exit 1
mv PENDING/* merge.patch
rm -fr PENDING RESYNC
grep -q SFIO update.patch || exit 1
grep -q SFIO merge.patch && exit 1
echo OK

echo $N Resolve SFIO content when it seems the file rolled back .....$NL
# The patch has 2 csets, the repo has the first one already
# The local repo adds content to 'newfile' so the RESYNC will
# have an SCCS/s.newfile without that change
bk takepatch < ../BPATCH3 2>ERR && {
	echo expect takepatch to fail
	exit 1
}
grep -q "key.* not found in sfile RESYNC/SCCS/s.newfile" ERR || exit 1
# still a failure
echo "failed (bug -- when adding a change already there)"

echo $N Create a hole in the serials in the table ...................$NL
# 1.1 - 1.2 ------ 1.3 ---------- 1.4 -- 1.5 -- (1.6)
#    \                                         /
#     +--- 1.1.1.1 ----- (1.1.1.2) ---------- +
#
# The parens ones aren't there after the second pull (the -R one)
# The unpull removes the lower line and 1.6, but leaves gaps in the table
# Then a pull -r1.1.1.1(equiv) causes 1.5 to get renumbered out of the
# ser2dsize range, and causes 1.4 to appear in the table twice.
# If there were asserts/tests in place, it would have caught it.
# 
cd "$HERE"
commercial branch
bk clone $Q . ../trunk
cd ../trunk
# For my own
touch 1
bk new $Q 1
bk commit $Q -y1.2
cd ../branch
touch 2 
bk new $Q 2
bk commit $Q --tag=TAG -y1.1.1.1
cd ../trunk
touch 3 
bk new $Q 3
bk commit $Q -y1.3
cd ../branch
touch 4
bk new $Q 4
bk commit $Q -y1.1.1.2
cd ../trunk
touch 5
bk new $Q 5
bk commit $Q -y1.4
touch 6
bk new $Q 6
bk commit $Q -y1.5
bk pull $Q
bk unpull $Q -fs
bk pull -R -rTAG $Q || exit 1
echo OK

echo $N Fun with Monotonia ..........................................$NL
cd "$HERE"
rm -fr copy
tar xf copy.tar
cd copy
bk admin $Q -fMONOTONIC start-as-sfile
bk edit $Q start-as-sfile
bk delta $Q -fyfoo start-as-sfile
# bk pull $Q 2> FIRSTERR && exit 1
bk commit $Q -ymono
bk undo $Q -sfr+
bk pull $Q 2> ERR && exit 1
grep -q 'monotonic file .* has dangling' ERR || exit 1
rm -fr PENDING RESYNC
# the new takepatch fails the same way
_BK_NO_PATCHSFIO=1 bk pull $Q 2> ERR && exit 1
grep -q 'monotonic file .* has dangling' ERR || exit 1
echo "failed (bug -- we just don't update danglers well)"

echo $N Check takepatch checking checksum in sccs_delta .............$NL
cd "$HERE"
_commercial_config > c
bk setup -a -f --sccs-compat -cc no-blob || fail
cd no-blob
echo abcde > foo
bk new $Q foo
bk commit $Q -yfoo
bk clone $Q . ../checksum
bk edit $Q foo
echo abbde > foo
bk delta $Q -yfoo foo
bk commit $Q -yfoo
bk _scat foo | sed s/abbde/abcde/ > newfoo
bk _mv newfoo SCCS/s.foo
bk admin -z foo
cd ../checksum
bk pull $Q -R 2> ERR && fail -f ERR 1
grep -q "Bad checksum 504:505 in" ERR || fail -f ERR 2
echo OK
