# Copyright (c) 2006 BitMover
# %K%

_mtime() {
	bk _stat "$1" | awk -F\| '{print $10}'
}

TZ="GMT"
export TZ

# (generated with gnuism %s) TZ=GMT date -d "05/20/97 18:48:11" +%s
T11=864154091
T12=864154096
DTZ11="97/05/20 18:48:11+00:00"
DTZ12="97/05/20 18:48:16+00:00"

# (generated with gnuism %s) TZ=GMT date -d "09/22/98 16:23:31" +%s
T21=906481411
T22=906481414
DTZ21="98/09/22 16:23:31+00:00"
DTZ22="98/09/22 16:23:34+00:00"

# Future (generated with gnuism %s) TZ=GMT date -d "02/08/22 09:42:21" +%s
T31=1644313341
T32=1644313347
DTZ31="22/02/08 09:42:21+00:00"
DTZ32="22/02/08 09:42:27+00:00"

# Situations to test - hard linked clone don't roll forward

# use D_TIME limited to now

echo $N Create a repo for timestamp investigation ...................$NL
commercial project
bk _touch now
# Make 3 files: keyword, nokeyword, deltatime
echo %'K'% > keyword
echo foo > nokeyword
echo foo > deltatime
bk _touch -t $T11 keyword nokeyword deltatime
BK_DATE_TIME_ZONE="$DTZ12" bk new $Q keyword nokeyword
bk delta $Q -i -T deltatime
test -f keyword -o -f nokeyword -o -f deltatime && {
	echo failed
	ls
	exit 1
}
# setStime puts things 2 seconds behind tip delta
test $T12 -ge `_mtime SCCS/s.keyword`	|| { echo failed; exit 1; }
test $T12 -ge `_mtime SCCS/s.nokeyword`	|| { echo failed; exit 1; }
test $T11 -ge `_mtime SCCS/s.deltatime`	|| { echo failed; exit 1; }
echo OK

echo $N Test admin ..................................................$NL
bk clean
cp -f SCCS/s.keyword backup
# see that sfile age is known after admin -z
bk admin -z keyword
test $T12 -ge `_mtime SCCS/s.keyword` || { echo failed; exit 1; }
# make it older, test that it will bring it forward
bk _touch -t $T11 SCCS/s.keyword
bk admin -z keyword
test $T12 -ge `_mtime SCCS/s.keyword` || { echo failed; exit 1; }
# see that a new flag doesn't alter sfile
BK_DATE_TIME_ZONE="$DTZ22" bk admin $Q -fRCS keyword
test $T12 -ge `_mtime SCCS/s.keyword` || { echo failed; exit 1; }
# however, flag will affect -T time
bk get $Q -T keyword
test $T22 -eq `_mtime keyword` || { echo failed; exit 1; }
# Test that having the gfile older will push the sfile back
bk _touch -t $T11 keyword
bk admin $Q -FRCS keyword
test $T11 -eq `_mtime keyword`		|| { echo failed; exit 1; }
test $T11 -ge `_mtime SCCS/s.keyword`	|| { echo failed; exit 1; }
# and admin -z will leave everything alone
test $T11 -eq `_mtime keyword`		|| { echo failed; exit 1; }
test $T11 -ge `_mtime SCCS/s.keyword`	|| { echo failed; exit 1; }
bk admin -z keyword
# restore
rm -f SCCS/s.keyword keyword
mv -f backup SCCS/s.keyword
echo OK

echo $N Test check will fix things that are off .....................$NL
# check - should fix things when amiss, and gack if _BK_DEVELOPER
bk get $Q -T keyword
bk _touch -t $T22 SCCS/s.keyword
test -n "$_BK_DEVELOPER" && OLDEV="$_BK_DEVELOPER"
_BK_DEVELOPER=1
export _BK_DEVELOPER
bk check keyword 2> ERR && { echo expected check to fail; exit 1; }
grep -q "timestamp keyword" ERR || { echo bad error message; cat ERR; exit 1; }
unset _BK_DEVELOPER
bk check keyword || exit 1
test -n "$OLDEV" && {
	_BK_DEVELOPER="$OLDEV"
	export _BK_DEVELOPER
}
test $T12 -ge `_mtime SCCS/s.keyword` || { echo failed; exit 1; }
bk clean keyword
echo OK

# checksum - calls admin - no new deltas, but breaks hardlinks
# XXX not tested

echo $N Test chmod will move things forward .........................$NL
# chmod - touchs gfile to now.  this adds delta, which ups sfile time.
cp -f SCCS/s.keyword backup
bk edit $Q keyword
bk _touch -t $T11 keyword
BK_CONFIG='checkout:edit!' BK_DATE_TIME_ZONE="$DTZ22" bk chmod +x keyword
test $T22 -ge `_mtime SCCS/s.keyword`	|| { echo failed 1; exit 1; }
test `_mtime keyword` -ge `_mtime now`	|| {
	echo failed 2
	echo $T11
	_mtime keyword
	_mtime now
	ls -l keyword now
	bk log keyword
	exit 1
}
bk unedit keyword
rm -f SCCS/s.keyword
mv -f backup SCCS/s.keyword
echo OK

echo $N Test ci / delta with -u, -l, nothing, -T, etc. ..............$NL
# ci/delta - with -u/-l, other wise, no gfile
cp -f SCCS/s.keyword backup
cp -f SCCS/s.nokeyword nobackup
# nothing
bk edit $Q keyword
echo foo >> keyword
bk _touch -t $T21 keyword
BK_DATE_TIME_ZONE="$DTZ22" bk delta $Q -yfoo keyword
test -f keyword && exit 1
test $T22 -ge `_mtime SCCS/s.keyword`	|| { echo failed; exit 1; }
# -u - with keyword expansion
bk edit $Q keyword
echo foo >> keyword
bk _touch -t $T21 keyword
BK_DATE_TIME_ZONE="$DTZ22" bk delta $Q -u -yfoo keyword
test -f keyword || exit 1
test $T22 -ge `_mtime SCCS/s.keyword`	|| { echo failed; exit 1; }
test `_mtime keyword` -ge `_mtime now`	|| { echo failed; exit 1; }
# -u - w/o keyword expansion -- like above, but could be just -l w/ a chmod
bk edit $Q nokeyword
echo foo >> nokeyword
bk _touch -t $T21 nokeyword
BK_DATE_TIME_ZONE="$DTZ22" bk delta $Q -u -yfoo nokeyword
test -f nokeyword || exit 1
test $T22 -ge `_mtime SCCS/s.nokeyword`		|| { echo failed; exit 1; }
test `_mtime nokeyword` -ge `_mtime now`	|| { echo failed; exit 1; }
# checkout:get - w/o keyword expansion -- like above
bk edit $Q nokeyword
echo foo >> nokeyword
bk _touch -t $T21 nokeyword
BK_CONFIG='checkout:get!' BK_DATE_TIME_ZONE="$DTZ22" \
    bk delta $Q -yfoo nokeyword
test -f nokeyword || exit 1
test $T22 -ge `_mtime SCCS/s.nokeyword`		|| { echo failed; exit 1; }
test `_mtime nokeyword` -ge `_mtime now`	|| { echo failed; exit 1; }
# -l - leaves gfile timestamp alone, so will move sfile back
bk edit $Q keyword
echo foo >> keyword
bk _touch -t $T21 keyword
BK_DATE_TIME_ZONE="$DTZ22" bk delta $Q -l -yfoo keyword
test -f keyword || exit 1
test $T21 -ge `_mtime SCCS/s.keyword`	|| { echo failed; exit 1; }
test $T21 -eq `_mtime keyword`		|| { echo failed; exit 1; }
# -G
echo foo >> keyword
bk _touch -t $T12 keyword
bk delta $Q -T -yfoo keyword
test $T12 -ge `_mtime SCCS/s.keyword`	|| { echo failed; exit 1; }
bk get $Q -T keyword
test $T12 -eq `_mtime keyword`		|| { echo failed; exit 1; }
# -G on a future delta clamps to now
bk edit $Q keyword
echo foo >> keyword
bk _touch -t $T31 keyword
bk delta $Q -l -T -yfoobar keyword 2> ERR
bk _touch newnow
grep -q "BK limiting the delta time" ERR || {
	echo wrong output; cat ERR; exit 1;
}
test $T31 -eq `_mtime keyword`		|| { echo failed; exit 1; }
test `_mtime newnow` -ge `_mtime SCCS/s.keyword` || { echo failed; exit 1; }
bk unedit keyword
bk get $Q -T keyword
test `_mtime newnow` -ge `_mtime keyword`	|| { echo failed; exit 1; }
rm -f newnow
mv -f backup SCCS/s.keyword
mv -f nobackup SCCS/s.nokeyword
echo OK

echo $N Test clean - should never move sfiles forward ...............$NL
# clean - no file, leave sfile alone (could be hard linked)
bk edit $Q keyword
bk _touch -t $T21 keyword
bk _touch -t $T11 SCCS/s.keyword
bk clean
test $T11 -eq `_mtime SCCS/s.keyword`	|| { echo failed; exit 1; }
echo OK

# clone (-l) (rlclone) - with and without -r -- should work
# here is a start..

echo $N Test clone checking out files according to delta time .......$NL
bk clean
bk commit $Q -y'get some files to clone'
cd "$HERE"
BK_CONFIG='checkout:get!' bk clone $Q -l project clone
# See that gfile has right delta time and sfile has not moved
cd clone
test -f keyword || { echo failed 5; exit 1; }
test $T12 -ge `_mtime SCCS/s.keyword`	|| { echo failed; exit 1; }
test $T12 -eq `_mtime keyword`		|| { echo failed; exit 1; }
cd ../project
echo OK

echo $N Test clone -l should not move sfile times forward ...........$NL
# if sfile moved forward, it could be newer than gfile in other repo
touch SCCS/s.keyword
bk get $Q -T keyword
# verify setup - gfile and sfile are newer than $T11
test $T11 -lt `_mtime SCCS/s.keyword`	|| { echo failed 1; exit 1; }
test $T11 -lt `_mtime keyword`		|| { echo failed 2; exit 1; }
bk _touch -t $T11 keyword SCCS/s.keyword
test $T11 -eq `_mtime SCCS/s.keyword`	|| { echo failed 3; exit 1; }
test $T11 -eq `_mtime keyword`		|| { echo failed 4; exit 1; }
cd "$HERE"
BK_CONFIG='checkout:get!' bk clone $Q -l project hardclone
# See that gfile has right delta time and sfile has not moved
cd hardclone
test -f keyword || { echo failed 5; exit 1; }
test $T11 -eq `_mtime SCCS/s.keyword`	|| { echo failed 6; exit 1; }
test $T12 -eq `_mtime keyword`		|| { echo failed 7; exit 1; }
cd ../project
# See that the time was not altered
test $T11 -eq `_mtime SCCS/s.keyword`	|| { echo failed 8; exit 1; }
test $T11 -eq `_mtime keyword`		|| { echo failed 9; exit 1; }
echo OK

echo $N Test co /get -T .............................................$NL
# co/get - -T or not.
bk clean
bk get $Q -T
# The gfiles should be predicable
test $T12 -eq `_mtime keyword`		|| { echo failed 1; exit 1; }
test $T12 -eq `_mtime nokeyword`	|| { echo failed 2; exit 1; }
test $T11 -eq `_mtime deltatime`	|| { echo failed 3; exit 1; }
# The sfiles should be older (get does not change time forward)
test `_mtime keyword` -ge `_mtime SCCS/s.keyword` || { echo failed 4; exit 1; }
test `_mtime nokeyword` -ge `_mtime SCCS/s.nokeyword` \
    || { echo failed 5; exit 1; }
test `_mtime deltatime` -ge `_mtime SCCS/s.deltatime` \
    || { echo failed 6; exit 1; }
# XXX: note that -TG (as well as export / gnupatch) move the s time back
bk clean keyword
bk _touch -r now SCCS/s.keyword
bk get $Q -TG keyword.copy keyword
test $T12 -eq `_mtime keyword.copy`	|| { echo failed 7; exit 1; }
test $T12 -ge `_mtime SCCS/s.keyword`	|| { echo failed 8; exit 1; }
rm -f keyword.copy
# make a future delta and see that we get the clamping we expect
# this is different than the -G test in co, because this uses env
# variable to actually make future delta.
# This simulates a clone from a machine/repo that is the future,
# and running 'checkout: get or edit' and getting current time files.
cp -f SCCS/s.keyword backup
bk edit $Q keyword
echo foo >> keyword
BK_DATE_TIME_ZONE="$DTZ32" bk delta $Q -ylater keyword
bk get $Q -T keyword
bk _touch newnow
test `_mtime keyword` -ge `_mtime now`		|| { echo failed 9; exit 1; }
test `_mtime newnow` -ge `_mtime keyword`	|| { echo failed 10; exit 1; }
bk get $Q -TG keyword.copy keyword
bk _touch newnow
test `_mtime keyword.copy` -ge `_mtime now`	|| { echo failed 11; exit 1; }
test `_mtime newnow` -ge `_mtime keyword.copy`	|| { echo failed 12; exit 1; }
rm -f newnow keyword.copy keyword SCCS/s.keyword
mv -f backup SCCS/s.keyword
echo OK

# comments - uses admin to re-write?
# commit - uses admin?
# cp - take a look
# cset - what might go wrong here?
# csetprune - uses admin to re-write?
# diffs (does a get of sorts) - leaves things alone (tests GET_DTIME)
# edit (get -e) - done
# export (should set times?  Not sfiles, but if -T, it does)
# grep (shouldn't touch things)
# import (patch does -G, others do straight up)
# makepatch (should leave things alone)
# pull/push - look here - mainly resolve

echo $N Test relink keeps the older time ............................$NL
cd "$HERE"
cp -rp project link1
cp -rp project link2
cd link1
bk _touch -t $T11 SCCS/s.keyword
cd ../link2
bk _touch -t $T21 SCCS/s.keyword
cd ..
bk relink $Q link1 link2
cd link1
test $T11 -ge `_mtime SCCS/s.keyword` || { echo failed; exit 1; }
echo OK

# resolve -- what does pass 4 do?

echo $N Test scompress modifies sfile only ..........................$NL
# scompress
bk _touch -r now SCCS/s.keyword
bk _scompress keyword
test $T12 -ge `_mtime SCCS/s.keyword` || { echo failed; exit 1; }
echo OK

# stripdel - rewrite sfiles, should clean or policy on gfile
# takepatch
# undo
# unedit

echo $N Test collapse with renames ..................................$NL
# collapse - leaves thing in an edited state - what about time?
echo hi > foo
bk new $Q -u foo || exit 1
bk commit $Q -y1 || exit 1
bk mv foo bar || exit 1
bk commit $Q -y2 || exit 1
bk edit $Q bar || exit 1
bk _touch -t $T11 bar || exit 1
bk collapse $Q -e || exit 1
test $T11 -ge `_mtime SCCS/s.bar` || exit 1
echo OK
