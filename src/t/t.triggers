# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

DASHA=
test X`uname -s` = XDarwin && DASHA=-a

echo $N Check commit trigger environment variables ..................$NL
cd $HERE
commercial project
bk edit $Q BitKeeper/etc/config
echo "checkout: get" >> BitKeeper/etc/config
bk delta $Q -ycheckout BitKeeper/etc/config
bk commit $Q -ycheckout
mkdir BitKeeper/triggers
cat > BitKeeper/triggers/pre-commit <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ | bk _sort > $HERE/pre-commit
exit 0
EOF
cat > BitKeeper/triggers/post-commit <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ | bk _sort > $HERE/post-commit
exit 0
EOF
chmod +x BitKeeper/triggers/*
echo h > h.h
bk ci $Q -i h.h
bk commit $S -a -yCset
grep -q BK_CSETS $HERE/pre-commit && {
	echo should not have defined BK_CSETS in pre-commit
	exit 1
}
grep -q BK_STATUS=OK $HERE/post-commit || {
	echo no/bad exit status
	cat $HERE/post-commit
	exit 1
}
grep -q "pre-commit returns 0" BitKeeper/log/cmd_log || {
	echo should have logged trigger
	exit 1
}
grep -q "post-commit returns 0" BitKeeper/log/cmd_log || {
	echo should have logged trigger
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-commit ==========
	cat $HERE/pre-commit
	echo ========== post-commit ==========
	cat $HERE/post-commit
}

echo $N Make sure commit can be told to fail and it does so nicely ..$NL
cat > BitKeeper/triggers/pre-commit <<EOF
#!/bin/bash
exit 1
EOF
chmod +x BitKeeper/triggers/*
echo c > c.c
bk ci $Q -i c.c
bk commit $S -a -yCset2 2>/dev/null && {
	echo failed to exit with an error status
	exit 1
}
if [ `bk sfiles -gp` != c.c ]
then	echo bad pending list
	exit 1
fi
echo OK

echo $N Check tag trigger environment variables without rev .........$NL
cd $HERE
tar cf TAR project
cd project
cat > BitKeeper/triggers/pre-tag <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ | bk _sort > $HERE/pre-tag
exit 0
EOF
chmod +x BitKeeper/triggers/pre-tag
bk tag $Q check_vars
grep -q BK_TAG=check_vars $HERE/pre-tag || {
	echo No BK_TAG in environment or wrong value
	exit 1
}
grep -q BK_TAG_REV $HERE/pre-tag && {
	echo Should not have set BK_TAG_REV
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-tag ==========
	cat $HERE/pre-tag
}

echo $N Check tag trigger environment variables with rev ............$NL
bk tag $Q -r1.1 primordial_ooze
grep -q BK_TAG=primordial_ooze $HERE/pre-tag || {
	echo No BK_TAG in environment or wrong value
	exit 1
}
grep -q BK_TAG_REV=1.1 $HERE/pre-tag || {
	echo Should have set BK_TAG_REV=1.1
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-tag ==========
	cat $HERE/pre-tag
}

echo $N Make sure tag can be told to fail and it does so nicely .....$NL
cat > BitKeeper/triggers/pre-tag <<EOF
#!/bin/bash
exit 1
EOF
chmod +x BitKeeper/triggers/*
bk tag foo && {
	echo failed to exit with an error status
	exit 1
}
echo OK
cd $HERE
rm -rf project
tar xf TAR
cd project

echo $N Make sure we get the list of pending files in pre-commit ....$NL
cat > BitKeeper/triggers/pre-commit <<EOF
#!/bin/bash 
cp \$BK_PENDING $HERE/BK_PENDING
exit 1
EOF
chmod +x BitKeeper/triggers/*
bk commit $S -a -yCset2 2>/dev/null && {
	echo failed to exit with an error status
	exit 1
}
test -f $HERE/BK_PENDING || {
	echo failed to copy the file
	exit 1
}
test SCCS/s.c.c${BK_FS}1.1 = `cat $HERE/BK_PENDING` || {
	echo bad file list
	cat $HERE/BK_PENDING
	exit 1
}
echo OK

echo $N Extract user from file list of pending deltas ...............$NL
test `bk prs -hd':USER:\n' - < $HERE/BK_PENDING` = bk || {
	echo can not extract user from file list
	exit 1
}
echo OK

echo $N Make sure commit succeeds when told it is OK ................$NL
cat > BitKeeper/triggers/pre-commit <<EOF
#!/bin/bash
exit 0
EOF
chmod +x BitKeeper/triggers/*
bk commit $S -a -yCset2 || {
	echo failed
	exit 1
}
echo OK

echo $N Make sure clone is passed the right variables ...............$NL
cat > BitKeeper/triggers/pre-outgoing <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ |
	grep -v _SEED= |
	grep -v _FEATURES |
	grep -v BK_LICENSE= |
 	grep -v BK_AUTH_HMAC=GOOD | bk _sort > $HERE/pre-outgoing
exit 1
EOF
cat > BitKeeper/triggers/post-outgoing <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ |
	grep -v _SEED= |
	grep -v BK_LICENSE= |
	grep -v _FEATURES |
	grep -v BK_AUTH_HMAC=GOOD | bk _sort > $HERE/post-outgoing
EOF
chmod +x BitKeeper/triggers/*
project_repoid=`bk identity -r`
cd $HERE
bk clone $Q project clone && {
	echo failed to exit with an error status
	exit 1
}
test -d clone && {
	echo should not have created repository
	exit 1
}
bk clone $Q -r1.1 project clone 
grep -q BK_CSETS=1.0..1.1 $HERE/pre-outgoing || {
	echo failed to put cset list in the env
	exit 1
}
rm project/BitKeeper/triggers/pre-outgoing
bk clone $Q -r1.1 project clone || {
	echo should have succeeded and did not
	exit 1
}
bk clone $Q -r1.1 project apply || {
	echo should have succeeded and did not
	exit 1
}
test -d clone || {
	echo should have created repository
	exit 1
}
grep -q BK_CSETS=1.0..1.1 $HERE/post-outgoing || {
	echo failed to put cset list in the env
	exit 1
}
grep BKD_REPO_ID= $HERE/post-outgoing > $HERE/tmp
fgrep "$project_repoid" $HERE/tmp > /dev/null || {
	echo "failed to record where we came from which is $project_repoid"
	cat $HERE/post-outgoing
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-outgoing clone ==========
	cat $HERE/pre-outgoing
	echo ========== post-outgoing clone ==========
	cat $HERE/post-outgoing
}

# win32 cannot support lclone
if [ "$PLATFORM" != "WIN32" ]
then #-----------------------------------------------------------------
echo $N Make sure clone -l is passed the right variables ............$NL
cd $HERE/project
cat > BitKeeper/triggers/pre-outgoing <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ |
	grep -v BK_LICENSE= |
	bk _sort > $HERE/pre-outgoing-l
exit 1
EOF
cat > BitKeeper/triggers/post-outgoing <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ |
	grep -v BK_LICENSE= |
	bk _sort > $HERE/post-outgoing-l
EOF
chmod +x BitKeeper/triggers/*
cd $HERE
bk clone -l $Q project lclone && {
	echo failed to exit with an error status
	exit 1
}
test -d lclone && {
	echo should not have created repository
	exit 1
}
bk clone $Q -l -r1.1 project lclone 
grep -q BK_CSETS=1.0..1.1 $HERE/pre-outgoing || {
	echo failed to put cset list in the env
	exit 1
}
rm project/BitKeeper/triggers/pre-outgoing
bk clone $Q -l -r1.1 project lclone || {
	echo should have succeeded and did not
	exit 1
}
test -d lclone || {
	echo should have created repository
	exit 1
}
grep -q BK_CSETS=1.0..1.1 $HERE/post-outgoing || {
	echo failed to put cset list in the env
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-outgoing clone -l ==========
	cat $HERE/pre-outgoing-l
	echo ========== post-outgoing clone -l ==========
	cat $HERE/post-outgoing-l
}

echo $N Make sure clone and clone -l have same pre-outgoing .........$NL
cmp -s $HERE/pre-outgoing $HERE/pre-outgoing-l || {
	echo failed
	diff $HERE/pre-outgoing $HERE/pre-outgoing-l
	exit 1
}
echo OK

echo $N Make sure clone and clone -l have same post-outgoing ........$NL
cmp -s $HERE/post-outgoing $HERE/post-outgoing-l || {
	echo failed
	diff $HERE/post-outgoing $HERE/post-outgoing-l
	exit 1
}
echo OK
fi #---------------------------------------------------------------------

# Make a post-incoming trigger be checked in, see if clone runs it.
echo $N Test post-incoming in a clone ...............................$NL
cd $HERE
cp -rp project parent
cd parent
rm -f BitKeeper/triggers/*
cat > BitKeeper/triggers/post-incoming <<EOF
#!/bin/bash
# ignore BK_REPO_ID because clone and clone-l had different ids
set | grep $DASHA ^BK | grep -v _BK_ |
    grep -v BK_IGNORELOCK |
    grep -v BKD_LEVEL |
    grep -v BK_REPO_ID |
    grep -v _FEATURES |
    grep -v BKD_LICTYPE |
    grep -v BKD_SEED= |
    grep -v BKD_SEED_OK=1 |
    bk _sort > $HERE/post-incoming-clone
exit 0
EOF
chmod +x BitKeeper/triggers/post-incoming
bk new $Q BitKeeper/triggers/post-incoming
bk commit $Q -ypost-incoming
cd $HERE
bk clone $Q parent clone2
test -f $HERE/post-incoming-clone || {
	echo failed to run post-incoming trigger
	exit 1
}
grep BKD_REPO_ID= $HERE/post-incoming-clone > $HERE/tmp
fgrep "$project_repoid" $HERE/tmp > /dev/null || {
	echo "failed to record where we came from which is $project_repoid"
	cat $HERE/post-incoming-clone
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== post-incoming clone ==========
	cat $HERE/post-incoming-clone
}

if [ "$PLATFORM" != "WIN32" ]
then #-----------------------------------------------------------------
# Make a post-incoming trigger be checked in, see if clone -l runs it.
echo $N Test post-incoming in a clone -l ............................$NL
cd $HERE/parent
bk edit $Q BitKeeper/triggers
cat > BitKeeper/triggers/post-incoming <<EOF
#!/bin/bash
set | grep $DASHA ^BK |
    grep -v _BK_ |
    grep -v BK_LICENSE= |  # leftover from pre-triggers (remove in 3.3.x)
    grep -v BK_REPO_ID |
    bk _sort > $HERE/post-incoming-clone-l
exit 0
EOF
chmod +x BitKeeper/triggers/post-incoming
bk delta -y-l $Q BitKeeper/triggers/post-incoming
bk commit $Q -ypost-incoming-l
cd $HERE
rm -rf clone2
bk clone -l $Q parent clone2
test -f $HERE/post-incoming-clone-l || {
	echo failed to run post-incoming trigger
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== post-incoming clone -l ==========
	cat $HERE/post-incoming-clone-l
}

echo $N Make sure clone and clone -l have same post-incoming ........$NL
cmp -s $HERE/post-incoming-clone $HERE/post-incoming-clone-l || {
	echo failed
	diff $HERE/post-incoming-clone $HERE/post-incoming-clone-l
	exit 1
}
echo OK
fi #-------------------------------------------------------------------
cd $HERE
rm -rf parent clone2

echo $N Make sure pull is passed the right variables ................$NL
cd $HERE/project
cat > BitKeeper/triggers/pre-outgoing <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ | bk _sort > $HERE/pre-outgoing
cp \$BK_CSETLIST $HERE/CSETS
exit 1
EOF
chmod +x BitKeeper/triggers/*
cd $HERE/clone
bk pull $Q && {
	echo failed to exit with an error status
	exit 1
}
grep -q BK_CSETLIST $HERE/pre-outgoing || {
	echo failed to put cset list file in the env
	cat $HERE/pre-outgoing
	exit 1
}
grep -q BK_LOCALCSETS=2 $HERE/pre-outgoing || 
grep -q BK_LOCALCSETS=3 $HERE/pre-outgoing || {
	echo failed to put local csets in the env
	cat $HERE/pre-outgoing
	exit 1
}
grep -q BK_REMOTECSETS=0 $HERE/pre-outgoing || {
	echo failed to put remote csets in the env
	cat $HERE/pre-outgoing
	exit 1
}
grep -q BK_LICENSE=$BKL_P $HERE/pre-outgoing || {
	echo didn\'t pass license
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC dir
	exit 1
}
echo OK

echo $N Make sure pre-incoming triggers fail the pull ...............$NL
rm $HERE/project/BitKeeper/triggers/pre-outgoing
cd $HERE/clone
mkdir BitKeeper/triggers
cat > BitKeeper/triggers/pre-incoming <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ | bk _sort > $HERE/pre-incoming
exit 1
EOF
chmod +x BitKeeper/triggers/*
bk pull $Q && {
	echo failed to exit non zero with failed pre-incoming trigger
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-incoming ==========
	cat $HERE/pre-incoming
}

echo $N Make sure pre-resolve triggers fail the pull ................$NL
cd $HERE/clone
rm BitKeeper/triggers/*
cat > BitKeeper/triggers/pre-resolve <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ | bk _sort > $HERE/pre-resolve
pwd > $HERE/PWD
exit 1
EOF
chmod +x BitKeeper/triggers/*
bk pull $Q && {
	echo failed to exit non zero with failed pre-resolve trigger
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -f $HERE/pre-resolve || {
	echo failed to call trigger
	exit 1
}
grep -q "pre-resolve returns 1" BitKeeper/log/cmd_log || {
	echo should have logged trigger
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-resolve ==========
	cat $HERE/pre-resolve
}

echo $N Make sure we can see the data in the pre-resolve trigger ....$NL
cat > BitKeeper/triggers/pre-resolve <<EOF
#!/bin/bash
bk changes - < \$BK_CSETLIST > $HERE/changes
cp \$BK_CSETLIST $HERE/csets-out
pwd > $HERE/resolve-pwd
exit 1
EOF
chmod +x BitKeeper/triggers/*
bk pull $Q && {
	echo failed to exit non zero with failed pre-incoming trigger
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -s $HERE/changes || {
	echo failed to create change list
	exit 1
}
grep -q ChangeSet@1.3 $HERE/changes || {
	echo failed to list the ChangeSet
	exit 1
}
GOT=`wc -l < $HERE/csets-out`
if [ $GOT -ne 2 -a $GOT -ne 3 ]; then
	echo csets-out contains extra junk
	cat $HERE/csets-out
	exit 1
fi
GOT=`grep '^ChangeSet' $HERE/changes | wc -l`
if [ $GOT -ne 2 -a $GOT -ne 3 ]; then
	echo listed extra changes
	exit 1
fi
echo OK

echo $N Make sure the pre-resolve trigger is run in RESYNC ..........$NL
grep -q RESYNC $HERE/resolve-pwd || {
	echo failed
	cat RESYNC $HERE/resolve-pwd
	exit 1
}
echo OK

echo $N Check bk changes -v - .......................................$NL
echo 1.1 > list
echo junk >> list
bk changes - < list > /dev/null 2>&1 && {
	echo failed to reject junk
	exit 1
}
echo 1.1 > list
echo \#junk >> list
echo >> list
bk changes - < list > out || {
	echo didn\'t ignore blanks and comments
	exit 1
}
if [ `grep '^ChangeSet' out | wc -l` -ne 1 ]; then
	echo returned extra junk
	exit 1
fi
echo OK

echo $N Make sure pre-apply exiting 1 cleans up .....................$NL
cd $HERE/apply
test -d BitKeeper/triggers || mkdir BitKeeper/triggers
cat > BitKeeper/triggers/pre-apply <<EOF
#!/bin/bash
set | grep $DASHA ^BK | grep -v _BK_ | bk _sort -u > $HERE/pre-apply
pwd > $HERE/apply-pwd
exit 1
EOF
chmod +x BitKeeper/triggers/*
bk pull $Q && {
	echo failed to exit non zero with failed pre-apply trigger
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -d PENDING && {
	echo failed to clean up PENDING
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-apply ==========
	cat $HERE/pre-apply
}

echo $N Make sure the pre-apply trigger is run in RESYNC ............$NL
grep -q RESYNC $HERE/apply-pwd || {
	echo failed
	cat RESYNC $HERE/apply-pwd
	exit 1
}
echo OK

echo $N Make sure pre-apply exiting 2 leaves patch in PENDING .......$NL
cd $HERE/apply
test -d BitKeeper/triggers || mkdir BitKeeper/triggers
cat > BitKeeper/triggers/pre-apply <<EOF
#!/bin/bash
exit 2
EOF
chmod +x BitKeeper/triggers/*
bk pull $Q && {
	echo failed to exit non zero with failed pre-apply trigger
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -d PENDING || {
	echo failed to leave PENDING
	exit 1
}
echo OK

echo $N Make sure pre-apply exiting 3 leaves RESYNC and PENDING .....$NL
cd $HERE/apply
test -d BitKeeper/triggers || mkdir BitKeeper/triggers
cat > BitKeeper/triggers/pre-apply <<EOF
#!/bin/bash
exit 3
EOF
chmod +x BitKeeper/triggers/*
bk pull $Q && {
	echo failed to exit non zero with failed pre-apply trigger
	exit 1
}
X="RESYNC-*"
test "$X" || {
	echo failed to leave RESYNC
	exit 1
}
test -d PENDING || {
	echo failed to leave PENDING
	exit 1
}
echo OK

BK_DEBUGX=yes
export BK_DEBUGX
echo $N Do it again to see that it can rename RESYNC twice ..........$NL
bk pull $Q && {
	echo failed to exit non zero with failed pre-apply trigger
	exit 1
}
test -d "RESYNC" && {
	echo failed to rename RESYNC
	exit 1
}
X="RESYNC-*"
test "$X" || {
	echo failed to leave RESYNC
	exit 1
}
test -d PENDING || {
	echo failed to leave PENDING
	exit 1
}
echo OK

echo $N Make sure that pushes do not prompt in pre-apply ............$NL
cd $HERE/apply
test -d BitKeeper/triggers || mkdir BitKeeper/triggers
# This is quoted so that I don't have to escape all the $VAR instances
# in the shell script.  Sigh.
bk base64 -d > BitKeeper/triggers/pre-apply <<EOF 
IyEvYmluL3NoCgp0ZXN0IGBiayBnZmlsZXMgQml0S2VlcGVyL3RyaWdnZXJzIHwg
d2MgLWxgIC1ndCAwIHx8IGV4aXQgMAppZiBbICRCS19TSURFID0gc2VydmVyIF0K
dGhlbiAgICBlY2hvIFJlZnVzaW5nIHRvIGFjY2VwdCBhbnkgY2hhbmdlcyB0byB0
cmlnZ2VycyBvbiBwdXNoLAogICAgICAgIGVjaG8gZ2V0IHRoZSBwcm9qZWN0IGFk
bWluIHRvIHB1bGwgeW91ciBjaGFuZ2VzLgogICAgICAgIGV4aXQgMQpmaQoKcm0g
LWYgQml0S2VlcGVyL3RtcC90X3JlamVjdApmb3IgaSBpbiBgYmsgZ2ZpbGVzIEJp
dEtlZXBlci90cmlnZ2Vyc2AKZG8gICAgICAoCiAgICAgICAgZWNobyBQbGVhc2Ug
cmV2aWV3IHRoZSBmb2xsb3dpbmcgdHJpZ2dlciBmb3Igc2VjdXJpdHkgcmlza3Mu
CiAgICAgICAgZWNobyBEbyBub3QgYWNjZXB0IGl0IGlmIHlvdSB0aGluayBpdCBp
cyBhIHByb2JsZW0uCiAgICAgICAgZWNobwogICAgICAgIGVjaG8gPT09PT0gJGkg
PT09PT0KICAgICAgICBiayBjYXQgJGkKICAgICAgICApID4gQml0S2VlcGVyL3Rt
cC9wcm9tcHQkJAogICAgICAgIGJrIHByb21wdCAtZkJpdEtlZXBlci90bXAvcHJv
bXB0JCQgLXQiUmV2aWV3IHRyaWdnZXIiIC15QWNjZXB0IC1uUmVqZWN0CiAgICAg
ICAgU1RBVFVTPSQ/CiAgICAgICAgcm0gLWYgQml0S2VlcGVyL3RtcC9wcm9tcHQk
JAogICAgICAgIHRlc3QgJFNUQVRVUyA9IDAgfHwgewogICAgICAgICAgICAgICAg
dG91Y2ggQml0S2VlcGVyL3RtcC90X3JlamVjdAogICAgICAgICAgICAgICAgYnJl
YWsKICAgICAgICB9CmRvbmUKdGVzdCAtZiBCaXRLZWVwZXIvdG1wL3RfcmVqZWN0
ICYmIHsKICAgICAgICBybSAtZiBCaXRLZWVwZXIvdG1wL3RfcmVqZWN0CiAgICAg
ICAgZXhpdCAzCn0Kcm0gLWYgQml0S2VlcGVyL3RtcC90X3JlamVjdApleGl0IDAK
EOF
chmod +x BitKeeper/triggers/*
cd $HERE
bk clone -q project new-trigger
test -d new-trigger/BitKeeper/triggers || mkdir new-trigger/BitKeeper/triggers
cd new-trigger/BitKeeper/triggers
cat > post-incoming-passwd <<EOF
#!/bin/bash

# I'm the bad trigger that will send the password file to the world
grep root /etc/passwd
EOF
chmod +x post-incoming-passwd
bk new $Q post-incoming-passwd
bk commit $Q -ypost-incoming-passwd
bk push $HERE/apply > OUT 2>&1 && {
	echo should have failed
	cat OUT
	exit 1
}
grep -q 'Refusing to accept any changes' OUT || {
	echo bad message
	cat OUT
	exit 1
}
echo OK

test "$TEST_GUI" && {
echo $N Make sure that pulls do prompt in pre-apply .................$NL
cd $HERE/apply
rm -rf PENDING RESYNC-*
# If you accept this then expect to see the root password
BK_MSG_GEOM=+200+200 BK_GUI=YES bk pull $Q $HERE/new-trigger
echo OK
ls -F 
echo
}

echo $N Make sure we can see the data in the post-incoming trigger ..$NL
cd $HERE/clone
rm BitKeeper/triggers/* $HERE/changes
cat > BitKeeper/triggers/post-incoming <<EOF
#!/bin/bash
bk changes - < \$BK_CSETLIST > $HERE/changes
set | grep $DASHA ^BK | grep -v _BK_ | bk _sort -u > $HERE/post-incoming
EOF
chmod +x BitKeeper/triggers/*
clone_repoid=`bk identity -r`
bk pull $Q || {
	echo failed to exit zero
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -s $HERE/changes || {
	echo failed to create change list
	exit 1
}
grep -q ChangeSet@1.3 $HERE/changes || {
	echo failed to list the ChangeSet
	exit 1
}
grep BKD_REPO_ID= $HERE/post-incoming > $HERE/tmp
fgrep "$project_repoid" $HERE/tmp > /dev/null || {
	echo failed to record where we came from
	exit 1
}
grep BK_REPO_ID= $HERE/post-incoming > $HERE/tmp
fgrep "$clone_repoid" $HERE/tmp > /dev/null || {
	echo failed to record where we are
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== post-incoming ==========
	cat $HERE/post-incoming
}

echo $N Fail a push in pre-incoming and make sure we clean up .......$NL
rm $HERE/pre-* $HERE/post-*
cd $HERE/project
rm BitKeeper/triggers/*
cat > BitKeeper/triggers/pre-incoming <<EOF
#!/bin/bash
echo I am the remote pre-incoming trigger and I am failing
set | grep $DASHA ^BK | grep -v _BK_ | bk _sort > $HERE/pre-incoming
exit 1
EOF
chmod +x BitKeeper/triggers/*
cd $HERE/clone
ls > LS
bk new $Q LS
bk commit -ywhatever $Q
bk push >OUT 2>&1 && {
	echo push should have failed
	exit 1
}
test -d ../project/RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -d ../project/PENDING && {
	echo failed to clean up PENDING
	exit 1
}
grep -q 'I am the remote pre-incoming trigger' OUT || {
	echo failed to pass back the trigger message
	cat OUT
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ====== pre-push-incoming ==========
	cat $HERE/pre-incoming
}

echo $N Make sure pull -R does not run post-incoming ................$NL
rm -f $HERE/pre-* $HERE/post-*
cd $HERE/project
rm BitKeeper/triggers/*
cat > BitKeeper/triggers/post-incoming <<EOF
#!/bin/bash
echo I am the post-incoming trigger
set | grep $DASHA ^BK | grep -v _BK_ | bk _sort > $HERE/post-incoming
exit 1
EOF
chmod +x BitKeeper/triggers/*
cd $HERE/clone
ls > whatever
bk new $Q whatever
bk commit -ywhatever $Q
cd $HERE/project
bk pull -R $HERE/clone > OUT 2>&1 || {
	echo pull should not have failed
	exit 1
}
test -d RESYNC || {
	echo failed to leave RESYNC
	exit 1
}
test -f $HERE/post-incoming && {
	echo should not have run trigger, we did not finish
	exit 1
}
echo OK

echo $N Make sure resolve does run the post-incoming ................$NL
rm -f $HERE/post-incoming
bk resolve >OUT 2>&1 || {
	echo resolve should not have failed
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -f $HERE/post-incoming || {
	echo should have run trigger, we did finish
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ====== resolve post-incoming ==========
	cat $HERE/post-incoming
}

echo $N Fail a push in pre-resolve and make sure we clean up ........$NL
cd $HERE/project
bk undo -qsfr+
rm BitKeeper/triggers/*
cat > BitKeeper/triggers/pre-resolve <<EOF
#!/bin/bash
echo pre-resolve failing
set | grep $DASHA ^BK | grep -v _BK_ | bk _sort >> $HERE/pre-resolve
exit 1
EOF
chmod +x BitKeeper/triggers/*
waitForUnlock $HERE/project
cd $HERE/clone
rm -f BitKeeper/triggers/* $HERE/pre-resolve
bk push > OUT 2>&1 && {
	echo push should have failed
	cat OUT
	exit 1
}
test -d ../project/RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -d ../project/PENDING && {
	echo failed to clean up PENDING
	exit 1
}
grep -q 'pre-resolve failing' OUT || {
	echo failed to pass back trigger output
	cat OUT
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ====== pre-resolve ==========
	cat $HERE/pre-resolve
}

echo $N Exit 2 out of a pre-resolve, make sure it leaves the patch ..$NL
cd $HERE/project
rm -rf PENDING
rm BitKeeper/triggers/*
cat > BitKeeper/triggers/pre-resolve <<EOF
#!/bin/bash
echo pre-resolve failing but leaving patch
set | grep $DASHA ^BK | grep -v _BK_ | bk _sort >> $HERE/pre-resolve
exit 2
EOF
chmod +x BitKeeper/triggers/*
cd $HERE/clone
rm -f BitKeeper/triggers/* $HERE/pre-resolve
bk push > OUT 2>&1 && {
	echo push should have failed
	exit 1
}
test -d ../project/RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -d ../project/PENDING || {
	echo failed to leave PENDING
	exit 1
}
grep -q 'pre-resolve failing but leaving patch' OUT || {
	echo failed to pass back trigger output
	cat OUT
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ====== pre-resolve ==========
	cat $HERE/pre-resolve
}

echo $N Make sure we see BK_PATCH in the pre-resolve trigger ........$NL
cd ../project/PENDING || exit 1
GOT=`grep BK_PATCH= $HERE/pre-resolve`
test "X$GOT" = X && {
	echo Failed
	cat $HERE/pre-resolve
	exit 1
}
BK_PATCH='no such file'
eval $GOT
test -f "$BK_PATCH" || {
	echo Failed
	cat $HERE/pre-resolve
	exit 1
}
echo OK

echo $N Look for cset list in pre-resolve in the push ...............$NL
cd $HERE/clone
cat > $HERE/project/BitKeeper/triggers/pre-resolve <<EOF
#!/bin/bash
bk changes - < \$BK_CSETLIST > $HERE/changes
exit 1
EOF
chmod +x $HERE/project/BitKeeper/triggers/*
bk push $Q && {
	echo failed to exit nonzero
	exit 1
}
test -d $HERE/project/RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -s $HERE/changes || {
	echo failed to create change list
	exit 1
}
grep -q ChangeSet@1.5 $HERE/changes || 
grep -q ChangeSet@1.6 $HERE/changes || {
	echo failed to list the ChangeSet
	cat $HERE/changes
	exit 1
}
echo OK

echo $N Look for cset list in post in the push ......................$NL
cd $HERE/clone
rm $HERE/project/BitKeeper/triggers/* $HERE/changes
cat > $HERE/project/BitKeeper/triggers/post-incoming <<EOF
#!/bin/bash
bk changes - < \$BK_CSETLIST > $HERE/changes
exit 0
EOF
chmod +x $HERE/project/BitKeeper/triggers/*
bk push $Q || {
	echo failed to exit zero, exited $?
	exit 1
}
test -s $HERE/changes || {
	echo failed to create change list
	exit 1
}
grep -q ChangeSet@1.5 $HERE/changes || 
grep -q ChangeSet@1.6 $HERE/changes || {
	echo failed to list the ChangeSet
	exit 1
}
echo OK

cd $HERE
rm -rf *

echo $N Create initial repository ...................................$NL
commercial project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
mkdir src
cd src
echo foo > foo.c
echo bar > bar.c
echo h > h.h
bk ci $Q -i foo.c bar.c h.h
if [ ! -f SCCS/s.foo.c ]; then echo failed to create history; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 15 ]; then echo wrong pending result $P; bk pending; exit 1; fi
bk commit $S -a -yCset
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo failed to clear pending list; bk pending; exit 1; fi
echo OK
cores

echo $N Create trivial server side triggers .........................$NL
cd $HERE
mkdir project/BitKeeper/triggers || exit 1
cd project/BitKeeper/triggers
echo "#! /bin/sh"                > good
#echo "echo \`bk root\`/\$0: trigger fired"	>> good
echo "bk root"			>> good
echo "PROOT=\`bk root\`"			>> good
echo "echo \$PROOT/\$0: trigger fired"	>> good
echo "exit 0"                   >> good
bk undos good > X
chmod +x X
for x in pre post;do
	for y in commit incoming outgoing;do
		cp X $x-$y
	done
done

# Overwrite the pre incoming trigger with a more interesting one
cat >good2 <<EOF
#!/bin/bash
echo "\`bk root\`/\$0: trigger fired"
test "X$BK_RESYNC" = XFALSE || exit 0
if [ ! -d RESYNC ]; then echo "missing RESYNC TREE"; exit 1; fi
if [ X\$BK_OUTGOING_USER != X`bk getuser` ]; then echo "Wrong user"; exit 1; fi
echo "post-incoming trigger: user=\$BK_OUTGOING_USER"
REV=\`cat RESYNC/BitKeeper/etc/csets-in\`
echo "incoming rev=\$REV"
for i in $REV
do	echo ChangeSet${BK_FS}$i
done | bk prs -h -
exit 0
EOF
bk undos good2 > pre-incoming
chmod +x pre-incoming

cd $HERE
echo "OK"

echo $N Clone w/trivial triggers ....................................$NL
cd $HERE
bk clone $Q $HERE/project $HERE/copy 2> /dev/null || { echo failed; exit 1; }
echo OK

echo $N Create trivial client side triggers .........................$NL
cd $HERE
mkdir copy/BitKeeper/triggers || exit 1
cd copy/BitKeeper/triggers
echo "#! /bin/sh"                > good
echo "echo \`bk root\`/\$0: trigger fired"	>> good
echo "exit 0"                   >> good
chmod +x good
for x in pre post;do
	for y in commit incoming outgoing;do
		cp good $x-$y
	done
done
cd $HERE
echo "OK"

echo $N Make sure delta fails with pre-delta trigger ................$NL
cp -rp $HERE/project $HERE/delta
cd $HERE/delta/BitKeeper/triggers
cat > pre-delta <<EOF
#!/bin/bash

set | grep $DASHA ^BK | grep -v _BK_ | bk _sort > $HERE/pre-delta
echo You bozo, you forgot to cstyle \$BK_FILE
exit 1
EOF
chmod +x pre-delta
cd $HERE/delta/src
bk get $Q -e foo.c
echo bad form, dude >> foo.c
bk delta $Q -y'This is a multi
line comment,
to test if that works' foo.c > OUT 2>&1 && {
	echo delta should have failed
	exit 1
}
test -f SCCS/p.foo.c || {
	echo delta should have failed
	exit 1
}
grep -q 'you forgot to cstyle foo.c' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
grep -q BK_FILE= $HERE/pre-delta || {
	echo failed to set BK_FILE
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ====== pre-delta ==========
	cat $HERE/pre-delta
}

if [ X$BK_TESTGUI != X ]; then
    echo $N citool w/failing pre-delta trigger...........................$NL
    bk citool
    echo OK
    echo $N citool w/working pre-delta trigger...........................$NL
    cd $HERE/delta/BitKeeper/triggers
    cat > pre-delta <<EOF
#!/bin/bash

echo You bozo, you forgot to cstyle \$BK_FILE
echo I am letting slide just this once.
exit 0
EOF
    bk citool
    echo OK
fi

echo $N Test that a pre-delta trigger will work from command line ...$NL
cd $HERE
cp -rp delta aaron
cd $HERE/aaron/BitKeeper/triggers
cat > pre-delta <<EOF
#!/bin/bash

echo You bozo, you forgot to cstyle \$BK_FILE
echo I am letting slide just this once.
exit 0
EOF
cd $HERE/aaron/src
bk get $Q -e foo.c
echo bad form, dude >> foo.c
bk ci -p -ywhatever foo.c > OUT 2>&1
test -f SCCS/p.foo.c && {
	echo failed to do the delta
	cat OUT
	exit 1
}
grep -q 'bad form, dude' OUT || {
	echo bad diffs
	cat OUT
	exit 1
}
echo OK

echo $N Test that a pre-delta trigger can delta the file ............$NL
cd $HERE/delta/BitKeeper/triggers
cat > pre-delta <<EOF
#!/bin/bash

bk delta -y'I am the trigger' $BK_FILE
exit 2
EOF
chmod +x pre-delta
cd $HERE/delta/src
bk get $Q -e foo.c
echo bad form, dude >> foo.c
echo Bad comment > SCCS/c.foo.c
bk delta foo.c >OUT 2>&1 < /dev/null || {
	echo should not have errored
	cat OUT
	exit 1
}
test -f SCCS/c.foo.c && {
	echo should have cleaned up c.file
	cat OUT
	exit 1
}
test 'I am the trigger' = "`bk prs -hr+ -d:C: foo.c`" || {
	echo set the wrong comment
	bk prs foo.c
	cat OUT
	exit 1
}
echo OK

cd $HERE
rm -rf delta

echo $N Commit w/trivial triggers ...................................$NL
cd $HERE/project/src
bk get $Q -e foo.c
echo 3 >> foo.c
bk delta $Q -y2 foo.c
bk commit $Q -y2 > /dev/null 2>&1 || { echo failed; exit 1; }
echo OK

if [ X$BK_TESTGUI != X ]; then
    echo $N citool w/trivial triggers ...................................$NL
    cd $HERE/project/src
    bk get $Q -e foo.c
    echo delta three >> foo.c
    bk delta $Q -y2 foo.c
    bk citool
    echo OK
fi

echo $N Pull w/trivial triggers .....................................$NL
cd $HERE/copy
bk pull -t >pull.out 2>&1 || { echo failed; exit 1; }
grep -q "1.3" pull.out
if [ $? -ne 0 ]; then echo failed 2; cat pull.out; exit 1; fi
grep -q "project/.*BitKeeper/triggers/pre-outgoing: trigger fired" pull.out
if [ $? -ne 0 ]; then echo failed 3; cat pull.out; exit 1; fi
grep -q "project/.*BitKeeper/triggers/post-outgoing: trigger fired" pull.out
if [ $? -ne 0 ]; then echo failed 4; cat pull.out; exit 1; fi
grep -q "copy/.*BitKeeper/triggers/pre-incoming: trigger fired" pull.out
if [ $? -ne 0 ]; then echo failed 5; cat pull.out; exit 1; fi
grep -q "/copy/.*BitKeeper/triggers/post-incoming: trigger fired" pull.out
if [ $? -ne 0 ]; then echo failed 6; cat pull.out; exit 1; fi
echo OK

echo $N Push w/trivial triggers .....................................$NL
cd $HERE/copy/src
bk get $Q -e foo.c
echo 4 >> foo.c
bk delta $Q -y2 foo.c
bk commit $Q -y"cset comment for 1.4" > /dev/null 2>&1
bk push >push.out 2>&1 || { echo failed; cat push.out; exit 1; }
echo OK

echo $N Check BK_STATUS in push and push -n and pull -n .............$NL
cd $HERE/project/BitKeeper/triggers
rm -f *
bk undos > pre-incoming <<EOF
#!/bin/bash
set | grep $DASHA BK_STATUS
EOF
cp pre-incoming pre-outgoing

chmod +x pre*
cd $HERE/copy
rm -f BitKeeper/triggers/*
bk push -n >push.out 2>&1 || { echo failed; cat push.out; exit 1; }
grep -q BK_STATUS=DRYRUN push.out || {
	echo Failed
	cat push.out
	exit 1
}
bk push >push.out 2>&1 || { echo failed; cat push.out; exit 1; }
grep -q BK_STATUS=DRYRUN push.out && {
	echo Failed
	cat push.out
	exit 1
}
bk pull -n >pull.out 2>&1 || { echo failed; cat pull.out; exit 1; }
grep -q BK_STATUS=DRYRUN pull.out || {
	echo Failed
	cat push.out
	exit 1
}
cd $HERE/project/BitKeeper/triggers
rm -f *
echo OK

echo $N Create failure triggers .....................................$NL
cd $HERE
cd project/BitKeeper/triggers
echo "#! /bin/sh"                > bad
echo "echo negative trigger"	>> bad
echo "exit 1"                   >> bad
chmod +x bad
for y in commit incoming outgoing;do
	cp -f bad pre-$y
done
echo "OK"

echo $N Clone w/failure triggers ....................................$NL
cd $HERE
bk clone $Q $HERE/project $HERE/dontcopy && { echo failed; exit 1; }
cd $HERE/project
echo OK

echo $N Commit w/failure triggers ...................................$NL
cd $HERE/project/src
bk get $Q -e foo.c
echo delta four >> foo.c
bk delta $Q -y2 foo.c
bk commit $Q -y2 > /dev/null && { echo failed; exit 1; }
echo OK

#if [ X$BK_TESTGUI != X ]; then
#    echo $N citool w/failure triggers ...................................$NL
#    cd $HERE/project/src
#    bk get $Q -e foo.c
#    echo delta five >> foo.c
#    bk delta $Q -y2 foo.c
#    bk citool
#    echo OK
#fi

echo $N Pull w/failure triggers .....................................$NL
rm -f $HERE/project/BitKeeper/triggers/*-commit
rm -rf $HERE/copy/BitKeeper/triggers
cd $HERE/project/src
bk get $Q -e foo.c
echo 5 >> foo.c
bk delta $Q -y2 foo.c
bk commit $Q -y2 

cd $HERE/copy
bk pull -t -c0 $Q && { echo failed; exit 1; }
bk lock -s || { echo failed; exit 1; }

# clean up
cd $HERE/project/src
bk undo -qfr+
echo OK

cd $HERE/copy
echo $N Push w/failure triggers .....................................$NL
cd $HERE/copy/src
bk get $Q -e foo.c
echo delta two >> foo.c
bk delta $Q -y2 foo.c
bk commit $Q -y2 || { echo failed; exit 1; }

bk push -c0 $Q && { echo failed 1; exit 1; }
bk lock -s || { echo failed 2; exit 1; }
echo OK

echo $N auto-mirroring ..............................................$NL
cd $HERE/project/BitKeeper/triggers
rm -f *
while ! bk lock -ls
do	#echo waiting for the repository to become unlocked
	sleep 1
done
bk clone $Q $HERE/project $HERE/backup || exit 1
cd $HERE/project/BitKeeper/triggers
cat > post-incoming <<EOF
#!/bin/bash
bk push $Q $HERE/backup || echo Failed to mirror the repository
EOF
chmod +x post-incoming
cd $HERE/copy/src
echo data > car.c
bk new $Q car.c
bk commit $Q -y3  
bk push $Q $HERE/project || { echo failed; exit 1; }
cd $HERE/backup
TRY=0
while [ $TRY -lt 10 ] 
do
	if [ -f $HERE/backup/src/SCCS/s.car.c ]; then break; fi
	sleep 1
	TRY=`expr $TRY + 1`
done
if [ ! -f $HERE/backup/src/SCCS/s.car.c ]; then echo failed; exit 1; fi
echo OK

echo $N Make sure we run triggers on a merge commit .................$NL
cd $HERE/project/BitKeeper/triggers
rm -f *
while ! bk lock -ls
do	#echo waiting for the repository to become unlocked
	sleep 1
done
bk clone $Q $HERE/project $HERE/merge || exit 1
cat > post-commit <<EOF
#!/bin/bash
set | grep ^BK > $HERE/merge-commit
EOF
chmod +x post-commit
cd $HERE/project
echo foo > foo
bk new $Q foo
bk commit $Q -ywhatever
rm -f $HERE/merge-commit
cd $HERE/merge
echo bar > bar
bk new $Q bar
bk commit $Q -ywhatever
cd $HERE/project
bk pull $Q $HERE/merge || {
	echo should have succeeded
	exit 1
}
test -f $HERE/merge-commit || {
	echo failed to run trigger
	exit 1
}
echo OK

echo $N Modify comment in pre-commit trigger ........................$NL
cd $HERE
commercial comment-chk
trig=BitKeeper/triggers
mkdir -p $trig
cat > $trig/pre-commit.comments <<'EOF'
#!/bin/sh
tr '[a-z]' '[A-Z]' > $BK_TMP/comment$$ < $BK_COMMENTFILE
mv $BK_TMP/comment$$ $BK_COMMENTFILE
EOF
chmod +x $trig/*
touch foo
bk new $Q foo
bk commit $Q -y'upper case' || exit 1
bk prs -r+ -hnd:COMMENTS: ChangeSet | grep -q "UPPER CASE" || {
	echo Failed
	exit 1
}
echo OK

echo $N Check commit w perl trigger .................................$NL
cd $HERE
commercial proj2
bk edit $Q BitKeeper/etc/config
echo "checkout: get" >> BitKeeper/etc/config
bk delta $Q -ycheckout BitKeeper/etc/config
bk commit $Q -ycheckout
mkdir BitKeeper/triggers
PERL=`type perl | awk '{ print $NF }'`
echo $PERL | grep -q "not found"  && { echo failed; exit 1; }
cat > BitKeeper/triggers/pre-commit <<EOF
#! $PERL -w
print "I am in perl";
EOF
chmod +x BitKeeper/triggers/pre-commit
echo h > h.h
bk ci $Q -i h.h
bk commit $S -a -yCset > $HERE/out
grep -q "I am in perl" $HERE/out || { echo failed; cat $HERE/out; exit 1; }
echo OK

if [ "$PLATFORM" = "WIN32" ]
then
echo $N Check commit w Windows Batch file trigger ...................$NL
cat > BitKeeper/triggers/pre-commit.bat <<EOF
@ECHO OFF
REM This is a remark
echo "I am a Windows BATCH file"
EOF
bk edit $Q h.h
echo "h2" > h.h
bk delta $Q -yh2 h.h
bk commit $S -a -yCset_bat > $HERE/out
grep -q "I am a Windows BATCH file" $HERE/out || { echo failed; exit 1; }
echo OK

echo $N Check commit w bogus shell ..................................$NL
cat > BitKeeper/triggers/pre-commit <<EOF
#!c:/bogus.exe
exit 0
EOF
bk edit $Q h.h
echo "h2" > h.h
bk delta $Q -yh3 h.h
bk commit $S -a -yCset_h3 2> $HERE/out
grep -q "Cannot expand shell path" $HERE/out || { echo failed; exit 1; }
echo OK
fi

echo $N Check that delta does NOT work in repo with trigger .........$NL
# create a pre-delta trigger that should prevent delta from working and 
# initial sanity check
cd $HERE
commercial proj3
echo foo >foo
bk new $Q foo
cd $HERE/proj3
mkdir BitKeeper/triggers
cat >BitKeeper/triggers/pre-delta <<EOF
#!/bin/bash
exit 1
EOF
chmod +x BitKeeper/triggers/*
cd $HERE/proj3
bk edit $Q foo 
bk delta $Q -yfoo foo && {
	echo Failed
	exit 1 
}
echo OK

echo $N Check delta does NOT work with trigger NOT checked out ......$NL
cd $HERE/proj3
# we have to ignore the pre-delta trigger (since it exit 1) when
# checking in the pre-delta trigger...
BK_NO_TRIGGERS=1 bk new $Q BitKeeper/triggers/pre-delta || exit 1
bk edit $Q foo 
bk delta $Q -ybar foo 2>/dev/null && {
	echo "failed (bug 2005-04-13-001)"
	exit 1
}
echo OK
