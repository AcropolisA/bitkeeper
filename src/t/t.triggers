# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

if [ X$PLATFORM = X"WIN32" ]
then
        # It is unlikely in that ssh/rsh to localhost will work on NT.
        # We let the user tell us otherwise.
        if [ -z "$DO_REMOTE" ]; then DO_REMOTE=NO; fi
else
	if [ -z "$DO_REMOTE" ]; then DO_REMOTE=YES; fi
fi

# Tests to see if triggers work.
echo $N Create initial repository ...................................$NL
no_logging project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
mkdir src
cd src
echo foo > foo.c
echo bar > bar.c
echo h > h.h
bk ci $Q -i foo.c bar.c h.h
if [ ! -f SCCS/s.foo.c ]; then echo failed to create history; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 15 ]; then echo wrong pending result $P; bk pending; exit 1; fi
bk commit $S -a -yCset
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo failed to clear pending list; bk pending; exit 1; fi
echo OK
cores

echo $N Create trivial server side triggers .........................$NL
cd $HERE
mkdir project/BitKeeper/triggers || exit 1
cd project/BitKeeper/triggers
echo "#! /bin/sh"                > good
#echo "echo \`bk root\`/\$0: trigger fired"	>> good
echo "bk root"			>> good
echo "PROOT=\`bk root\`"			>> good
echo "echo \$PROOT/\$0: trigger fired"	>> good
echo "exit 0"                   >> good
bk undos good > X
chmod +x X
for x in pre post;do
	for y in commit incoming outgoing;do
		cp X $x-$y
	done
done

# Overwrite the post incommong trigger with a more interesting one
cat >good2 <<EOF
#! /bin/sh
echo "\`bk root\`/\$0: trigger fired"
if [ ! -d RESYNC ]; then echo "missing RESYNC TREE"; exit 1; fi
if [ X\$BK_CLIENT_USER != X`bk getuser` ]; then echo "Wrong user"; exit 1; fi
echo "post-incoming trigger: user=\$BK_CLIENT_USER"
REV=\`cat RESYNC/BitKeeper/etc/csets-in\`
echo "incoming rev=\$REV"
bk prs -hnr\$REV RESYNC/ChangeSet
exit 0
EOF
bk undos good2 > pre-incoming
chmod +x pre-incoming

cd $HERE
echo "OK"

echo $N Clone w/trivial triggers ....................................$NL
cd $HERE
bk clone $Q $HERE/project $HERE/copy 2> /dev/null || { echo failed; exit 1; }
echo OK

echo $N Create trivial client side triggers .........................$NL
cd $HERE
mkdir copy/BitKeeper/triggers || exit 1
cd copy/BitKeeper/triggers
echo "#! /bin/sh"                > good
echo "echo \`bk root\`/\$0: trigger fired"	>> good
echo "exit 0"                   >> good
chmod +x good
for x in pre post;do
	for y in commit incoming outgoing;do
		cp good $x-$y
	done
done
cd $HERE
echo "OK"

echo $N Commit w/trivial triggers ...................................$NL
cd $HERE/project/src
bk get $Q -e foo.c
echo 3 >> foo.c
bk delta $Q -y2 foo.c
bk commit $Q -y2 > /dev/null 2>&1 || { echo failed; exit 1; }
echo OK

if [ X$BK_TESTGUI != X ]; then
    echo $N citool w/trivial triggers ...................................$NL
    cd $HERE/project/src
    bk get $Q -e foo.c
    echo delta three >> foo.c
    bk delta $Q -y2 foo.c
    bk citool
    echo OK
fi

echo $N Pull w/trivial triggers .....................................$NL
cd $HERE/copy
bk pull -t >pull.out 2>&1 || { echo failed; exit 1; }
cd $HERE/project
while ! bk lock -s; do true; done
cd $HERE/copy
grep -q "1.3" pull.out
if [ $? -ne 0 ]; then echo failed 2; cat pull.out; exit 1; fi
grep -q "$HERE/project/BitKeeper/triggers/pre-outgoing: trigger fired" pull.out
if [ $? -ne 0 ]; then echo failed 3; cat pull.out; exit 1; fi
grep -q "$HERE/project/BitKeeper/triggers/post-outgoing: trigger fired" pull.out
if [ $? -ne 0 ]; then echo failed 4; cat pull.out; exit 1; fi
grep -q "$HERE/copy/BitKeeper/triggers/pre-incoming: trigger fired" pull.out
if [ $? -ne 0 ]; then echo failed 5; cat pull.out; exit 1; fi
grep -q "$HERE/copy/BitKeeper/triggers/post-incoming: trigger fired" pull.out
if [ $? -ne 0 ]; then echo failed 6; cat pull.out; exit 1; fi
echo OK

echo $N Push w/trivial triggers .....................................$NL
cd $HERE/copy/src
bk get $Q -e foo.c
echo 4 >> foo.c
bk delta $Q -y2 foo.c
bk commit $Q -y"cset comment for 1.4" > /dev/null 2>&1

bk push >push.out 2>&1 || { echo failed; exit 1; }
# Importtant: must wait for the remote tree to unlock before we 
# check the output file
cd $HERE/project
while ! bk lock -s; do true; done
cd $HERE/copy/src
grep -q "$HERE/project/BitKeeper/triggers/pre-incoming: trigger fired" push.out
if [ $? -ne 0 ]; then echo failed 2; cat push.out; exit 1; fi
grep -q "$HERE/project/BitKeeper/triggers/post-incoming: trigger fired" push.out
if [ $? -ne 0 ]; then echo failed 4; cat push.out; exit 1; fi
grep -q "$HERE/copy/BitKeeper/triggers/pre-outgoing: trigger fired" push.out
if [ $? -ne 0 ]; then echo failed 5; cat push.out; exit 1; fi
grep -q "$HERE/copy/BitKeeper/triggers/post-outgoing: trigger fired" push.out
if [ $? -ne 0 ]; then echo failed 6; cat push.out; exit 1; fi
grep -q "post-incoming trigger: user=`bk getuser`" push.out
if [ $? -ne 0 ]; then echo failed 7; cat push.out; exit 1; fi
grep -q "incoming rev=1.4" push.out
if [ $? -ne 0 ]; then echo failed 8; cat push.out; exit 1; fi
grep -q "C cset comment for 1.4" push.out 
if [ $? -ne 0 ]; then echo failed 9; cat push.out; exit 1; fi
# Wait for the remote push process to exit before we remove the trigger
cd $HERE/project/BitKeeper/triggers
rm -f *
echo OK

echo $N Create failure triggers .....................................$NL
cd $HERE
cd project/BitKeeper/triggers
echo "#! /bin/sh"                > bad
echo "echo negative trigger"	>> bad
echo "exit 1"                   >> bad
chmod +x bad
for y in commit incoming outgoing;do
	cp -f bad pre-$y
done
echo "OK"

echo $N Clone w/failure triggers ....................................$NL
cd $HERE
bk clone $Q $HERE/project $HERE/dontcopy && { echo failed; exit 1; }
cd $HERE/project
while ! bk lock -s; do true; done
echo OK

echo $N Commit w/failure triggers ...................................$NL
cd $HERE/project/src
bk get $Q -e foo.c
echo delta four >> foo.c
bk delta $Q -y2 foo.c
bk commit $Q -y2 > /dev/null && { echo failed; exit 1; }
echo OK

#if [ X$BK_TESTGUI != X ]; then
#    echo $N citool w/failure triggers ...................................$NL
#    cd $HERE/project/src
#    bk get $Q -e foo.c
#    echo delta five >> foo.c
#    bk delta $Q -y2 foo.c
#    bk citool
#    echo OK
#fi

echo $N Pull w/failure triggers .....................................$NL
rm -f $HERE/project/BitKeeper/triggers/*-commit
rm -rf $HERE/copy/BitKeeper/triggers
cd $HERE/project/src
bk get $Q -e foo.c
echo 5 >> foo.c
bk delta $Q -y2 foo.c
bk commit $Q -y2 

cd $HERE/copy
bk pull -t -c0 $Q && { echo failed; exit 1; }
bk lock -s || { echo failed; exit 1; }

# clean up
cd $HERE/project/src
bk undo -qfr+
echo OK

cd $HERE/copy
echo $N Push w/failure triggers .....................................$NL
cd $HERE/copy/src
bk get $Q -e foo.c
echo delta two >> foo.c
bk delta $Q -y2 foo.c
bk commit $Q -y2 || { echo failed; exit 1; }

bk push -c0 $Q && { echo failed 1; exit 1; }
bk lock -s || { echo failed 2; exit 1; }
echo OK
echo $N auto-mirroring ..............................................$NL
cd $HERE/project/BitKeeper/triggers
rm -f *
cd $HERE/project
while ! bk lock -s; do true; done
bk clone $Q $HERE/project $HERE/backup
cd $HERE/project/BitKeeper/triggers
echo "#! /bin/sh"			> post-incoming
echo "echo Auto_mirror 1>\&2"	>> post-incoming
echo "bk push -q $HERE/backup"	>> post-incoming
chmod +x post-incoming
cd $HERE/copy/src
echo data > car.c
bk new $Q car.c
bk commit $Q -y3  
bk push $Q $HERE/project || { echo failed; exit 1; }
cd $HERE/backup
TRY=0
while [ $TRY -lt 10 ] 
do
	if [ -f $HERE/backup/src/SCCS/s.car.c ]; then break; fi
	sleep 1
	TRY=`expr $TRY + 1`
done
if [ ! -f $HERE/backup/src/SCCS/s.car.c ]; then echo failed; exit 1; fi
echo OK
